<!DOCTYPE html>
<html class="staticrypt-html">
    <head>
        <meta charset="utf-8" />
        <title>Protected Page</title>
        <meta name="viewport" content="width=device-width, initial-scale=1" />

        <!-- do not cache this page -->
        <meta http-equiv="cache-control" content="max-age=0" />
        <meta http-equiv="cache-control" content="no-cache" />
        <meta http-equiv="expires" content="0" />
        <meta http-equiv="expires" content="Tue, 01 Jan 1980 1:00:00 GMT" />
        <meta http-equiv="pragma" content="no-cache" />

        <style>
            .staticrypt-hr {
                margin-top: 20px;
                margin-bottom: 20px;
                border: 0;
                border-top: 1px solid #eee;
            }

            .staticrypt-page {
                width: 360px;
                padding: 8% 0 0;
                margin: auto;
                box-sizing: border-box;
            }

            .staticrypt-form {
                position: relative;
                z-index: 1;
                background: #ffffff;
                max-width: 360px;
                margin: 0 auto 100px;
                padding: 45px;
                text-align: center;
                box-shadow: 0 0 20px 0 rgba(0, 0, 0, 0.2), 0 5px 5px 0 rgba(0, 0, 0, 0.24);
            }

            .staticrypt-form input[type="password"] {
                outline: 0;
                background: #f2f2f2;
                width: 100%;
                border: 0;
                margin: 0 0 15px;
                padding: 15px;
                box-sizing: border-box;
                font-size: 14px;
            }

            .staticrypt-form .staticrypt-decrypt-button {
                text-transform: uppercase;
                outline: 0;
                background: #4CAF50;
                width: 100%;
                border: 0;
                padding: 15px;
                color: #ffffff;
                font-size: 14px;
                cursor: pointer;
            }

            .staticrypt-form .staticrypt-decrypt-button:hover,
            .staticrypt-form .staticrypt-decrypt-button:active,
            .staticrypt-form .staticrypt-decrypt-button:focus {
                background: #4CAF50;
                filter: brightness(92%);
            }

            .staticrypt-html {
                height: 100%;
            }

            .staticrypt-body {
                height: 100%;
                margin: 0;
            }

            .staticrypt-content {
                height: 100%;
                margin-bottom: 1em;
                background: #76B852;
                font-family: "Arial", sans-serif;
                -webkit-font-smoothing: antialiased;
                -moz-osx-font-smoothing: grayscale;
            }

            .staticrypt-instructions {
                margin-top: -1em;
                margin-bottom: 1em;
            }

            .staticrypt-title {
                font-size: 1.5em;
            }

            label.staticrypt-remember {
                display: flex;
                align-items: center;
                margin-bottom: 1em;
            }

            .staticrypt-remember input[type="checkbox"] {
                transform: scale(1.5);
                margin-right: 1em;
            }

            .hidden {
                display: none !important;
            }

            .staticrypt-spinner-container {
                height: 100%;
                display: flex;
                align-items: center;
                justify-content: center;
            }

            .staticrypt-spinner {
                display: inline-block;
                width: 2rem;
                height: 2rem;
                vertical-align: text-bottom;
                border: 0.25em solid gray;
                border-right-color: transparent;
                border-radius: 50%;
                -webkit-animation: spinner-border 0.75s linear infinite;
                animation: spinner-border 0.75s linear infinite;
                animation-duration: 0.75s;
                animation-timing-function: linear;
                animation-delay: 0s;
                animation-iteration-count: infinite;
                animation-direction: normal;
                animation-fill-mode: none;
                animation-play-state: running;
                animation-name: spinner-border;
            }

            @keyframes spinner-border {
                100% {
                    transform: rotate(360deg);
                }
            }
        </style>
    </head>

    <body class="staticrypt-body">
        <div id="staticrypt_loading" class="staticrypt-spinner-container">
            <div class="staticrypt-spinner"></div>
        </div>

        <div id="staticrypt_content" class="staticrypt-content hidden">
            <div class="staticrypt-page">
                <div class="staticrypt-form">
                    <div class="staticrypt-instructions">
                        <p class="staticrypt-title">bahahahahaha</p>
                        <p></p>
                    </div>

                    <hr class="staticrypt-hr" />

                    <form id="staticrypt-form" action="#" method="post">
                        <input
                            id="staticrypt-password"
                            type="password"
                            name="password"
                            placeholder="Password"
                            autofocus
                        />

                        <label id="staticrypt-remember-label" class="staticrypt-remember hidden">
                            <input id="staticrypt-remember" type="checkbox" name="remember" />
                            Remember me
                        </label>

                        <input type="submit" class="staticrypt-decrypt-button" value="DECRYPT" />
                    </form>
                </div>
            </div>
        </div>

        <script>
            // these variables will be filled when generating the file - the template format is 'variable_name'
            const staticryptInitiator = 
            ((function(){
  const exports = {};
  const cryptoEngine = ((function(){
  const exports = {};
  const { subtle } = crypto;

const IV_BITS = 16 * 8;
const HEX_BITS = 4;
const ENCRYPTION_ALGO = "AES-CBC";

/**
 * Translates between utf8 encoded hexadecimal strings
 * and Uint8Array bytes.
 */
const HexEncoder = {
    /**
     * hex string -> bytes
     * @param {string} hexString
     * @returns {Uint8Array}
     */
    parse: function (hexString) {
        if (hexString.length % 2 !== 0) throw "Invalid hexString";
        const arrayBuffer = new Uint8Array(hexString.length / 2);

        for (let i = 0; i < hexString.length; i += 2) {
            const byteValue = parseInt(hexString.substring(i, i + 2), 16);
            if (isNaN(byteValue)) {
                throw "Invalid hexString";
            }
            arrayBuffer[i / 2] = byteValue;
        }
        return arrayBuffer;
    },

    /**
     * bytes -> hex string
     * @param {Uint8Array} bytes
     * @returns {string}
     */
    stringify: function (bytes) {
        const hexBytes = [];

        for (let i = 0; i < bytes.length; ++i) {
            let byteString = bytes[i].toString(16);
            if (byteString.length < 2) {
                byteString = "0" + byteString;
            }
            hexBytes.push(byteString);
        }
        return hexBytes.join("");
    },
};

/**
 * Translates between utf8 strings and Uint8Array bytes.
 */
const UTF8Encoder = {
    parse: function (str) {
        return new TextEncoder().encode(str);
    },

    stringify: function (bytes) {
        return new TextDecoder().decode(bytes);
    },
};

/**
 * Salt and encrypt a msg with a password.
 */
async function encrypt(msg, hashedPassword) {
    // Must be 16 bytes, unpredictable, and preferably cryptographically random. However, it need not be secret.
    // https://developer.mozilla.org/en-US/docs/Web/API/SubtleCrypto/encrypt#parameters
    const iv = crypto.getRandomValues(new Uint8Array(IV_BITS / 8));

    const key = await subtle.importKey("raw", HexEncoder.parse(hashedPassword), ENCRYPTION_ALGO, false, ["encrypt"]);

    const encrypted = await subtle.encrypt(
        {
            name: ENCRYPTION_ALGO,
            iv: iv,
        },
        key,
        UTF8Encoder.parse(msg)
    );

    // iv will be 32 hex characters, we prepend it to the ciphertext for use in decryption
    return HexEncoder.stringify(iv) + HexEncoder.stringify(new Uint8Array(encrypted));
}
exports.encrypt = encrypt;

/**
 * Decrypt a salted msg using a password.
 *
 * @param {string} encryptedMsg
 * @param {string} hashedPassword
 * @returns {Promise<string>}
 */
async function decrypt(encryptedMsg, hashedPassword) {
    const ivLength = IV_BITS / HEX_BITS;
    const iv = HexEncoder.parse(encryptedMsg.substring(0, ivLength));
    const encrypted = encryptedMsg.substring(ivLength);

    const key = await subtle.importKey("raw", HexEncoder.parse(hashedPassword), ENCRYPTION_ALGO, false, ["decrypt"]);

    const outBuffer = await subtle.decrypt(
        {
            name: ENCRYPTION_ALGO,
            iv: iv,
        },
        key,
        HexEncoder.parse(encrypted)
    );

    return UTF8Encoder.stringify(new Uint8Array(outBuffer));
}
exports.decrypt = decrypt;

/**
 * Salt and hash the password so it can be stored in localStorage without opening a password reuse vulnerability.
 *
 * @param {string} password
 * @param {string} salt
 * @returns {Promise<string>}
 */
async function hashPassword(password, salt) {
    // we hash the password in multiple steps, each adding more iterations. This is because we used to allow less
    // iterations, so for backward compatibility reasons, we need to support going from that to more iterations.
    let hashedPassword = await hashLegacyRound(password, salt);

    hashedPassword = await hashSecondRound(hashedPassword, salt);

    return hashThirdRound(hashedPassword, salt);
}
exports.hashPassword = hashPassword;

/**
 * This hashes the password with 1k iterations. This is a low number, we need this function to support backwards
 * compatibility.
 *
 * @param {string} password
 * @param {string} salt
 * @returns {Promise<string>}
 */
function hashLegacyRound(password, salt) {
    return pbkdf2(password, salt, 1000, "SHA-1");
}
exports.hashLegacyRound = hashLegacyRound;

/**
 * Add a second round of iterations. This is because we used to use 1k, so for backwards compatibility with
 * remember-me/autodecrypt links, we need to support going from that to more iterations.
 *
 * @param hashedPassword
 * @param salt
 * @returns {Promise<string>}
 */
function hashSecondRound(hashedPassword, salt) {
    return pbkdf2(hashedPassword, salt, 14000, "SHA-256");
}
exports.hashSecondRound = hashSecondRound;

/**
 * Add a third round of iterations to bring total number to 600k. This is because we used to use 1k, then 15k, so for
 * backwards compatibility with remember-me/autodecrypt links, we need to support going from that to more iterations.
 *
 * @param hashedPassword
 * @param salt
 * @returns {Promise<string>}
 */
function hashThirdRound(hashedPassword, salt) {
    return pbkdf2(hashedPassword, salt, 585000, "SHA-256");
}
exports.hashThirdRound = hashThirdRound;

/**
 * Salt and hash the password so it can be stored in localStorage without opening a password reuse vulnerability.
 *
 * @param {string} password
 * @param {string} salt
 * @param {int} iterations
 * @param {string} hashAlgorithm
 * @returns {Promise<string>}
 */
async function pbkdf2(password, salt, iterations, hashAlgorithm) {
    const key = await subtle.importKey("raw", UTF8Encoder.parse(password), "PBKDF2", false, ["deriveBits"]);

    const keyBytes = await subtle.deriveBits(
        {
            name: "PBKDF2",
            hash: hashAlgorithm,
            iterations,
            salt: UTF8Encoder.parse(salt),
        },
        key,
        256
    );

    return HexEncoder.stringify(new Uint8Array(keyBytes));
}

function generateRandomSalt() {
    const bytes = crypto.getRandomValues(new Uint8Array(128 / 8));

    return HexEncoder.stringify(new Uint8Array(bytes));
}
exports.generateRandomSalt = generateRandomSalt;

async function signMessage(hashedPassword, message) {
    const key = await subtle.importKey(
        "raw",
        HexEncoder.parse(hashedPassword),
        {
            name: "HMAC",
            hash: "SHA-256",
        },
        false,
        ["sign"]
    );
    const signature = await subtle.sign("HMAC", key, UTF8Encoder.parse(message));

    return HexEncoder.stringify(new Uint8Array(signature));
}
exports.signMessage = signMessage;

function getRandomAlphanum() {
    const possibleCharacters = "abcdefghijklmnopqrstuvwxyzABCDEFGHIJKLMNOPQRSTUVWXYZ0123456789";

    let byteArray;
    let parsedInt;

    // Keep generating new random bytes until we get a value that falls
    // within a range that can be evenly divided by possibleCharacters.length
    do {
        byteArray = crypto.getRandomValues(new Uint8Array(1));
        // extract the lowest byte to get an int from 0 to 255 (probably unnecessary, since we're only generating 1 byte)
        parsedInt = byteArray[0] & 0xff;
    } while (parsedInt >= 256 - (256 % possibleCharacters.length));

    // Take the modulo of the parsed integer to get a random number between 0 and totalLength - 1
    const randomIndex = parsedInt % possibleCharacters.length;

    return possibleCharacters[randomIndex];
}

/**
 * Generate a random string of a given length.
 *
 * @param {int} length
 * @returns {string}
 */
function generateRandomString(length) {
    let randomString = "";

    for (let i = 0; i < length; i++) {
        randomString += getRandomAlphanum();
    }

    return randomString;
}
exports.generateRandomString = generateRandomString;

  return exports;
})());
const codec = ((function(){
  const exports = {};
  /**
 * Initialize the codec with the provided cryptoEngine - this return functions to encode and decode messages.
 *
 * @param cryptoEngine - the engine to use for encryption / decryption
 */
function init(cryptoEngine) {
    const exports = {};

    /**
     * Top-level function for encoding a message.
     * Includes password hashing, encryption, and signing.
     *
     * @param {string} msg
     * @param {string} password
     * @param {string} salt
     *
     * @returns {string} The encoded text
     */
    async function encode(msg, password, salt) {
        const hashedPassword = await cryptoEngine.hashPassword(password, salt);

        const encrypted = await cryptoEngine.encrypt(msg, hashedPassword);

        // we use the hashed password in the HMAC because this is effectively what will be used a password (so we can store
        // it in localStorage safely, we don't use the clear text password)
        const hmac = await cryptoEngine.signMessage(hashedPassword, encrypted);

        return hmac + encrypted;
    }
    exports.encode = encode;

    /**
     * Encode using a password that has already been hashed. This is useful to encode multiple messages in a row, that way
     * we don't need to hash the password multiple times.
     *
     * @param {string} msg
     * @param {string} hashedPassword
     *
     * @returns {string} The encoded text
     */
    async function encodeWithHashedPassword(msg, hashedPassword) {
        const encrypted = await cryptoEngine.encrypt(msg, hashedPassword);

        // we use the hashed password in the HMAC because this is effectively what will be used a password (so we can store
        // it in localStorage safely, we don't use the clear text password)
        const hmac = await cryptoEngine.signMessage(hashedPassword, encrypted);

        return hmac + encrypted;
    }
    exports.encodeWithHashedPassword = encodeWithHashedPassword;

    /**
     * Top-level function for decoding a message.
     * Includes signature check and decryption.
     *
     * @param {string} signedMsg
     * @param {string} hashedPassword
     * @param {string} salt
     * @param {int} backwardCompatibleAttempt
     * @param {string} originalPassword
     *
     * @returns {Object} {success: true, decoded: string} | {success: false, message: string}
     */
    async function decode(signedMsg, hashedPassword, salt, backwardCompatibleAttempt = 0, originalPassword = "") {
        const encryptedHMAC = signedMsg.substring(0, 64);
        const encryptedMsg = signedMsg.substring(64);
        const decryptedHMAC = await cryptoEngine.signMessage(hashedPassword, encryptedMsg);

        if (decryptedHMAC !== encryptedHMAC) {
            // we have been raising the number of iterations in the hashing algorithm multiple times, so to support the old
            // remember-me/autodecrypt links we need to try bringing the old hashes up to speed.
            originalPassword = originalPassword || hashedPassword;
            if (backwardCompatibleAttempt === 0) {
                const updatedHashedPassword = await cryptoEngine.hashThirdRound(originalPassword, salt);

                return decode(signedMsg, updatedHashedPassword, salt, backwardCompatibleAttempt + 1, originalPassword);
            }
            if (backwardCompatibleAttempt === 1) {
                let updatedHashedPassword = await cryptoEngine.hashSecondRound(originalPassword, salt);
                updatedHashedPassword = await cryptoEngine.hashThirdRound(updatedHashedPassword, salt);

                return decode(signedMsg, updatedHashedPassword, salt, backwardCompatibleAttempt + 1, originalPassword);
            }

            return { success: false, message: "Signature mismatch" };
        }

        return {
            success: true,
            decoded: await cryptoEngine.decrypt(encryptedMsg, hashedPassword),
        };
    }
    exports.decode = decode;

    return exports;
}
exports.init = init;

  return exports;
})());
const decode = codec.init(cryptoEngine).decode;

/**
 * Initialize the staticrypt module, that exposes functions callbable by the password_template.
 *
 * @param {{
 *  staticryptEncryptedMsgUniqueVariableName: string,
 *  isRememberEnabled: boolean,
 *  rememberDurationInDays: number,
 *  staticryptSaltUniqueVariableName: string,
 * }} staticryptConfig - object of data that is stored on the password_template at encryption time.
 *
 * @param {{
 *  rememberExpirationKey: string,
 *  rememberPassphraseKey: string,
 *  replaceHtmlCallback: function,
 *  clearLocalStorageCallback: function,
 * }} templateConfig - object of data that can be configured by a custom password_template.
 */
function init(staticryptConfig, templateConfig) {
    const exports = {};

    /**
     * Decrypt our encrypted page, replace the whole HTML.
     *
     * @param {string} hashedPassword
     * @returns {Promise<boolean>}
     */
    async function decryptAndReplaceHtml(hashedPassword) {
        const { staticryptEncryptedMsgUniqueVariableName, staticryptSaltUniqueVariableName } = staticryptConfig;
        const { replaceHtmlCallback } = templateConfig;

        const result = await decode(
            staticryptEncryptedMsgUniqueVariableName,
            hashedPassword,
            staticryptSaltUniqueVariableName
        );
        if (!result.success) {
            return false;
        }
        const plainHTML = result.decoded;

        // if the user configured a callback call it, otherwise just replace the whole HTML
        if (typeof replaceHtmlCallback === "function") {
            replaceHtmlCallback(plainHTML);
        } else {
            document.write(plainHTML);
            document.close();
        }

        return true;
    }

    /**
     * Attempt to decrypt the page and replace the whole HTML.
     *
     * @param {string} password
     * @param {boolean} isRememberChecked
     *
     * @returns {Promise<{isSuccessful: boolean, hashedPassword?: string}>} - we return an object, so that if we want to
     *   expose more information in the future we can do it without breaking the password_template
     */
    async function handleDecryptionOfPage(password, isRememberChecked) {
        const { isRememberEnabled, rememberDurationInDays, staticryptSaltUniqueVariableName } = staticryptConfig;
        const { rememberExpirationKey, rememberPassphraseKey } = templateConfig;

        // decrypt and replace the whole page
        const hashedPassword = await cryptoEngine.hashPassword(password, staticryptSaltUniqueVariableName);

        const isDecryptionSuccessful = await decryptAndReplaceHtml(hashedPassword);

        if (!isDecryptionSuccessful) {
            return {
                isSuccessful: false,
                hashedPassword,
            };
        }

        // remember the hashedPassword and set its expiration if necessary
        if (isRememberEnabled && isRememberChecked) {
            window.localStorage.setItem(rememberPassphraseKey, hashedPassword);

            // set the expiration if the duration isn't 0 (meaning no expiration)
            if (rememberDurationInDays > 0) {
                window.localStorage.setItem(
                    rememberExpirationKey,
                    (new Date().getTime() + rememberDurationInDays * 24 * 60 * 60 * 1000).toString()
                );
            }
        }

        return {
            isSuccessful: true,
            hashedPassword,
        };
    }
    exports.handleDecryptionOfPage = handleDecryptionOfPage;

    /**
     * Clear localstorage from staticrypt related values
     */
    function clearLocalStorage() {
        const { clearLocalStorageCallback, rememberExpirationKey, rememberPassphraseKey } = templateConfig;

        if (typeof clearLocalStorageCallback === "function") {
            clearLocalStorageCallback();
        } else {
            localStorage.removeItem(rememberPassphraseKey);
            localStorage.removeItem(rememberExpirationKey);
        }
    }

    async function handleDecryptOnLoad() {
        let isSuccessful = await decryptOnLoadFromUrl();

        if (!isSuccessful) {
            isSuccessful = await decryptOnLoadFromRememberMe();
        }

        return { isSuccessful };
    }
    exports.handleDecryptOnLoad = handleDecryptOnLoad;

    /**
     * Clear storage if we are logging out
     *
     * @returns {boolean} - whether we logged out
     */
    function logoutIfNeeded() {
        const logoutKey = "staticrypt_logout";

        // handle logout through query param
        const queryParams = new URLSearchParams(window.location.search);
        if (queryParams.has(logoutKey)) {
            clearLocalStorage();
            return true;
        }

        // handle logout through URL fragment
        const hash = window.location.hash.substring(1);
        if (hash.includes(logoutKey)) {
            clearLocalStorage();
            return true;
        }

        return false;
    }

    /**
     * To be called on load: check if we want to try to decrypt and replace the HTML with the decrypted content, and
     * try to do it if needed.
     *
     * @returns {Promise<boolean>} true if we derypted and replaced the whole page, false otherwise
     */
    async function decryptOnLoadFromRememberMe() {
        const { rememberDurationInDays } = staticryptConfig;
        const { rememberExpirationKey, rememberPassphraseKey } = templateConfig;

        // if we are login out, terminate
        if (logoutIfNeeded()) {
            return false;
        }

        // if there is expiration configured, check if we're not beyond the expiration
        if (rememberDurationInDays && rememberDurationInDays > 0) {
            const expiration = localStorage.getItem(rememberExpirationKey),
                isExpired = expiration && new Date().getTime() > parseInt(expiration);

            if (isExpired) {
                clearLocalStorage();
                return false;
            }
        }

        const hashedPassword = localStorage.getItem(rememberPassphraseKey);

        if (hashedPassword) {
            // try to decrypt
            const isDecryptionSuccessful = await decryptAndReplaceHtml(hashedPassword);

            // if the decryption is unsuccessful the password might be wrong - silently clear the saved data and let
            // the user fill the password form again
            if (!isDecryptionSuccessful) {
                clearLocalStorage();
                return false;
            }

            return true;
        }

        return false;
    }

    function decryptOnLoadFromUrl() {
        const passwordKey = "staticrypt_pwd";

        // get the password from the query param
        const queryParams = new URLSearchParams(window.location.search);
        const hashedPasswordQuery = queryParams.get(passwordKey);

        // get the password from the url fragment
        const hashRegexMatch = window.location.hash.substring(1).match(new RegExp(passwordKey + "=(.*)"));
        const hashedPasswordFragment = hashRegexMatch ? hashRegexMatch[1] : null;

        const hashedPassword = hashedPasswordFragment || hashedPasswordQuery;

        if (hashedPassword) {
            return decryptAndReplaceHtml(hashedPassword);
        }

        return false;
    }

    return exports;
}
exports.init = init;

  return exports;
})());
        ;
            const templateError = "template_error",
                isRememberEnabled = true,
                staticryptConfig = {"staticryptEncryptedMsgUniqueVariableName":"ecf14ee8c3dc53c9755a32a69038172e8bed049616960c4bf4b89fb515e066ef7dc5da519367d49e9e95b11c55e8c9b06d7728be703a52b63a9b1cb7ad173e7c9d4b29f95c4edb901feaa2c41140d595dc38d91453abaaacc1bec7e3a8841925a0f64d6473e4d2b107e6aa878f9ccfc3167153867fa211b36e82632c6c157f90f952d9ae534a54330bcb364cf09f410311ab2e5c213816451bda278efaeb432df745ad1eef34fd7d1eca9d4cabfdee1f5ada6445c3c0fcff7acd6090baf909a26736a2e9191ec9551105de3a8f70f8deed23aaaead9398b0642c596388ba5087618a614f235f7f353403e4d5c9ab21670080be9126decee3babfffae0e057fca04694dea218c038ebeaa7367b65a0af13ed20614546c6fcf2deb0bec7f0cecdd4afcaa63f0e1038dcae2a51e2fb4b71b2e78728469b7f1dcf5c37af9083c06c87c45eaf522f93e55a3522a6812429b36a13148dd7251e8337e3d5f8b86371ee4c5b324bc0bf5e3796eae8292721b745204423bf773ff666b94e18d0b801c810441b63f12bc792908e44296bb409c106b8511d5ed761c605332b9854cfaa842f0ca4e8b0fc8fee530eb77c2431d274806c6b37d9296ca8a09b166051196ffd8ed48c42860175595f0d2f28a953687a2b6ec2f0096494bade61e8fef50760b28a7d73b4eb9c2af4a0376f5af2a57c97d5b24031088bbcc580596f26dbeac1a2d63b06d4cdf6f52ca028af20740d3797c79a5fd74d80197e749524b29610f117ddaae8b68dc1440cb1535b073120cabdcd12ede272e6b65065934a38f5d05e48eb6eda9c3c1d8db2ce2cc87c1aa1d0881fea72368a6b3fc7db0a3f0446057fc63152d53052f8759707ec1640d93cc6dc556f74367b2b091fb85cb84eafe9dba564f34d69354e92d2259ef2bbe14ce145e753c99ae89302c8d42846531eb7077b8ceaf347d2780071cf1b19f67b1558d6ae3dba7ed7a7d99e245346994fecf7ebc17826066c567a6a45250222b8c266d3cb108f7a810a52066a9aca35a221c2b2824c5ad52947bc2eff6efb2525880622aa05239066f69d613f3f72d9379c9346ec7511c89044d1764abf04ec95003fe6c0c1eded0e21630a130a93c6d788f08a89258de448084e57eaa9f4a60f30932ad402f496c1f793f68641bad2db5ea8e9f65e17809584688721dd4bc9d00390e96efccdc1ba1331cbbeba3ee39f7ccfebd8ad90cba45ddcbacf91e6e2b439c862e38e6798ce636adce5a66adc55fd5b2a3dd73744fe4e21d5d878ba0be9295eec8f4f3610fd0f0ee25c85c2c721be57b50a08ac2073e3ef869d2f66a8bee0a0b8fdc7c4fda78294c0e39b09a8b95fec11c28d6afbf50e29468c8397b70b4b9043abc57628e13f9cd1bc63686dcbfb1f5f76930387389ec6e8ae3d3d9f19411c15b950f2989ed50ee061bed2241b68c10c143274084b350c03b3952e503d2b3a62f40f05491c7aad1627d5e0c64e564c92047493bfa3307e6cf034ed7538dfc34016f2f05d558edda8f1fbc6c7f8e27f7208b92ed7e53d43bfc21dc3392a633eeca3158efb8b316e1a469db77c16db667aa461860a2b16babb5891fd415acde87b806fba8cab28128edd0275c0250bc33859a36d8cfdbc19e1b07487eb9f9a29717ac936635f4dae1c3e25596eb7a7fa7be973601943f0aef7645e081f3815db8ed51821c79fe013342590054d6e1c4f3217fb0e4e744386879e39ee86a65abc0af54846b684671ce7c9b875272d3024aaa29d2a2ea33fe95342f3ce86ac5c31cdc30ce82a5c8d6c9f643d96454e47de8cba646509342722e1c559d6d07516f9335ebe52b2fbaa724eec1a1102d50eee64986f823b2372c2234bb4f8501be9638c639e8a2c131511bf5716dbe73b00020a1c9f0665bff85fd42ffeeb50fe12c87d16e2fd66dbe76cf46cb7991473a212048875f8afb87f2310283bba68824978cf7d0b89f14c4ee44ba9377c3d411ab7bc5871b29cedebc510fa7802a9c7ef89d0e65616e9db329e90397d866ac60c78757fe13155c1159dfbbef47f0328e99eabea09188c83978ca69b60807a1e2717ee25c83342af4e52deaae595552400d58b0895d959991b1495650792cfd76e813fa43921795c5dcfa3a110a5e66046094dc17b984e5b5cd754dfe75c2f5d4e773277e068fcdcb40864cb7315f3b0c51261ba1202df3c1811e74ec35b6f3ac9bb502b4cdad05919d47f3129c1b86b08adce3f6c8843857bc915ebe403b206d5cb09b61acf3b10954cd663b29889875e57362e1de4e4cb91cf1cb19dbe140cac6f1b9eb5af1c8573576910f9fc22bb4563824d9110bee6898265ae7b8ebdf711922c709de09a63837ede3ed37596b24b0428b6665936a2f23d23f535e0e313976b05a131a7ecc742f286095ec04a86250d3d62c4a85cb2bcf452d131003851965d174d8f31ebf6cce10ea6df3c182f0ed99138d682cafc87d0434e15e9f51c63dbdb258ec451b9493554b84dba29b4927201f150785f70b6553837dd83b7c2aec4b896969b0d07a300c297436c42f7d4f5f3c58e9b50f2f03d126658e79048a383e2b32c7be0d4a03853f063ac7a9a7032a629371953422d491cdf2da081e26d6f7a12c98ad2a65c20aae76fe4f85eb27f7e482dea33102b8e5d3ec8e30aeb8b1fdbce19633ae0853736055108aae380781cf2b281e02cca0f5922f3d34d758e19b4453eaab37080be0b9312ac795c0d876aaaf6c290c4a4216bea34d4d3d7d087423a6fedd7737c3497efcac7a0fa57025a849ac54bf108331a19d350d6bdc84076d2ffe5ace7c74f7141c0cdd2f84cc8041c2d09fd470f3e83889b048bf18ffe22a3b93c1d8e7b48aba021dc3eaadf9dcb9b22cfe910caca2d1d56f686675366fc3e9a5d9470844b9ccde090f281b970e82c15e08c54fabffc50d7ad201d3ac3c0b78495fbff985b9650115fc2b2cbcf87b924a5e87c25ba526f2e638dae56b08aea08bc29d7de4ee191f353a204aa360f9b8de74ff1551ef9bdf8c08c809e3891b29b04de64eda01974b3099cc8fe87cbddd3e295906813ecf00ac9293a6523d0a432c5e979fe5f0bf609f9d2b7101b9d4a89f20e74700567fc3074477cdd37d2025bc1c6f6c72ff6cd71e4c8c6335bdca18521bda3f149c6e33804650023e7e9f00b95b392488ca9e24f96ba5255bd83b61fa190aaa3674a24f1dcb6121a86b626bf54764a692344d1afbc30e12dbd38902812d466768f47bfb5ac4b7e016bd1125f1305b3b60bdfa5ada2d7b699210461636acf498cc72eec261faacb3d33bb2d9186caf16691695462b11e071c4c4eed0b1a8176f3d92eb1fbef6185698ae1891ff319f152abeda84b06f34d63758ef3cfd324d7cd85826f7c448497853b0031114935736676d9339a7fec5640ed6b6cc3b84b676b6e8d5877d73de810ec1bfb618e498742b30885dd74de6368468128413d63a6cc23a88f11eb3220054e618895e2eb7d26518f1b0495ef14c7c9afe21426b934ade5123b46d70214ff5095a5f5705ad6e2d10a087faf3b0fc6a2bb258ab6ca4c4ec2f443754e89b75d91871744b684a549f970944ff505546f9e81f7341c3d818371621ae3678f5b2ef12822e0f66720c3060fdc3da9d44d63d4c914367c026fd74d3dc71859aa1a3e7cd66b362167187d9e882d7b07a9e7de38782e71409a54c506cb82978a3c4c1697fbb97601c60236b34da335d47e1beb8f51566f763a4c25c3c038971023ffb53d56cfad7d9ff934026f104484a294f827f821ae07f7790ef160536920cff8a273f270dceb712eface02ae0a81b6a6e5fb92dab01171b5cd4ed06f5440ebcac7e261e816b8660001d756f73f3308e060663fdc828a7cc69e0c26fc522a06bbc3515da89f715658e5f6db66a192cdad3d6565b98375f1c3573e51aa6fb293ede42e42f6d7cff1c3e5bb4326e2711f844a269c0ef7742b68a1f385427c9409f6a95e6715405a1addc58b8e235133f3ede7ccdd2ac6c9564f4a9e0066bcd49613b6319b81f1a5c834e3c2cae26afd8040a18c3e754b4ecdea759f59636b43f33fdac24e9bcf20d6945dd27f4eb0959fa8a498a6a962b72bcbb33cf459e562fea456dabc917ad07404eb369189a48af5b46c3b9a33213c0bb4ab7ad76e763545db9af5ea3a6ac22d136875cfc49f63ffb2c2938f4471f24856508c83af50bae7eedf261ef27b18a5788185d28eaf4690ed58fbc837aade932a1fe6f7e7d70bdf27585cb2fe91bec94614622e7a93e68274085623254d23467fd93f0c2b5ec3caa8fb87df1edb60cf2d31c528a162b941054d3ddfb5f9364096877f9f03b1ecb5b4a610d26427edc90f51c5b32cc59a9841c37f37c4c79264e741df97aea1e2dfbb789efe1757ccfde387f84e1adda239dbc076e404b0b0149f30f8a07789f5860c44c1af09b309b98e510900c4b2b0004daa1bae4c46cb78794278fc20f89d966037a59a59027ee53d364c34e865938885dfc1889cfbf8fbb426c79e6f2cac01fb62d74a394da9e0209ed989fb3213931010a182f26b155b63e55dfc89dab84cc37d8229c78d25c3caf99db765d97167e22fe98a717d322ee96a91442d1c0fa7b8f677c78cf46b52b761b7e1f6ffabb4b1a702998207006a0583f931662f72e9b2ffd7406455525746aee3c4ac08dbe880502966a4361bdf4c1f34d41b0cacf9c60eae6989ccead1021b8bb3327fd5fac68595200fdb7e13288c0edd64a403fb32241d1439c79ea7e0843540ecda031e9b823ed94cdecfc0bfd023c8ec34fca397310df60cdba024d44eccc6f004278e431a69c9d870b33bfb77c3a04feda18b4ef80b1c906ed58b8f363c4dbe1fb768568fdd5999e30be155f09e145322e2bdaf53dbcb9983e0996d20daea1b243e92112172ecf2bf3b9b70f16b868a2bb224a67d7d96f3c102c3a152000d2e335aaa4f2b66fa698241d497a872e0e7610b4579006c7238a50bde014a4e79fded79daf9aa73fd67ffd8c8b374b8a7f76dfe7dcee796e60a96df0aa0cc8edaca96d7c0fa18bcc3e009f54c795b80a85df8aab5f194e79dd6e23d82387b3958cd0ad138bfc9713397fe878d17b8a0b3dda75b23b022e1c66f75f363ff0e6fc4205347f8cb5b03f6f568334e401ff1611f3141843730915ca1a2e36fd52781888179ab8859609337e177a7fb7761647b67bf86f5eb3bf8b3683e39b7c34e5b367517d5feb3fb5210f9813fb428f1ff7d050c5519a368ffd2ceca450113b18ea64df9a557401b849e0a3275b0a5b5b3f876113913f9ba0d0de8dcf133039295a9d34f6e1153808a2153804774065f9c9f053064c82e86953b37da40104f4960256e0c6dc46838576a1f8ed3b40e212bd34dcd6f5bcf3f00b5c41bf0946879ab0a7ec62663ed686163ff664ae5cef104a648efcb420d36e9072a503054bbaeb03e58a15c52a9ec326060bcaf7dfb315c6ea43a33ce4b43b0178bab2b6b84d1f38cb1e14ca11e60c3deaeb54597a38a820e83e99f21e242f070ccfd82c7ce7f449b4a879ffaf3403cac11373888acb3ed84f87f21c3aabbe1a463fc60d36ac70e74e8f68c510b074a23ae640cf5cc7b00ad117fe2f3eda49a957025202e591b67ba2827cd5d5b0e4f52c6e3832e7268db1042e12f13829cfb1dc2127b71a3b2986558630e56115a40aef98c78dcc43018d0ee03500132810c859cc734ee19f815ceb0d01c718b2715bca3502278323432a55421424dec4fe71dff7595d1a42b852ec95072d7eb2167010f52541670722da147d5f2fe8d00148b7fcf95057204424882e00e97ab7df723f7f4e036f04e04401cee4ecc12458385cdf4cd7fa0693be30c24329767760d8346662774f1aab822cf5ff2d9236f8b837ee3cc1ca87ec45c39f19176cf84cf1100c67f9b5b998eb53400688d46c1d4e687e50f6880fdc6d06ee35ce42514c55b5936dfff9297b5de2628e7cd6ec586b74aa32f3cbceaf08ce7091367288c7a4e941ed8df5ed0e00f3a96114fcdb64e96638bfa3d6ae190c92701c2fa82b0452ed004de284eefcbf8341c2a91f8663a2191ca2736e602c16d56d580858944fa5676fc147dfe18356710f0042f604be5c5dd1dc8520c971441d3d05e82dcf8eff2268d2d072d94fdf2cce42a8898e4b113393dba3d2b228d41e7a0ad0055c439d6813dd0a2ec0b2096eaa1f75d0e50468f5cb370df0c7c3ce4a788fd3d931880d6c20bf3c737a384be479c8f5d28cdef61d6d117f009a2cd48c9693ecb6c49404f80f3179a020beea0a2429fcaa7133e9c7ec668e46303b0edd66dedb21b91197ab9a970226cf84cbba4fa39291e385a36a57f4a9443c42e5bf64fd589e96551fd925e40b3302d006b76854edcd18f75dbb440622785cd4a362ebb5a5ad140569155655e30b138ccfd4fdad620fe97464a24a60752e92f10a20fff4ee347394f154298b4cb66aa7eaaa41602a262fde98172bc76cdd2a96daf59f75261ee6cf74a14918b9d2adbb12b9dce77e4b5c9152aa47c837b3e16920c3d106105c2df76949dddde000c6b5870c6688a51158390e18864a69485194c4bcaaaf563bc26a1aa61c8d2bcb973922a25cd6bfa8c72f944bebe45e8c41ad656d49eb2ebbd5eb958f02d399e52fa516e5f13c8483d2dd05bcada58b3fbfa740cf2632c9c91c695bd6a713235d2531cde2d4ef93900945eef586cd3992778e01f4df4e3cbe88d367bda34349425272a7e4e4d12eb2b13df5c523c84fcb22267c5c9781095796b49b898c326744a71a32c84e613a70dd58767165abcf0bc10bcad9f9985e5a104a75db5a16d5b4d18cb1717de21dca919a4d3838b0877e0109ce41f18b906497bd21d27fc06562cefb327d46564604f0d07537848ad3e7cca32557640c47fe37e3c4a661e4722c7caa9f7c7be16f62bdd5d9fc0b0b884ed418e4173386d3b4b2e022b2c4f2a27c5d289ba220f2424566a4fa60caee0dfe5192fa5e7de4148339f55873496eb776cd4bde24e4b3a52ff00d7c7442a1d110a78f13a207a8e320ec7269aac2144ada53487ae68acfea57f1e7a10c408aec41e99da915e8694c73a1d1c54c6d4a3ec7ccc46ed8d2ed3b8713a1ef4cde36c1e3d2828645085c83195d55ad3b0f82a97c0ae0479f7d4c6c255ef130bddfa1e8ee9da5323d118786ed571acc3f0e5c5b6aeca23686ecde3cf4eec63ce54147663bc387e935b12354199834aa57cb6d981032e79e1564c0a63c5879d71d29238e73f4edd58dbe67f8d80e2a7f76d4aa1567e318d028806146508de08502806831948cb8b9d09c23b494fef08f2575c52067285cb4e280642dc09d6e47c6bf838b95e976586a2d9113bd65000614b761401051291cd72867b0d1809ab059a13987cc7f3902046ed817751ec00085f16967e0a6fe8e590319c4b70632dde3f9c4ec151bae41eee62fbd7c9a6b40fec366fa2024f6c83745dd98fe10c316bc7f6eb7278544a38c94d1164c858ab66abcc377ba0a70e7bf5cf61e9c5c956def55eca80f7dc81873fce97a33081bdbb40d7554478d04c256b5379e45017b0b3480f94cd42a598cece9f4f087eba8a6f909b281fe1807ec41b470945d4185c756c50d3c1065075af7b38d0d0cf4dc7ff7712181e5ca96671731ef66da8f49c7dccd09dddb616989cf31ba745b8f4c8cb580532b279b19785e53914da2bb342478adca105d4328204595d2cf02d057760af27e4a88deb94778ac1c0aa0f91fbbc0080a1955670548e00828d56eb7a14a64cbc08ac796c501fe9ae3c73088450a4e8d9d24303de6fc17529209df25cfae213a494cfb5acf3a15fe5c9ed94225364bf55b1c37c11666a831081ce37f9c74292b379a573777fb846559e28b02f1609f69cdbe48e1eae661dff094855accd03b61abd9f4341ee9eca4524a937f0cb0c99274409df21bb32ac451c437dbe6d4912855cc2a28c818fc33eb631ce4dd5b023500d64aac48796df7753ed4e45013f4bd0dfc7752b2a9a5ad7e27ea684af5871fd0db2a8b14b08450e0081ceb133c26d8366a0229306994d4ee1d6763f2dc459baebe4a23e36ab77158be08403713c715ca23b5c025fd606b9674742f025033e622964b9fb32dbcb492ce90e223a3cdf59d42e3bb3ceb028b61fa6694b9123ae02552c71499c4743d051453d9a143cc15d9add9e09622c4a731aebbd3ba279cce85a5056722f59b6a4c851823cb3e12c3fd7045499cd8cb7acc89ee7b44d06fa4ad6d8e0b1ae218d6122fc1ab9787316c2957532858ddd1c2b7e54b0b72cc7286268a65663026797ec0c9ea735af38827deed96d4ddad46f690d4a259279c248bba3eccb44f7e767ebc9183e0cb0597600f8ac3f0f56f4e745e65d6ec1bf9ae703619931a8419b8f72baa8b61f56a0b92a5dac58cc24eaa57fef7dd2f31fbf2c18b5f124260e7e10a2dffd0fc61b784bfc296feb7166c807724bbf2c57f4dd318f78f214d8c76da6fe274bfc5dc88f20f394f929efe1031a0978196b709c7e9a9f4f0b25095670e705980c05afdd932cd3b0c6f65c8f8c6716c79a43461dea765876659dcbcb81c84a5c4436af3ceee54a9c5e404220f2b99540e516499d55e26c18e1c994d1ca01e9d59e4cb1824d94b780961d75ae7610cbb1c70ee3a48a01fb9bc3210305a5cf45991ea4583cd220c44914c5db8aa37303725d2457b5f07e782b670300d8fef21765ba8a82e9b59a794fbfe2f8b199c4da49bb0860f1c898475d0fda077bf8d6cce7f935234f740a4a88d034094b7c1aab6461087e3691a0b23fc6b8f061b2a5c8217dd9acee0ec534bed3032d40395b45c49689eaa29a57500b911244bc9b8bbfa42f0b9debcae1de0cefd0468c7dfb7f64c4db37122e7fa4cc17981d5c0d156c9048891c68b8c5ecc5f29a5b301ccd9a27df20da84fb3f732f8f329249910e0b5b37d2ac84cc4046eab43e98bd2f2727a057c0263952665ed5b36ce94f43832e46e14a54ce92898597a8f84087aea8ced95b7f795e5869dc1cbde1e4be124ada2f378b7baf09a3d1180aadf3b5e6ef222aaa6a8b9e8d19230c69cc6bef644094fac75af2f3409c75dea02f716faac81f039744050d20256a8da63e8d39a6e9d13c88df93f19912f8724c0202371a6d1b34490691d63a73ed8532228fdd561a2febd51043c336416734bb27c89646bbb9b56fd0194d7206d","isRememberEnabled":true,"rememberDurationInDays":0,"staticryptSaltUniqueVariableName":"6286a646663ff150f7a8a0e02eb9ed11"};

            // you can edit these values to customize some of the behavior of StatiCrypt
            const templateConfig = {
                rememberExpirationKey: "staticrypt_expiration",
                rememberPassphraseKey: "staticrypt_passphrase",
                replaceHtmlCallback: null,
                clearLocalStorageCallback: null,
            };

            // init the staticrypt engine
            const staticrypt = staticryptInitiator.init(staticryptConfig, templateConfig);

            // try to automatically decrypt on load if there is a saved password
            window.onload = async function () {
                const { isSuccessful } = await staticrypt.handleDecryptOnLoad();

                // if we didn't decrypt anything on load, show the password prompt. Otherwise the content has already been
                // replaced, no need to do anything
                if (!isSuccessful) {
                    // hide loading screen
                    document.getElementById("staticrypt_loading").classList.add("hidden");
                    document.getElementById("staticrypt_content").classList.remove("hidden");
                    document.getElementById("staticrypt-password").focus();

                    // show the remember me checkbox
                    if (isRememberEnabled) {
                        document.getElementById("staticrypt-remember-label").classList.remove("hidden");
                    }
                }
            };

            // handle password form submission
            document.getElementById("staticrypt-form").addEventListener("submit", async function (e) {
                e.preventDefault();

                const password = document.getElementById("staticrypt-password").value,
                    isRememberChecked = document.getElementById("staticrypt-remember").checked;

                const { isSuccessful } = await staticrypt.handleDecryptionOfPage(password, isRememberChecked);

                if (!isSuccessful) {
                    alert(templateError);
                }
            });
        </script>
    </body>
</html>
