<!DOCTYPE html>
<html class="staticrypt-html">
    <head>
        <meta charset="utf-8" />
        <title>eaglenetwork</title>
        <meta name="viewport" content="width=device-width, initial-scale=1" />

        <!-- do not cache this page -->
        <meta http-equiv="cache-control" content="max-age=0" />
        <meta http-equiv="cache-control" content="no-cache" />
        <meta http-equiv="expires" content="0" />
        <meta http-equiv="expires" content="Tue, 01 Jan 1980 1:00:00 GMT" />
        <meta http-equiv="pragma" content="no-cache" />

        <style>
            .staticrypt-hr {
                margin-top: 20px;
                margin-bottom: 20px;
                border: 0;
                border-top: 1px solid #eee;
            }

            .staticrypt-page {
                width: 360px;
                padding: 8% 0 0;
                margin: auto;
                box-sizing: border-box;
            }

            .staticrypt-form {
                position: relative;
                z-index: 1;
                background: #ffffff;
                max-width: 360px;
                margin: 0 auto 100px;
                padding: 45px;
                text-align: center;
                box-shadow: 0 0 20px 0 rgba(0, 0, 0, 0.2), 0 5px 5px 0 rgba(0, 0, 0, 0.24);
            }

            .staticrypt-form input[type="password"] {
                outline: 0;
                background: #f2f2f2;
                width: 100%;
                border: 0;
                margin: 0 0 15px;
                padding: 15px;
                box-sizing: border-box;
                font-size: 14px;
            }

            .staticrypt-form .staticrypt-decrypt-button {
                text-transform: uppercase;
                outline: 0;
                background: #4CAF50;
                width: 100%;
                border: 0;
                padding: 15px;
                color: #ffffff;
                font-size: 14px;
                cursor: pointer;
            }

            .staticrypt-form .staticrypt-decrypt-button:hover,
            .staticrypt-form .staticrypt-decrypt-button:active,
            .staticrypt-form .staticrypt-decrypt-button:focus {
                background: #4CAF50;
                filter: brightness(92%);
            }

            .staticrypt-html {
                height: 100%;
            }

            .staticrypt-body {
                height: 100%;
                margin: 0;
            }

            .staticrypt-content {
                height: 100%;
                margin-bottom: 1em;
                background: #76B852;
                font-family: "Arial", sans-serif;
                -webkit-font-smoothing: antialiased;
                -moz-osx-font-smoothing: grayscale;
            }

            .staticrypt-instructions {
                margin-top: -1em;
                margin-bottom: 1em;
            }

            .staticrypt-title {
                font-size: 1.5em;
            }

            label.staticrypt-remember {
                display: flex;
                align-items: center;
                margin-bottom: 1em;
            }

            .staticrypt-remember input[type="checkbox"] {
                transform: scale(1.5);
                margin-right: 1em;
            }

            .hidden {
                display: none !important;
            }

            .staticrypt-spinner-container {
                height: 100%;
                display: flex;
                align-items: center;
                justify-content: center;
            }

            .staticrypt-spinner {
                display: inline-block;
                width: 2rem;
                height: 2rem;
                vertical-align: text-bottom;
                border: 0.25em solid gray;
                border-right-color: transparent;
                border-radius: 50%;
                -webkit-animation: spinner-border 0.75s linear infinite;
                animation: spinner-border 0.75s linear infinite;
                animation-duration: 0.75s;
                animation-timing-function: linear;
                animation-delay: 0s;
                animation-iteration-count: infinite;
                animation-direction: normal;
                animation-fill-mode: none;
                animation-play-state: running;
                animation-name: spinner-border;
            }

            @keyframes spinner-border {
                100% {
                    transform: rotate(360deg);
                }
            }
        </style>
    </head>

    <body class="staticrypt-body">
        <div id="staticrypt_loading" class="staticrypt-spinner-container">
            <div class="staticrypt-spinner"></div>
        </div>

        <div id="staticrypt_content" class="staticrypt-content hidden">
            <div class="staticrypt-page">
                <div class="staticrypt-form">
                    <div class="staticrypt-instructions">
                        <p class="staticrypt-title">eaglenetwork</p>
                        <p><p><strong>study</strong> app</p>
</p>
                    </div>

                    <hr class="staticrypt-hr" />

                    <form id="staticrypt-form" action="#" method="post">
                        <input
                            id="staticrypt-password"
                            type="password"
                            name="password"
                            placeholder="enter password"
                            autofocus
                        />

                        <label id="staticrypt-remember-label" class="staticrypt-remember hidden">
                            <input id="staticrypt-remember" type="checkbox" name="remember" />
                            Remember me
                        </label>

                        <input type="submit" class="staticrypt-decrypt-button" value="DECRYPT" />
                    </form>
                </div>
            </div>
        </div>

        <script>
            // these variables will be filled when generating the file - the template format is 'variable_name'
            const staticryptInitiator = 
            ((function(){
  const exports = {};
  const cryptoEngine = ((function(){
  const exports = {};
  const { subtle } = crypto;

const IV_BITS = 16 * 8;
const HEX_BITS = 4;
const ENCRYPTION_ALGO = "AES-CBC";

/**
 * Translates between utf8 encoded hexadecimal strings
 * and Uint8Array bytes.
 */
const HexEncoder = {
    /**
     * hex string -> bytes
     * @param {string} hexString
     * @returns {Uint8Array}
     */
    parse: function (hexString) {
        if (hexString.length % 2 !== 0) throw "Invalid hexString";
        const arrayBuffer = new Uint8Array(hexString.length / 2);

        for (let i = 0; i < hexString.length; i += 2) {
            const byteValue = parseInt(hexString.substring(i, i + 2), 16);
            if (isNaN(byteValue)) {
                throw "Invalid hexString";
            }
            arrayBuffer[i / 2] = byteValue;
        }
        return arrayBuffer;
    },

    /**
     * bytes -> hex string
     * @param {Uint8Array} bytes
     * @returns {string}
     */
    stringify: function (bytes) {
        const hexBytes = [];

        for (let i = 0; i < bytes.length; ++i) {
            let byteString = bytes[i].toString(16);
            if (byteString.length < 2) {
                byteString = "0" + byteString;
            }
            hexBytes.push(byteString);
        }
        return hexBytes.join("");
    },
};

/**
 * Translates between utf8 strings and Uint8Array bytes.
 */
const UTF8Encoder = {
    parse: function (str) {
        return new TextEncoder().encode(str);
    },

    stringify: function (bytes) {
        return new TextDecoder().decode(bytes);
    },
};

/**
 * Salt and encrypt a msg with a password.
 */
async function encrypt(msg, hashedPassword) {
    // Must be 16 bytes, unpredictable, and preferably cryptographically random. However, it need not be secret.
    // https://developer.mozilla.org/en-US/docs/Web/API/SubtleCrypto/encrypt#parameters
    const iv = crypto.getRandomValues(new Uint8Array(IV_BITS / 8));

    const key = await subtle.importKey("raw", HexEncoder.parse(hashedPassword), ENCRYPTION_ALGO, false, ["encrypt"]);

    const encrypted = await subtle.encrypt(
        {
            name: ENCRYPTION_ALGO,
            iv: iv,
        },
        key,
        UTF8Encoder.parse(msg)
    );

    // iv will be 32 hex characters, we prepend it to the ciphertext for use in decryption
    return HexEncoder.stringify(iv) + HexEncoder.stringify(new Uint8Array(encrypted));
}
exports.encrypt = encrypt;

/**
 * Decrypt a salted msg using a password.
 *
 * @param {string} encryptedMsg
 * @param {string} hashedPassword
 * @returns {Promise<string>}
 */
async function decrypt(encryptedMsg, hashedPassword) {
    const ivLength = IV_BITS / HEX_BITS;
    const iv = HexEncoder.parse(encryptedMsg.substring(0, ivLength));
    const encrypted = encryptedMsg.substring(ivLength);

    const key = await subtle.importKey("raw", HexEncoder.parse(hashedPassword), ENCRYPTION_ALGO, false, ["decrypt"]);

    const outBuffer = await subtle.decrypt(
        {
            name: ENCRYPTION_ALGO,
            iv: iv,
        },
        key,
        HexEncoder.parse(encrypted)
    );

    return UTF8Encoder.stringify(new Uint8Array(outBuffer));
}
exports.decrypt = decrypt;

/**
 * Salt and hash the password so it can be stored in localStorage without opening a password reuse vulnerability.
 *
 * @param {string} password
 * @param {string} salt
 * @returns {Promise<string>}
 */
async function hashPassword(password, salt) {
    // we hash the password in multiple steps, each adding more iterations. This is because we used to allow less
    // iterations, so for backward compatibility reasons, we need to support going from that to more iterations.
    let hashedPassword = await hashLegacyRound(password, salt);

    hashedPassword = await hashSecondRound(hashedPassword, salt);

    return hashThirdRound(hashedPassword, salt);
}
exports.hashPassword = hashPassword;

/**
 * This hashes the password with 1k iterations. This is a low number, we need this function to support backwards
 * compatibility.
 *
 * @param {string} password
 * @param {string} salt
 * @returns {Promise<string>}
 */
function hashLegacyRound(password, salt) {
    return pbkdf2(password, salt, 1000, "SHA-1");
}
exports.hashLegacyRound = hashLegacyRound;

/**
 * Add a second round of iterations. This is because we used to use 1k, so for backwards compatibility with
 * remember-me/autodecrypt links, we need to support going from that to more iterations.
 *
 * @param hashedPassword
 * @param salt
 * @returns {Promise<string>}
 */
function hashSecondRound(hashedPassword, salt) {
    return pbkdf2(hashedPassword, salt, 14000, "SHA-256");
}
exports.hashSecondRound = hashSecondRound;

/**
 * Add a third round of iterations to bring total number to 600k. This is because we used to use 1k, then 15k, so for
 * backwards compatibility with remember-me/autodecrypt links, we need to support going from that to more iterations.
 *
 * @param hashedPassword
 * @param salt
 * @returns {Promise<string>}
 */
function hashThirdRound(hashedPassword, salt) {
    return pbkdf2(hashedPassword, salt, 585000, "SHA-256");
}
exports.hashThirdRound = hashThirdRound;

/**
 * Salt and hash the password so it can be stored in localStorage without opening a password reuse vulnerability.
 *
 * @param {string} password
 * @param {string} salt
 * @param {int} iterations
 * @param {string} hashAlgorithm
 * @returns {Promise<string>}
 */
async function pbkdf2(password, salt, iterations, hashAlgorithm) {
    const key = await subtle.importKey("raw", UTF8Encoder.parse(password), "PBKDF2", false, ["deriveBits"]);

    const keyBytes = await subtle.deriveBits(
        {
            name: "PBKDF2",
            hash: hashAlgorithm,
            iterations,
            salt: UTF8Encoder.parse(salt),
        },
        key,
        256
    );

    return HexEncoder.stringify(new Uint8Array(keyBytes));
}

function generateRandomSalt() {
    const bytes = crypto.getRandomValues(new Uint8Array(128 / 8));

    return HexEncoder.stringify(new Uint8Array(bytes));
}
exports.generateRandomSalt = generateRandomSalt;

async function signMessage(hashedPassword, message) {
    const key = await subtle.importKey(
        "raw",
        HexEncoder.parse(hashedPassword),
        {
            name: "HMAC",
            hash: "SHA-256",
        },
        false,
        ["sign"]
    );
    const signature = await subtle.sign("HMAC", key, UTF8Encoder.parse(message));

    return HexEncoder.stringify(new Uint8Array(signature));
}
exports.signMessage = signMessage;

function getRandomAlphanum() {
    const possibleCharacters = "abcdefghijklmnopqrstuvwxyzABCDEFGHIJKLMNOPQRSTUVWXYZ0123456789";

    let byteArray;
    let parsedInt;

    // Keep generating new random bytes until we get a value that falls
    // within a range that can be evenly divided by possibleCharacters.length
    do {
        byteArray = crypto.getRandomValues(new Uint8Array(1));
        // extract the lowest byte to get an int from 0 to 255 (probably unnecessary, since we're only generating 1 byte)
        parsedInt = byteArray[0] & 0xff;
    } while (parsedInt >= 256 - (256 % possibleCharacters.length));

    // Take the modulo of the parsed integer to get a random number between 0 and totalLength - 1
    const randomIndex = parsedInt % possibleCharacters.length;

    return possibleCharacters[randomIndex];
}

/**
 * Generate a random string of a given length.
 *
 * @param {int} length
 * @returns {string}
 */
function generateRandomString(length) {
    let randomString = "";

    for (let i = 0; i < length; i++) {
        randomString += getRandomAlphanum();
    }

    return randomString;
}
exports.generateRandomString = generateRandomString;

  return exports;
})());
const codec = ((function(){
  const exports = {};
  /**
 * Initialize the codec with the provided cryptoEngine - this return functions to encode and decode messages.
 *
 * @param cryptoEngine - the engine to use for encryption / decryption
 */
function init(cryptoEngine) {
    const exports = {};

    /**
     * Top-level function for encoding a message.
     * Includes password hashing, encryption, and signing.
     *
     * @param {string} msg
     * @param {string} password
     * @param {string} salt
     *
     * @returns {string} The encoded text
     */
    async function encode(msg, password, salt) {
        const hashedPassword = await cryptoEngine.hashPassword(password, salt);

        const encrypted = await cryptoEngine.encrypt(msg, hashedPassword);

        // we use the hashed password in the HMAC because this is effectively what will be used a password (so we can store
        // it in localStorage safely, we don't use the clear text password)
        const hmac = await cryptoEngine.signMessage(hashedPassword, encrypted);

        return hmac + encrypted;
    }
    exports.encode = encode;

    /**
     * Encode using a password that has already been hashed. This is useful to encode multiple messages in a row, that way
     * we don't need to hash the password multiple times.
     *
     * @param {string} msg
     * @param {string} hashedPassword
     *
     * @returns {string} The encoded text
     */
    async function encodeWithHashedPassword(msg, hashedPassword) {
        const encrypted = await cryptoEngine.encrypt(msg, hashedPassword);

        // we use the hashed password in the HMAC because this is effectively what will be used a password (so we can store
        // it in localStorage safely, we don't use the clear text password)
        const hmac = await cryptoEngine.signMessage(hashedPassword, encrypted);

        return hmac + encrypted;
    }
    exports.encodeWithHashedPassword = encodeWithHashedPassword;

    /**
     * Top-level function for decoding a message.
     * Includes signature check and decryption.
     *
     * @param {string} signedMsg
     * @param {string} hashedPassword
     * @param {string} salt
     * @param {int} backwardCompatibleAttempt
     * @param {string} originalPassword
     *
     * @returns {Object} {success: true, decoded: string} | {success: false, message: string}
     */
    async function decode(signedMsg, hashedPassword, salt, backwardCompatibleAttempt = 0, originalPassword = "") {
        const encryptedHMAC = signedMsg.substring(0, 64);
        const encryptedMsg = signedMsg.substring(64);
        const decryptedHMAC = await cryptoEngine.signMessage(hashedPassword, encryptedMsg);

        if (decryptedHMAC !== encryptedHMAC) {
            // we have been raising the number of iterations in the hashing algorithm multiple times, so to support the old
            // remember-me/autodecrypt links we need to try bringing the old hashes up to speed.
            originalPassword = originalPassword || hashedPassword;
            if (backwardCompatibleAttempt === 0) {
                const updatedHashedPassword = await cryptoEngine.hashThirdRound(originalPassword, salt);

                return decode(signedMsg, updatedHashedPassword, salt, backwardCompatibleAttempt + 1, originalPassword);
            }
            if (backwardCompatibleAttempt === 1) {
                let updatedHashedPassword = await cryptoEngine.hashSecondRound(originalPassword, salt);
                updatedHashedPassword = await cryptoEngine.hashThirdRound(updatedHashedPassword, salt);

                return decode(signedMsg, updatedHashedPassword, salt, backwardCompatibleAttempt + 1, originalPassword);
            }

            return { success: false, message: "Signature mismatch" };
        }

        return {
            success: true,
            decoded: await cryptoEngine.decrypt(encryptedMsg, hashedPassword),
        };
    }
    exports.decode = decode;

    return exports;
}
exports.init = init;

  return exports;
})());
const decode = codec.init(cryptoEngine).decode;

/**
 * Initialize the staticrypt module, that exposes functions callbable by the password_template.
 *
 * @param {{
 *  staticryptEncryptedMsgUniqueVariableName: string,
 *  isRememberEnabled: boolean,
 *  rememberDurationInDays: number,
 *  staticryptSaltUniqueVariableName: string,
 * }} staticryptConfig - object of data that is stored on the password_template at encryption time.
 *
 * @param {{
 *  rememberExpirationKey: string,
 *  rememberPassphraseKey: string,
 *  replaceHtmlCallback: function,
 *  clearLocalStorageCallback: function,
 * }} templateConfig - object of data that can be configured by a custom password_template.
 */
function init(staticryptConfig, templateConfig) {
    const exports = {};

    /**
     * Decrypt our encrypted page, replace the whole HTML.
     *
     * @param {string} hashedPassword
     * @returns {Promise<boolean>}
     */
    async function decryptAndReplaceHtml(hashedPassword) {
        const { staticryptEncryptedMsgUniqueVariableName, staticryptSaltUniqueVariableName } = staticryptConfig;
        const { replaceHtmlCallback } = templateConfig;

        const result = await decode(
            staticryptEncryptedMsgUniqueVariableName,
            hashedPassword,
            staticryptSaltUniqueVariableName
        );
        if (!result.success) {
            return false;
        }
        const plainHTML = result.decoded;

        // if the user configured a callback call it, otherwise just replace the whole HTML
        if (typeof replaceHtmlCallback === "function") {
            replaceHtmlCallback(plainHTML);
        } else {
            document.write(plainHTML);
            document.close();
        }

        return true;
    }

    /**
     * Attempt to decrypt the page and replace the whole HTML.
     *
     * @param {string} password
     * @param {boolean} isRememberChecked
     *
     * @returns {Promise<{isSuccessful: boolean, hashedPassword?: string}>} - we return an object, so that if we want to
     *   expose more information in the future we can do it without breaking the password_template
     */
    async function handleDecryptionOfPage(password, isRememberChecked) {
        const { isRememberEnabled, rememberDurationInDays, staticryptSaltUniqueVariableName } = staticryptConfig;
        const { rememberExpirationKey, rememberPassphraseKey } = templateConfig;

        // decrypt and replace the whole page
        const hashedPassword = await cryptoEngine.hashPassword(password, staticryptSaltUniqueVariableName);

        const isDecryptionSuccessful = await decryptAndReplaceHtml(hashedPassword);

        if (!isDecryptionSuccessful) {
            return {
                isSuccessful: false,
                hashedPassword,
            };
        }

        // remember the hashedPassword and set its expiration if necessary
        if (isRememberEnabled && isRememberChecked) {
            window.localStorage.setItem(rememberPassphraseKey, hashedPassword);

            // set the expiration if the duration isn't 0 (meaning no expiration)
            if (rememberDurationInDays > 0) {
                window.localStorage.setItem(
                    rememberExpirationKey,
                    (new Date().getTime() + rememberDurationInDays * 24 * 60 * 60 * 1000).toString()
                );
            }
        }

        return {
            isSuccessful: true,
            hashedPassword,
        };
    }
    exports.handleDecryptionOfPage = handleDecryptionOfPage;

    /**
     * Clear localstorage from staticrypt related values
     */
    function clearLocalStorage() {
        const { clearLocalStorageCallback, rememberExpirationKey, rememberPassphraseKey } = templateConfig;

        if (typeof clearLocalStorageCallback === "function") {
            clearLocalStorageCallback();
        } else {
            localStorage.removeItem(rememberPassphraseKey);
            localStorage.removeItem(rememberExpirationKey);
        }
    }

    async function handleDecryptOnLoad() {
        let isSuccessful = await decryptOnLoadFromUrl();

        if (!isSuccessful) {
            isSuccessful = await decryptOnLoadFromRememberMe();
        }

        return { isSuccessful };
    }
    exports.handleDecryptOnLoad = handleDecryptOnLoad;

    /**
     * Clear storage if we are logging out
     *
     * @returns {boolean} - whether we logged out
     */
    function logoutIfNeeded() {
        const logoutKey = "staticrypt_logout";

        // handle logout through query param
        const queryParams = new URLSearchParams(window.location.search);
        if (queryParams.has(logoutKey)) {
            clearLocalStorage();
            return true;
        }

        // handle logout through URL fragment
        const hash = window.location.hash.substring(1);
        if (hash.includes(logoutKey)) {
            clearLocalStorage();
            return true;
        }

        return false;
    }

    /**
     * To be called on load: check if we want to try to decrypt and replace the HTML with the decrypted content, and
     * try to do it if needed.
     *
     * @returns {Promise<boolean>} true if we derypted and replaced the whole page, false otherwise
     */
    async function decryptOnLoadFromRememberMe() {
        const { rememberDurationInDays } = staticryptConfig;
        const { rememberExpirationKey, rememberPassphraseKey } = templateConfig;

        // if we are login out, terminate
        if (logoutIfNeeded()) {
            return false;
        }

        // if there is expiration configured, check if we're not beyond the expiration
        if (rememberDurationInDays && rememberDurationInDays > 0) {
            const expiration = localStorage.getItem(rememberExpirationKey),
                isExpired = expiration && new Date().getTime() > parseInt(expiration);

            if (isExpired) {
                clearLocalStorage();
                return false;
            }
        }

        const hashedPassword = localStorage.getItem(rememberPassphraseKey);

        if (hashedPassword) {
            // try to decrypt
            const isDecryptionSuccessful = await decryptAndReplaceHtml(hashedPassword);

            // if the decryption is unsuccessful the password might be wrong - silently clear the saved data and let
            // the user fill the password form again
            if (!isDecryptionSuccessful) {
                clearLocalStorage();
                return false;
            }

            return true;
        }

        return false;
    }

    function decryptOnLoadFromUrl() {
        const passwordKey = "staticrypt_pwd";

        // get the password from the query param
        const queryParams = new URLSearchParams(window.location.search);
        const hashedPasswordQuery = queryParams.get(passwordKey);

        // get the password from the url fragment
        const hashRegexMatch = window.location.hash.substring(1).match(new RegExp(passwordKey + "=(.*)"));
        const hashedPasswordFragment = hashRegexMatch ? hashRegexMatch[1] : null;

        const hashedPassword = hashedPasswordFragment || hashedPasswordQuery;

        if (hashedPassword) {
            return decryptAndReplaceHtml(hashedPassword);
        }

        return false;
    }

    return exports;
}
exports.init = init;

  return exports;
})());
        ;
            const templateError = "template_error",
                isRememberEnabled = true,
                staticryptConfig = {"staticryptEncryptedMsgUniqueVariableName":"f920b456611f6d10b138655ff84bbbdd40997494488f2ab871c0ce17b91611001c026ea6aee6075365797eef6d24eaab926b3feabf6c8a0a0816d7458f88545a33fc88dee9fe9298eac3b557565806695874d90849bee4cd75bb117cb30f54dcd6c42c5aae9cb980ef7dfda0c2e82ddf4688cfe86b2285a416e720fbd914a32143d582bab08e002235fbf708dedc400fa7808ff35e67d9795ac8dbc9d25190e50c7e107b3e68672d17640918c6a7ac2d5e2c435b8b1ced65d89b215b6c6f5d725104d6ebe38bc0d5d5d0d2f2fa60a356e1fde2e6aa988aa790efe94a63282ea138cf0b63b7ac3b0a46ccd3b8ec894f724e3e70d785da741f505f3ec4d69b6a5b0d0f5eabfd7af92f1b3b597c6a0fcd46f9c363795b209e750dd6ccfc0ca22c5eac553b078621c73bea74526e53c75e812ef2fa4ec648bf23ab6159c2dca879a9ebd8de44345adba97edb906422049a5884d6e3f07d2caed602a985322a46a23cee92bc2a3de745fbb2e1551255a217faa1e0f70105a49695770ae3fbb3311f333b05e98c85b69778fc1f26b1f47dc4af227ca52e124e9d037a820fe52ce16ea574f8a0c963d7fe1702e4f5fc227a7d7d101655e62506d5422ad82b05622bba8b5d00f557e3e8d492bd9b1e60f441094c7b0db6b2815f186349b8a5726e93ca1977ed6cf9a0fb77a53e45c8e1861b452bc656b0e8192b67c416097d27fd6e9c85312b4fdb3e46ac0c6f8edc6a3cc05bf0ec8cb576a95207273e1c50865f51b3581cc9a832d8535ed483671ffad581ea0c99587ca9f07d7b21dd9a26c1f43c45df7068c6e60cea7e31f0103252372a17a74db78d4731615fa77397ebe4be901fc81343e090bf7e49caa9c913947d37b1db54d80968a9090ed6274790504845242c77001280604a7c9ee6f2dc1141d5b764db13684cc929d36ad0794d8853351ef7f59ace4f4e11e29183bc6058483b37dcd6f083ed39a2fafb4e0ef2a90428d6085368bf1a36e9ed93e2c192624bae1879a18be1b58de21238a97b2a76bfaa8b4e16748d21667001b92bfbd04fbe9eee1d610e26bbcfe5609b92f0cfa33789d9968ef0f00205bcba10f67ec9ff949b2d94fbed518025f142981f8b19d8b191e9f12dcadd0468c65816511afaf759d7862fef65edeb3fbbee7ffc8ca234075e1e9cc25fd5219c8749ff853ab70e083605f0e2962f6b4f14eef143fce6dfb507fbda7296c9d0f952222baea82b2840304cb9647dbb9fe0113062e3eec54b47d0bc6f21fd513174ab26101a23d29347c2df1ccac3d91cddf12b71ed9e79764880a09a88014833470de03ca6a675b082b13951429e4372eb6233af44219523e8e0677d729966d378847e272d3647f772d3922d87166b53c84cd8e62f36c4c071275f5d9f2babec3d54f1478f7610b2550d57ab1b85b27e2b21e620f7c1f535c567ad822e4c188fb17c5b508e8f61988148177551636ab44e48bc492098e5d35fc1aabb07b0dcd9563f10d06f558f7ebba6108a0b75dc34267b10b08f324c70b2fffc6352f855a50be4c4facc050777a3cace2c04f261cbda51e7dcbdb9c7ebb9b92b3cf300b2078e5467e7cb050135e8a0e904ec9995e55f5ea41679d08fdfad34eb9bb4d893b79acf38b74f0d1d9c0829b35b046aa1b6ff73c183c9113be55f999fa4f95da1cd680b0d3d7132d5c6af866184b9326b903798670b25cd2834a29477922a9492ef57e1f2d34adf8362e01cc108059127fbb6dd6106be2ff517118665513358a82120459d3940e9cd39534cd155b40a12293972d1e5b17459a7315812bede14d7222ffae1618b5930395113f298483950abeccc4339179d912fbe1491378c798d19551d52f17fc9b128e39e37bb54b589078940cd1657bb2e0189d1b369054a5a908a0484074006bda298a2d903da9d5b3036b92b5a8628f4db7a6d2334f5ad05fbba0c89f7135a2eb9abdee1785f57c60b6620998dd311d6ab9373c36236f574e1a0245c100daf9e86fa4b284223cbd6ac3d341eb5b82b65ceea55f1ea9fbb9d5ae98970df2321bf7de0137d197846264cf97a2ce766c12902320e1d3df1028f2ee3c8f8d5b2c5a184530f1c2c0c7bb8103eed29b28370282795175d19f8041564135953523bb67e494ce20c2ff9e9ab8064979d0338b38f9b36d3a92cbcd31733e9ce9eabccaf819e8d2937abfe10d58f0ce853b365570b6df1356c6674289bde036c6242ac3fb490fc610ae1c124db668026e5ede7e4a969f3a4f5076392092be29429d107bbd543fe9c4eb15067bebcf146f94327742cb496f81e1e01be46bca0f39d75bac3807c7e511bab0e5b13022dfce7e23b2d52717345cfca3b8e178df4e029e5b544bb6e4be058015e9b12853747a2cef0eb5eca39b2540c30cf3ea9d4fbf2d78db4ff9e337925e766c886fad8e71d368bd5953d8361d0c2727d1afb169dfe7069ad1ad212e5894c5097bbbca827c4e9a5edc41e25cb530e0da1cf5d21e39cb71ce57fcae860125955b3b0e03423ae3c8e0c25a177e3da188a47ab75f8f9b4a78570d65f006369cd2dae428a21f519547df1893c6838fa09e718d80d0c671176691ec502a4397c57c450d0399ca8ff593064e5f430b49325cbb84c9a1e7f4a0b7cd81180765f3e9b966318d335df9e00fd8d615b8b0659cbddc29888d303868e9710b944cfa54a9958f3a2894dc0348ff6e48914230a9ccc9868d2a2a5d176b5d27beb5717376da78d2e881b96c80d78f783fa3d289d24909e791563bddc6cf0d52db455469e41cbf3ebb76d713d162228461d8380b2d85d34afaabbd4c5c19b9c4a1f2796ac6c33325edf0596bcce6af97ca4822bc9af7c8469c45d8eae169ee6542e9756325004f92c75e2d824bab5516df8d1b4546a62523d5061ea25718205b8b570e2cf5fa4292fe9bb502ded48489aebd31fdb4fc8d02e033e9b6cd8d968cb632b4db9dcd5db99937dc4f106741b960a624f7bae13c80e281e837a4b3851726b1dea21620867bef0d8ca1643d9428eea84e13ace39e10afe5a3ae707a5c98636cff09e0641462a9b648902bcc4bee0682363ce473b324837d17965ac8b77bb6ba6cd1fe417f91174c043f9c38460d5f460cb42394979c4ff1e29a21fc741f66d35c6f3238319cf7ed6c81aba30a2e9a9ed990f7e3aa98ed0af552b29ae14b9e0676928a7775d0f063597cc54c766515b0843a3319d72b483085b94538a3c94744cbed50580d988d9925b1fb061d141b6e36897de173c1fc2d485745878a945f9c9546dfebad0c6274ba7a3bcd8a5214a6d566cd8dec20439d58b8b4f0f5ee0096790287aa007e56a609d37a7a824996d523cd585ec574fe48ccbf2f94f7a909bebb8c4fb4ba08acd9bab71efea2df727613bb8a85dc0ce1eb22486bc07c98cc523ad234a4c81a748df59cf89a0ac214719b9dadefca3ee610d7de24d2da30e76456867303679c3a09125a977bbe02e3f50d309f223a8154188b85956eddbc491e2a904c5bfa34b54151bfa9fb6398d7bd819c6bb995b2e36a8fd260ee97e4a271801e9341b7c9e348aeb006de6edd8524a95b2c0ae30b16efa2fbeba12bbd3e6e5a038090e2676f0e277d19ff260ea1894cde0406189bab5944b89d40137331d3657393dc644567d6710293b6f404f35857445dd7c8e509cb8b1cd7158531b08d32868c1398759b11819522c2bf44b5c0ff499f398f0293a5403eef2e638337080e5a2dacc90938b9abeb49765df650214116c6eefdf00bda76f649e9052acc15ff6c9abba6fd61506d4752f560665bbea3281f8bbe76a2d192781f86e403029b0dd951efd5d46fd544391cc52c81a2448e100c818d3242eb13a7b7bafcb42f066aa60747e44915d28c676b87a7903ec24f9e2e2e9648bba91ff7e20463699a3dc91647691b818e62bd6f3265189d2f78427588a295731d8dace19fbf5175fbf5a0fbec14594d32acab3328d11dff8a1d6892d18899ec19c60b42863957097a53ca3c56871e8a1ee949eae50f718ba9056787a5465dc09490473f233f9aced75b4727c4bd9c260b080fad3006553d31848ba8af7837b609bdc297e3ef61d6282bdfbb102675abbaf4153d3d11ac5d9d3e1fb1ed19865fd9d5548c27eb3e39904c3e57a0ed28067c861d05bbba12e4175e717e2eccac107088b53519554eee721d2ab6253a2dcf0135e527b0899807074c3b9be8d327c997f49702bc6becda1361a431093043ddedb10c242abb4b1611a4d80a87b2a4b4a629f56082cfc23cdb6731b72cb8cc22d36f1fd649de0e10907c9ef21b02eb26417b3489fcd3d769ab936af544e73d27b57e2d7e3bf4bafb58339de69476e41e6e2ee77ac0f3176bbac3540d8130d56ac2a96be3bb0b3d9e23f442bad49a2c27a0e5019426d931f375589f4270f88b2efdf32536b7e80890174d9ce0415d1cd48ac872744f5da1d339f58173e48321faaa2413c0e48d4465d951dce849071680d13ecf3f7820ba3f34919bed4166be8bc1177217c1243124a8a37035766e0118d7b0f593c29077c507ca1064ca949e70bf9bd1706abda3f28462fb7d8c444cc0f5e6d20f43cf0073ea49c4f100bffdfbea375e5f35d3ce589d6cc2bc45d0b7f106a811c61429570e6e5417a2089aa6676acb99d5cb4995c6b157575c4315c2dbfa3c5c2bb4c21f3c0de99352211dd5952c206614d85bbf0a16b1a83da7e9ef2a77409f4c9785ca0cb8ffcf81782edc8e4ef55222bba048e43a579ba05139da99d11a1b09917631fd4575461029eac89c491e42b5fc8b1a18435b5af1e783cd6a8dfff477257d06401e8c4907d4c31f1fb919d7f52dcb1ab4864c8396c159e4e576318f849ebc84c286056166a166a7b0524ce2d9678e9265c2c20d362586d44224cd35e54201c301d5b81aef0bc11f77d398c43880c3f69b51f1fd339e7a03a2cd87a4da8348672f314c0f54e8168cad541582746303e44ba548d50eaa6c4bfbbee3410ea7543fbf632f5d20bccdf572876cd058bfdf2d57c3f7ef1a72d3cb2446c4e669f1227817bc0b7823ab13b6625af2191371d8aa6b7505c6038a1ec52954c162f889b6c29f00c00a73613462bafeff3a8a16190eff12b2b98079c9bfbe436aac4117216ea69eecc8cb87451beca396bc65ebfeb376559423b0c51073319ac3c18fc252f96c8a5ea6cf9e6e13173bc995e13e7191fd3abb64215699580d1c6a5f937534f48e57603251b1c51fdbb6e55540871a53e4be20d21cb08b7fbffe9ea34d88e9df8576887dc63aac382f2f4d3b19e0deaff5a4eb412257dfe2b49af50be23201b98e002e5f7d9cc2b535cac17ce70a0f0bf3548c56600fed3fdf374907b9fcd721d5fc81231acb6a62eaf9d3eb9ce6d7ae12ed0b90a06688100343eea90f781a0bfa1d6fb02adafbd42e7be006be8031828979a03edb9c28deeb2ff127587099f7c68d4eb241b446d885c228252d41396f51366aef826446c0e6df59afb9c3a2b1a6736e2e0fef9f651d3ae1bba08c6190ddd3b5adeb530c74b02f292adddbbea61c1c060f3083ffd1a0abd24b69a5d75d5500411ce2ca96693da26831edd92d70eec1b3ab07a6c2d1fc4a83d037f8350536f3a095513f4a8d5ad1ac79e149fb79ef1a7037cb8f2471599fb6cdeb64dcc7eed27fe4cadf19b464893e3e79ea26914df7a8a0287c7b9c16e25b5cf268512c51f0f7cf1f278f812e5409f49aceaeb3edb0f82da095f0209cd5add0853b318e2f08c41f92d79d8736651964f3f225cbac9afac005dcb9762d7c4a3bcf826f007897e0b69029d23313f43068c1bd1a3a43417d4871328b51ecb298f5ce57528742f25853d61a7c07b9980e174589f7a859125e9063922b1dcb1b300530bc205c9a82f82db6a24e279037ce9f770f6e459fa4c2c3e8f05b47b43dc77bae614e461268825bfa6b0753217eb0da1732c76a54edad83d48a0117109eb11fb02320c68d02e8015cc5a0b3129b118b99efe9b7625780c7fab74201e0b076d94af03ccd54ed2b0e3094b7d4b2081c2e5337ee04f55a674c759eb617e3cc02769c541f741a0be17dfde27ec07f7c2db8c419907b0c1084053fd299bf1376b42accff718c6bd0e6eca6f15845771595857883860643f79eaa1e250fbd495ef926781b3ba9d92cdef8ad6283a036de49d7f95cdd2e0febba2d53326d976874f4dde6a02aafdbfabf8b989085efddd0d0df26afc10f49ff327bbfc17bcd6efecbf204af6ff3ca3868c6476a6c9bd2b54052dd324d4333fdd215876b2364cb648bb75185f5ba42553d19a35fff10959c1e6b41a1565dab4025cc5cb0010f0ca7c8cb09dfa4d8807c007a5a8f91613e25260e22703e784b77b017571187edd3cb714396f6f700925259f51707ab1f7c3ffdb263c1e2f1023b728e1e7467a242abffd1b40f7953416276e69e89f110d3d5e93b97a9a6e0d0d9555a52f9cdc9faffa259d5deff2af58a40aa4f19a4ce33d9373d214b66ec129cb3ef5c21e5132724b83ea43ecacf04dda68c25bf88b1b1253ce74f10d7b4d4b43d6fa437d1469b7f70082b2353ff5781d92f6fa57b1dddb34dd23b3fd17209e2eae4231612c340ab7c384a6b1ee5cf4895563caae375cd859c97edc6ecac6ea5c08adb7afe6b534d80a0725cf60be31c4e6fd03b4751b67a7a7224504e68ae8c8d209bf8bb49ba8e93b62e1bfac8789cbd551909a76dd631f86423b416a7dd614df1db17eb901276a7e7b5a3426d38f62f4bd298e3cc3d2d57a9db9ad61f61b16addb3f103ac681331879621682025589e41ba1abe2efaf2ab46370d8f6887315cb804ac373a83b1f63d6d3d1b55daf306749c52f5398545acbc3d6a2cfe75ad596e29508541b8e3b930558bfa3375ae9892274af8a9710e801c73e227dbdd2fba448f2617af450a2e3d0dfe963c0cdbcc7fda15eb4557e3b578ef42c77ac90d32a1ca59931ade43542ccefaa202b64cccbc79e74924aac055e2eefe0370175cff5dc62912e5aa857a9df4ef7b9fbcd7427de711dceb31e08d51238a9cc83f07e84c26cd1b0150ca2c9579c88668750bde1c9311a92a90c710085a891492832b0ae6785fd8a2bb43cb973ade0040439e6ef31099e84cdd1c016e407006a43220559e761b238b366f05866bf512de218341b63d5e6a58253f69e556c4c77ccf5f4cf203e6213b06d7f47e0b672557b1b67439216ed8d26e14304af7125b03374eb6f6fa5c3a462c546aec625c874c97811f1ae36a255a39e211f51b8228be0d4ff2c7f15953064692a325994271de89ac60081adb15b7576cb347f5f28fd4efe423ae86e199ce23e7388523c711ce8a369cfd00d0c166b27b76e83ab65029bd68b6be60a420c8017d25ff07b9aef980db7dfcd0307a6ad8d161a36e0ac3aabc116e0bb08cc724a9e3fd7c650e1778ba6c55d114259c5804d887aa37db3934836efa5b5f7729c709d5b43c4c1aef7ebbdc337ac27585bd832022e30a92ce3760619d7d6edc8b077ff7da30600776d7ca7a956273f18f76bd6ad92f59c4d8a031f75db123bda1bea06bd2cfa86517e974f79b8cef778f7","isRememberEnabled":true,"rememberDurationInDays":0,"staticryptSaltUniqueVariableName":"92a92d428d96a594af196de28f03ddc1"};

            // you can edit these values to customize some of the behavior of StatiCrypt
            const templateConfig = {
                rememberExpirationKey: "staticrypt_expiration",
                rememberPassphraseKey: "staticrypt_passphrase",
                replaceHtmlCallback: null,
                clearLocalStorageCallback: null,
            };

            // init the staticrypt engine
            const staticrypt = staticryptInitiator.init(staticryptConfig, templateConfig);

            // try to automatically decrypt on load if there is a saved password
            window.onload = async function () {
                const { isSuccessful } = await staticrypt.handleDecryptOnLoad();

                // if we didn't decrypt anything on load, show the password prompt. Otherwise the content has already been
                // replaced, no need to do anything
                if (!isSuccessful) {
                    // hide loading screen
                    document.getElementById("staticrypt_loading").classList.add("hidden");
                    document.getElementById("staticrypt_content").classList.remove("hidden");
                    document.getElementById("staticrypt-password").focus();

                    // show the remember me checkbox
                    if (isRememberEnabled) {
                        document.getElementById("staticrypt-remember-label").classList.remove("hidden");
                    }
                }
            };

            // handle password form submission
            document.getElementById("staticrypt-form").addEventListener("submit", async function (e) {
                e.preventDefault();

                const password = document.getElementById("staticrypt-password").value,
                    isRememberChecked = document.getElementById("staticrypt-remember").checked;

                const { isSuccessful } = await staticrypt.handleDecryptionOfPage(password, isRememberChecked);

                if (!isSuccessful) {
                    alert(templateError);
                }
            });
        </script>
    </body>
</html>
