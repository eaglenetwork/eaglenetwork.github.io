<!DOCTYPE html>
<html class="staticrypt-html">
    <head>
        <meta charset="utf-8" />
        <title>EduLock</title>
        <meta name="viewport" content="width=device-width, initial-scale=1" />

        <!-- do not cache this page -->
        <meta http-equiv="cache-control" content="max-age=0" />
        <meta http-equiv="cache-control" content="no-cache" />
        <meta http-equiv="expires" content="0" />
        <meta http-equiv="expires" content="Tue, 01 Jan 1980 1:00:00 GMT" />
        <meta http-equiv="pragma" content="no-cache" />

        <style>
            .staticrypt-hr {
                margin-top: 20px;
                margin-bottom: 20px;
                border: 0;
                border-top: 1px solid #eee;
            }

            .staticrypt-page {
                width: 360px;
                padding: 8% 0 0;
                margin: auto;
                box-sizing: border-box;
            }

            .staticrypt-form {
                position: relative;
                z-index: 1;
                background: #ffffff;
                max-width: 360px;
                margin: 0 auto 100px;
                padding: 45px;
                text-align: center;
                box-shadow: 0 0 20px 0 rgba(0, 0, 0, 0.2), 0 5px 5px 0 rgba(0, 0, 0, 0.24);
            }

            .staticrypt-form input[type="password"],
            input[type="text"] {
                background: inherit;
                border: 0;
                box-sizing: border-box; /* This ensures padding is included in the total width */
                font-size: 14px;
                outline: 0;
                padding: 15px 30px 15px 15px; /* Adjust the padding to ensure there is space for the icon */
                width: 100%;
            }

            .staticrypt-password-container {
                position: relative;
                outline: 0;
                background: #f2f2f2;
                width: 100%;
                border: 0;
                margin: 0 0 15px;
                box-sizing: border-box;
            }

            .staticrypt-toggle-password-visibility {
                cursor: pointer;
                height: 20px;
                opacity: 60%;
                padding: 13px;
                position: absolute;
                right: 0;
                top: 50%;
                transform: translateY(-50%);
                width: 20px;
            }

            .staticrypt-form .staticrypt-decrypt-button {
                text-transform: uppercase;
                outline: 0;
                background: #4CAF50;
                width: 100%;
                border: 0;
                padding: 15px;
                color: #ffffff;
                font-size: 14px;
                cursor: pointer;
            }

            .staticrypt-form .staticrypt-decrypt-button:hover,
            .staticrypt-form .staticrypt-decrypt-button:active,
            .staticrypt-form .staticrypt-decrypt-button:focus {
                background: #4CAF50;
                filter: brightness(92%);
            }

            .staticrypt-html {
                height: 100%;
            }

            .staticrypt-body {
                height: 100%;
                margin: 0;
            }

            .staticrypt-content {
                height: 100%;
                margin-bottom: 1em;
                background: #76B852;
                font-family: "Arial", sans-serif;
                -webkit-font-smoothing: antialiased;
                -moz-osx-font-smoothing: grayscale;
            }

            .staticrypt-instructions {
                margin-top: -1em;
                margin-bottom: 1em;
            }

            .staticrypt-title {
                font-size: 1.5em;
            }

            label.staticrypt-remember {
                display: flex;
                align-items: center;
                margin-bottom: 1em;
            }

            .staticrypt-remember input[type="checkbox"] {
                transform: scale(1.5);
                margin-right: 1em;
            }

            .hidden {
                display: none !important;
            }

            .staticrypt-spinner-container {
                height: 100%;
                display: flex;
                align-items: center;
                justify-content: center;
            }

            .staticrypt-spinner {
                display: inline-block;
                width: 2rem;
                height: 2rem;
                vertical-align: text-bottom;
                border: 0.25em solid gray;
                border-right-color: transparent;
                border-radius: 50%;
                -webkit-animation: spinner-border 0.75s linear infinite;
                animation: spinner-border 0.75s linear infinite;
                animation-duration: 0.75s;
                animation-timing-function: linear;
                animation-delay: 0s;
                animation-iteration-count: infinite;
                animation-direction: normal;
                animation-fill-mode: none;
                animation-play-state: running;
                animation-name: spinner-border;
            }

            @keyframes spinner-border {
                100% {
                    transform: rotate(360deg);
                }
            }
        </style>
    </head>

    <body class="staticrypt-body">
        <div id="staticrypt_loading" class="staticrypt-spinner-container">
            <div class="staticrypt-spinner"></div>
        </div>

        <div id="staticrypt_content" class="staticrypt-content hidden">
            <div class="staticrypt-page">
                <div class="staticrypt-form">
                    <div class="staticrypt-instructions">
                        <p class="staticrypt-title">EduLock</p>
                        <p><p>Please ask Clark for the password to this royal ahh website!</p>
</p>
                    </div>

                    <hr class="staticrypt-hr" />

                    <form id="staticrypt-form" action="#" method="post">
                        <div class="staticrypt-password-container">
                            <input
                                id="staticrypt-password"
                                type="password"
                                name="password"
                                placeholder="Password"
                                autofocus
                            />

                            <img
                                class="staticrypt-toggle-password-visibility"
                                alt="template_toggle_show"
                                title="template_toggle_show"
                                src="data:image/svg+xml;base64,PHN2ZyB4bWxucz0iaHR0cDovL3d3dy53My5vcmcvMjAwMC9zdmciIHZpZXdCb3g9IjAgMCA2NDAgNTEyIj48IS0tIUZvbnQgQXdlc29tZSBGcmVlIDYuNS4yIGJ5IEBmb250YXdlc29tZSAtIGh0dHBzOi8vZm9udGF3ZXNvbWUuY29tIExpY2Vuc2UgLSBodHRwczovL2ZvbnRhd2Vzb21lLmNvbS9saWNlbnNlL2ZyZWUgQ29weXJpZ2h0IDIwMjQgRm9udGljb25zLCBJbmMuLS0+PHBhdGggZD0iTTM4LjggNS4xQzI4LjQtMy4xIDEzLjMtMS4yIDUuMSA5LjJTLTEuMiAzNC43IDkuMiA0Mi45bDU5MiA0NjRjMTAuNCA4LjIgMjUuNSA2LjMgMzMuNy00LjFzNi4zLTI1LjUtNC4xLTMzLjdMNTI1LjYgMzg2LjdjMzkuNi00MC42IDY2LjQtODYuMSA3OS45LTExOC40YzMuMy03LjkgMy4zLTE2LjcgMC0yNC42Yy0xNC45LTM1LjctNDYuMi04Ny43LTkzLTEzMS4xQzQ2NS41IDY4LjggNDAwLjggMzIgMzIwIDMyYy02OC4yIDAtMTI1IDI2LjMtMTY5LjMgNjAuOEwzOC44IDUuMXpNMjIzLjEgMTQ5LjVDMjQ4LjYgMTI2LjIgMjgyLjcgMTEyIDMyMCAxMTJjNzkuNSAwIDE0NCA2NC41IDE0NCAxNDRjMCAyNC45LTYuMyA0OC4zLTE3LjQgNjguN0w0MDggMjk0LjVjOC40LTE5LjMgMTAuNi00MS40IDQuOC02My4zYy0xMS4xLTQxLjUtNDcuOC02OS40LTg4LjYtNzEuMWMtNS44LS4yLTkuMiA2LjEtNy40IDExLjdjMi4xIDYuNCAzLjMgMTMuMiAzLjMgMjAuM2MwIDEwLjItMi40IDE5LjgtNi42IDI4LjNsLTkwLjMtNzAuOHpNMzczIDM4OS45Yy0xNi40IDYuNS0zNC4zIDEwLjEtNTMgMTAuMWMtNzkuNSAwLTE0NC02NC41LTE0NC0xNDRjMC02LjkgLjUtMTMuNiAxLjQtMjAuMkw4My4xIDE2MS41QzYwLjMgMTkxLjIgNDQgMjIwLjggMzQuNSAyNDMuN2MtMy4zIDcuOS0zLjMgMTYuNyAwIDI0LjZjMTQuOSAzNS43IDQ2LjIgODcuNyA5MyAxMzEuMUMxNzQuNSA0NDMuMiAyMzkuMiA0ODAgMzIwIDQ4MGM0Ny44IDAgODkuOS0xMi45IDEyNi4yLTMyLjVMMzczIDM4OS45eiIvPjwvc3ZnPg=="
                            />
                        </div>

                        <label id="staticrypt-remember-label" class="staticrypt-remember hidden">
                            <input id="staticrypt-remember" type="checkbox" name="remember" />
                            Remember me
                        </label>

                        <input type="submit" class="staticrypt-decrypt-button" value="enter" />
                    </form>
                </div>
            </div>
        </div>

        <script>
            // these variables will be filled when generating the file - the template format is 'variable_name'
            const staticryptInitiator = 
            ((function(){
  const exports = {};
  const cryptoEngine = ((function(){
  const exports = {};
  const { subtle } = crypto;

const IV_BITS = 16 * 8;
const HEX_BITS = 4;
const ENCRYPTION_ALGO = "AES-CBC";

/**
 * Translates between utf8 encoded hexadecimal strings
 * and Uint8Array bytes.
 */
const HexEncoder = {
    /**
     * hex string -> bytes
     * @param {string} hexString
     * @returns {Uint8Array}
     */
    parse: function (hexString) {
        if (hexString.length % 2 !== 0) throw "Invalid hexString";
        const arrayBuffer = new Uint8Array(hexString.length / 2);

        for (let i = 0; i < hexString.length; i += 2) {
            const byteValue = parseInt(hexString.substring(i, i + 2), 16);
            if (isNaN(byteValue)) {
                throw "Invalid hexString";
            }
            arrayBuffer[i / 2] = byteValue;
        }
        return arrayBuffer;
    },

    /**
     * bytes -> hex string
     * @param {Uint8Array} bytes
     * @returns {string}
     */
    stringify: function (bytes) {
        const hexBytes = [];

        for (let i = 0; i < bytes.length; ++i) {
            let byteString = bytes[i].toString(16);
            if (byteString.length < 2) {
                byteString = "0" + byteString;
            }
            hexBytes.push(byteString);
        }
        return hexBytes.join("");
    },
};

/**
 * Translates between utf8 strings and Uint8Array bytes.
 */
const UTF8Encoder = {
    parse: function (str) {
        return new TextEncoder().encode(str);
    },

    stringify: function (bytes) {
        return new TextDecoder().decode(bytes);
    },
};

/**
 * Salt and encrypt a msg with a password.
 */
async function encrypt(msg, hashedPassword) {
    // Must be 16 bytes, unpredictable, and preferably cryptographically random. However, it need not be secret.
    // https://developer.mozilla.org/en-US/docs/Web/API/SubtleCrypto/encrypt#parameters
    const iv = crypto.getRandomValues(new Uint8Array(IV_BITS / 8));

    const key = await subtle.importKey("raw", HexEncoder.parse(hashedPassword), ENCRYPTION_ALGO, false, ["encrypt"]);

    const encrypted = await subtle.encrypt(
        {
            name: ENCRYPTION_ALGO,
            iv: iv,
        },
        key,
        UTF8Encoder.parse(msg)
    );

    // iv will be 32 hex characters, we prepend it to the ciphertext for use in decryption
    return HexEncoder.stringify(iv) + HexEncoder.stringify(new Uint8Array(encrypted));
}
exports.encrypt = encrypt;

/**
 * Decrypt a salted msg using a password.
 *
 * @param {string} encryptedMsg
 * @param {string} hashedPassword
 * @returns {Promise<string>}
 */
async function decrypt(encryptedMsg, hashedPassword) {
    const ivLength = IV_BITS / HEX_BITS;
    const iv = HexEncoder.parse(encryptedMsg.substring(0, ivLength));
    const encrypted = encryptedMsg.substring(ivLength);

    const key = await subtle.importKey("raw", HexEncoder.parse(hashedPassword), ENCRYPTION_ALGO, false, ["decrypt"]);

    const outBuffer = await subtle.decrypt(
        {
            name: ENCRYPTION_ALGO,
            iv: iv,
        },
        key,
        HexEncoder.parse(encrypted)
    );

    return UTF8Encoder.stringify(new Uint8Array(outBuffer));
}
exports.decrypt = decrypt;

/**
 * Salt and hash the password so it can be stored in localStorage without opening a password reuse vulnerability.
 *
 * @param {string} password
 * @param {string} salt
 * @returns {Promise<string>}
 */
async function hashPassword(password, salt) {
    // we hash the password in multiple steps, each adding more iterations. This is because we used to allow less
    // iterations, so for backward compatibility reasons, we need to support going from that to more iterations.
    let hashedPassword = await hashLegacyRound(password, salt);

    hashedPassword = await hashSecondRound(hashedPassword, salt);

    return hashThirdRound(hashedPassword, salt);
}
exports.hashPassword = hashPassword;

/**
 * This hashes the password with 1k iterations. This is a low number, we need this function to support backwards
 * compatibility.
 *
 * @param {string} password
 * @param {string} salt
 * @returns {Promise<string>}
 */
function hashLegacyRound(password, salt) {
    return pbkdf2(password, salt, 1000, "SHA-1");
}
exports.hashLegacyRound = hashLegacyRound;

/**
 * Add a second round of iterations. This is because we used to use 1k, so for backwards compatibility with
 * remember-me/autodecrypt links, we need to support going from that to more iterations.
 *
 * @param hashedPassword
 * @param salt
 * @returns {Promise<string>}
 */
function hashSecondRound(hashedPassword, salt) {
    return pbkdf2(hashedPassword, salt, 14000, "SHA-256");
}
exports.hashSecondRound = hashSecondRound;

/**
 * Add a third round of iterations to bring total number to 600k. This is because we used to use 1k, then 15k, so for
 * backwards compatibility with remember-me/autodecrypt links, we need to support going from that to more iterations.
 *
 * @param hashedPassword
 * @param salt
 * @returns {Promise<string>}
 */
function hashThirdRound(hashedPassword, salt) {
    return pbkdf2(hashedPassword, salt, 585000, "SHA-256");
}
exports.hashThirdRound = hashThirdRound;

/**
 * Salt and hash the password so it can be stored in localStorage without opening a password reuse vulnerability.
 *
 * @param {string} password
 * @param {string} salt
 * @param {int} iterations
 * @param {string} hashAlgorithm
 * @returns {Promise<string>}
 */
async function pbkdf2(password, salt, iterations, hashAlgorithm) {
    const key = await subtle.importKey("raw", UTF8Encoder.parse(password), "PBKDF2", false, ["deriveBits"]);

    const keyBytes = await subtle.deriveBits(
        {
            name: "PBKDF2",
            hash: hashAlgorithm,
            iterations,
            salt: UTF8Encoder.parse(salt),
        },
        key,
        256
    );

    return HexEncoder.stringify(new Uint8Array(keyBytes));
}

function generateRandomSalt() {
    const bytes = crypto.getRandomValues(new Uint8Array(128 / 8));

    return HexEncoder.stringify(new Uint8Array(bytes));
}
exports.generateRandomSalt = generateRandomSalt;

async function signMessage(hashedPassword, message) {
    const key = await subtle.importKey(
        "raw",
        HexEncoder.parse(hashedPassword),
        {
            name: "HMAC",
            hash: "SHA-256",
        },
        false,
        ["sign"]
    );
    const signature = await subtle.sign("HMAC", key, UTF8Encoder.parse(message));

    return HexEncoder.stringify(new Uint8Array(signature));
}
exports.signMessage = signMessage;

function getRandomAlphanum() {
    const possibleCharacters = "abcdefghijklmnopqrstuvwxyzABCDEFGHIJKLMNOPQRSTUVWXYZ0123456789";

    let byteArray;
    let parsedInt;

    // Keep generating new random bytes until we get a value that falls
    // within a range that can be evenly divided by possibleCharacters.length
    do {
        byteArray = crypto.getRandomValues(new Uint8Array(1));
        // extract the lowest byte to get an int from 0 to 255 (probably unnecessary, since we're only generating 1 byte)
        parsedInt = byteArray[0] & 0xff;
    } while (parsedInt >= 256 - (256 % possibleCharacters.length));

    // Take the modulo of the parsed integer to get a random number between 0 and totalLength - 1
    const randomIndex = parsedInt % possibleCharacters.length;

    return possibleCharacters[randomIndex];
}

/**
 * Generate a random string of a given length.
 *
 * @param {int} length
 * @returns {string}
 */
function generateRandomString(length) {
    let randomString = "";

    for (let i = 0; i < length; i++) {
        randomString += getRandomAlphanum();
    }

    return randomString;
}
exports.generateRandomString = generateRandomString;

  return exports;
})());
const codec = ((function(){
  const exports = {};
  /**
 * Initialize the codec with the provided cryptoEngine - this return functions to encode and decode messages.
 *
 * @param cryptoEngine - the engine to use for encryption / decryption
 */
function init(cryptoEngine) {
    const exports = {};

    /**
     * Top-level function for encoding a message.
     * Includes password hashing, encryption, and signing.
     *
     * @param {string} msg
     * @param {string} password
     * @param {string} salt
     *
     * @returns {string} The encoded text
     */
    async function encode(msg, password, salt) {
        const hashedPassword = await cryptoEngine.hashPassword(password, salt);

        const encrypted = await cryptoEngine.encrypt(msg, hashedPassword);

        // we use the hashed password in the HMAC because this is effectively what will be used a password (so we can store
        // it in localStorage safely, we don't use the clear text password)
        const hmac = await cryptoEngine.signMessage(hashedPassword, encrypted);

        return hmac + encrypted;
    }
    exports.encode = encode;

    /**
     * Encode using a password that has already been hashed. This is useful to encode multiple messages in a row, that way
     * we don't need to hash the password multiple times.
     *
     * @param {string} msg
     * @param {string} hashedPassword
     *
     * @returns {string} The encoded text
     */
    async function encodeWithHashedPassword(msg, hashedPassword) {
        const encrypted = await cryptoEngine.encrypt(msg, hashedPassword);

        // we use the hashed password in the HMAC because this is effectively what will be used a password (so we can store
        // it in localStorage safely, we don't use the clear text password)
        const hmac = await cryptoEngine.signMessage(hashedPassword, encrypted);

        return hmac + encrypted;
    }
    exports.encodeWithHashedPassword = encodeWithHashedPassword;

    /**
     * Top-level function for decoding a message.
     * Includes signature check and decryption.
     *
     * @param {string} signedMsg
     * @param {string} hashedPassword
     * @param {string} salt
     * @param {int} backwardCompatibleAttempt
     * @param {string} originalPassword
     *
     * @returns {Object} {success: true, decoded: string} | {success: false, message: string}
     */
    async function decode(signedMsg, hashedPassword, salt, backwardCompatibleAttempt = 0, originalPassword = "") {
        const encryptedHMAC = signedMsg.substring(0, 64);
        const encryptedMsg = signedMsg.substring(64);
        const decryptedHMAC = await cryptoEngine.signMessage(hashedPassword, encryptedMsg);

        if (decryptedHMAC !== encryptedHMAC) {
            // we have been raising the number of iterations in the hashing algorithm multiple times, so to support the old
            // remember-me/autodecrypt links we need to try bringing the old hashes up to speed.
            originalPassword = originalPassword || hashedPassword;
            if (backwardCompatibleAttempt === 0) {
                const updatedHashedPassword = await cryptoEngine.hashThirdRound(originalPassword, salt);

                return decode(signedMsg, updatedHashedPassword, salt, backwardCompatibleAttempt + 1, originalPassword);
            }
            if (backwardCompatibleAttempt === 1) {
                let updatedHashedPassword = await cryptoEngine.hashSecondRound(originalPassword, salt);
                updatedHashedPassword = await cryptoEngine.hashThirdRound(updatedHashedPassword, salt);

                return decode(signedMsg, updatedHashedPassword, salt, backwardCompatibleAttempt + 1, originalPassword);
            }

            return { success: false, message: "Signature mismatch" };
        }

        return {
            success: true,
            decoded: await cryptoEngine.decrypt(encryptedMsg, hashedPassword),
        };
    }
    exports.decode = decode;

    return exports;
}
exports.init = init;

  return exports;
})());
const decode = codec.init(cryptoEngine).decode;

/**
 * Initialize the staticrypt module, that exposes functions callbable by the password_template.
 *
 * @param {{
 *  staticryptEncryptedMsgUniqueVariableName: string,
 *  isRememberEnabled: boolean,
 *  rememberDurationInDays: number,
 *  staticryptSaltUniqueVariableName: string,
 * }} staticryptConfig - object of data that is stored on the password_template at encryption time.
 *
 * @param {{
 *  rememberExpirationKey: string,
 *  rememberPassphraseKey: string,
 *  replaceHtmlCallback: function,
 *  clearLocalStorageCallback: function,
 * }} templateConfig - object of data that can be configured by a custom password_template.
 */
function init(staticryptConfig, templateConfig) {
    const exports = {};

    /**
     * Decrypt our encrypted page, replace the whole HTML.
     *
     * @param {string} hashedPassword
     * @returns {Promise<boolean>}
     */
    async function decryptAndReplaceHtml(hashedPassword) {
        const { staticryptEncryptedMsgUniqueVariableName, staticryptSaltUniqueVariableName } = staticryptConfig;
        const { replaceHtmlCallback } = templateConfig;

        const result = await decode(
            staticryptEncryptedMsgUniqueVariableName,
            hashedPassword,
            staticryptSaltUniqueVariableName
        );
        if (!result.success) {
            return false;
        }
        const plainHTML = result.decoded;

        // if the user configured a callback call it, otherwise just replace the whole HTML
        if (typeof replaceHtmlCallback === "function") {
            replaceHtmlCallback(plainHTML);
        } else {
            document.write(plainHTML);
            document.close();
        }

        return true;
    }

    /**
     * Attempt to decrypt the page and replace the whole HTML.
     *
     * @param {string} password
     * @param {boolean} isRememberChecked
     *
     * @returns {Promise<{isSuccessful: boolean, hashedPassword?: string}>} - we return an object, so that if we want to
     *   expose more information in the future we can do it without breaking the password_template
     */
    async function handleDecryptionOfPage(password, isRememberChecked) {
        const { staticryptSaltUniqueVariableName } = staticryptConfig;

        // decrypt and replace the whole page
        const hashedPassword = await cryptoEngine.hashPassword(password, staticryptSaltUniqueVariableName);
        return handleDecryptionOfPageFromHash(hashedPassword, isRememberChecked);
    }
    exports.handleDecryptionOfPage = handleDecryptionOfPage;

    async function handleDecryptionOfPageFromHash(hashedPassword, isRememberChecked) {
        const { isRememberEnabled, rememberDurationInDays } = staticryptConfig;
        const { rememberExpirationKey, rememberPassphraseKey } = templateConfig;

        const isDecryptionSuccessful = await decryptAndReplaceHtml(hashedPassword);

        if (!isDecryptionSuccessful) {
            return {
                isSuccessful: false,
                hashedPassword,
            };
        }

        // remember the hashedPassword and set its expiration if necessary
        if (isRememberEnabled && isRememberChecked) {
            window.localStorage.setItem(rememberPassphraseKey, hashedPassword);

            // set the expiration if the duration isn't 0 (meaning no expiration)
            if (rememberDurationInDays > 0) {
                window.localStorage.setItem(
                    rememberExpirationKey,
                    (new Date().getTime() + rememberDurationInDays * 24 * 60 * 60 * 1000).toString()
                );
            }
        }

        return {
            isSuccessful: true,
            hashedPassword,
        };
    }
    exports.handleDecryptionOfPageFromHash = handleDecryptionOfPageFromHash;

    /**
     * Clear localstorage from staticrypt related values
     */
    function clearLocalStorage() {
        const { clearLocalStorageCallback, rememberExpirationKey, rememberPassphraseKey } = templateConfig;

        if (typeof clearLocalStorageCallback === "function") {
            clearLocalStorageCallback();
        } else {
            localStorage.removeItem(rememberPassphraseKey);
            localStorage.removeItem(rememberExpirationKey);
        }
    }

    async function handleDecryptOnLoad() {
        let isSuccessful = await decryptOnLoadFromUrl();

        if (!isSuccessful) {
            isSuccessful = await decryptOnLoadFromRememberMe();
        }

        return { isSuccessful };
    }
    exports.handleDecryptOnLoad = handleDecryptOnLoad;

    /**
     * Clear storage if we are logging out
     *
     * @returns {boolean} - whether we logged out
     */
    function logoutIfNeeded() {
        const logoutKey = "staticrypt_logout";

        // handle logout through query param
        const queryParams = new URLSearchParams(window.location.search);
        if (queryParams.has(logoutKey)) {
            clearLocalStorage();
            return true;
        }

        // handle logout through URL fragment
        const hash = window.location.hash.substring(1);
        if (hash.includes(logoutKey)) {
            clearLocalStorage();
            return true;
        }

        return false;
    }

    /**
     * To be called on load: check if we want to try to decrypt and replace the HTML with the decrypted content, and
     * try to do it if needed.
     *
     * @returns {Promise<boolean>} true if we derypted and replaced the whole page, false otherwise
     */
    async function decryptOnLoadFromRememberMe() {
        const { rememberDurationInDays } = staticryptConfig;
        const { rememberExpirationKey, rememberPassphraseKey } = templateConfig;

        // if we are login out, terminate
        if (logoutIfNeeded()) {
            return false;
        }

        // if there is expiration configured, check if we're not beyond the expiration
        if (rememberDurationInDays && rememberDurationInDays > 0) {
            const expiration = localStorage.getItem(rememberExpirationKey),
                isExpired = expiration && new Date().getTime() > parseInt(expiration);

            if (isExpired) {
                clearLocalStorage();
                return false;
            }
        }

        const hashedPassword = localStorage.getItem(rememberPassphraseKey);

        if (hashedPassword) {
            // try to decrypt
            const isDecryptionSuccessful = await decryptAndReplaceHtml(hashedPassword);

            // if the decryption is unsuccessful the password might be wrong - silently clear the saved data and let
            // the user fill the password form again
            if (!isDecryptionSuccessful) {
                clearLocalStorage();
                return false;
            }

            return true;
        }

        return false;
    }

    async function decryptOnLoadFromUrl() {
        const passwordKey = "staticrypt_pwd";
        const rememberMeKey = "remember_me";

        // try to get the password from the query param (for backward compatibility - we now want to avoid this method,
        // since it sends the hashed password to the server which isn't needed)
        const queryParams = new URLSearchParams(window.location.search);
        const hashedPasswordQuery = queryParams.get(passwordKey);
        const rememberMeQuery = queryParams.get(rememberMeKey);

        const urlFragment = window.location.hash.substring(1);
        // get the password from the url fragment
        const hashedPasswordRegexMatch = urlFragment.match(new RegExp(passwordKey + "=([^&]*)"));
        const hashedPasswordFragment = hashedPasswordRegexMatch ? hashedPasswordRegexMatch[1] : null;
        const rememberMeFragment = urlFragment.includes(rememberMeKey);

        const hashedPassword = hashedPasswordFragment || hashedPasswordQuery;
        const rememberMe = rememberMeFragment || rememberMeQuery;

        if (hashedPassword) {
            return handleDecryptionOfPageFromHash(hashedPassword, rememberMe);
        }

        return false;
    }

    return exports;
}
exports.init = init;

  return exports;
})());
        ;
            const templateError = "template_error",
                templateToggleAltShow = "template_toggle_show",
                templateToggleAltHide = "template_toggle_hide",
                isRememberEnabled = true,
                staticryptConfig = {"staticryptEncryptedMsgUniqueVariableName":"4551724d945fd95a9ccc319badc0345d73e6c9f2c1e66cdaa5642362c97e7eeff9644b7d7843b1c0385da7dd7a01a4a06fd5ae97e1f1443182f33e18c072f25d43cfd33380811ac1baa07ac62454a5c515ffd8023b0168e306c1143ee3717c6599f19546de453c66303ecbaf109364a48b623b4c0ec8f66db17be8def6c37899b9b56dd04716e6bb0ba8d89bb4774c24760b12104def292243d78538a04ae3ccc2445228770acc0d0b370c223d338429701d9500e46ce496213ec07a7d0ea31fd6e391aa6f42722c4521e85f3691b967a4009bb661d36929bc9f886f8f819118218da9fe027ce28a533ac8e06f20bd39c09525895f700452f7a021c0d945c554908e3e18db6a9c2093b162c79ed9db1f19b794751d3aa956d03923c5c3278d6f66a121da71984f75ab2d8c459bf384536858c69a56404c74f43fda5dcca9d82f3c18db5924c770e52119ec760864800c7f5ff1d81b6c9f80da302dd0e95031ba1a3939e9b2236ee0905283e6bad2894709a8187ac03cd2a80388e9a5ae160f61706cdab955c852e7bf27f6f2d22adc1764930278e4cf2f6b5e1acd2b890d9e21d7908b7ed11b550b5f3984c1187a75ee99e37defb5d79220b23ffc65c4224a6f247e2deaef92afff45be663f878ea17f85486c237cf5e77c034bed7267e8d701c0c2b130f154f5c134c063e70fe6cccee122d6d453a045cc4ee8bc44ab992789221117b4aed151422f3c65897a55f5702e543f77f3f41600c8f87a38691ee92568df76f73eddc35582a94c82efec14ce425a53622e55fc0528fd53c4ad1eb91cde5b9844389d279ccef3f63653540e9855ec48a1dcc189c070b6f035ca0c8b6a54b2a450926a7ea94d0aaa214f1f3193be3c7fbea45c8786b94430dda431297894ea6b8138d21b6ffd3730c96fd3e567e14837ea9a181279b48da252cf02cb8a297dedf26f831c37831850c3dae90571276befa19862e1f459b5142d8fe800997ddd72aadac4005d396e9d39767bc37acf3c735802438f55b310e236fcfb5b04e77e0a1f8c186329a52b897b849f4aab9a6ef903a2f94b0785cf5dc5616ded661c3087b9bc4719488409ab17f2985444e7fb28def1ef83b549667faa7ff7e2d38f2ffd5c5922c3263a2a30e7278687109480b6c1017f05d2607155b19301da7b7e8693b02c81fd4d9ecd64b1a3f4319aabcb321ab05b7b50ad3e6169f93736ec9d8f601ad1bdfdcc6a4aafe44e89dffd2fa6c3c81bc1098e59febd2af8dbf42eca24901cfb71970faec577eaffe14c12d2bda968e15de29c5e5c511a0b4ead3abac3755db352f58385e368908b56d42b7c00e03586abe43f7fe02c793923df5dc0449f44fad7a9007d6598b0e58b6982dd71e9941abe9f96a8f6fcb6e60c19dfa17d581292e2f0526d490e96052a724f67c461fb2e54fdd6723599ec53d3d7b5fa323772a586f5a0b6ed21f2d8d8f17eceee4ff05e729f2c4220d93b36f4daf7eb5d103714ced4c20d89e7cd7677427c76b348a92d8cd5dc415f744d44debb4554c379e7932fd253aa7cd7c0946587eca959567a0dbbf66a96bd3b889c782100194c669202e633c96764747a3939763100df0b92cbf36dc98381bc7d8acdd144691f951791114a99dc0e4a4c0f5b6fe1903ea12359a313344e91bcc1a54d8a53636dc5b78c250d419c7367bb62c1748e23948bdcdac65820da4a3d8cd1d6cae7ce54071b7addc42f81017fcfaa3afa977263464f76bf1e795fc7e9bda5fb89111fd2207a2bc7152a08af50cad5fa737ebba533e0bf7e9a678b43c19ee1239505bb7da1450d992b575d99c87f8086ea1efc0abe1b32c6ee7528705c30ae110ebeda7e819d3460d78f65c9676acb0d81b11273aadee8846edff4ac14f562fec84914a2f198ae7ebe9272fcd74dcc9c8a368165bbf22398b3d934b849a6acc8ce694ea72c34b431e25020d8ce2430500d5de117e5826c28824677a2eb4348f6696ef3e3cdfe2aac4835b1fa2dedf5e7c9107e38a8edb14cceceeb3bb66614c88eabdccef618d2b9dec2e244f9ac97b93e51a00eb045995f7d3cb7bb4cad049f71828da8f38045f8315c3ecff62e6ee5ef1816d8872bc029fe6a9e761c79da53fc9f7b54c74efe89df4fd7ba1f333d9dadb0fdd2b5895761c864426e94f26df24f9a2e011facc9c61e70404c2b8e25b609175d84ad2f55a5ffad29392ce6cdc05509ade8eac94903526b1514e473b0abfa6e185aa5f4b408e7a67b956c226aca03400911d19eb40b178b01fc81c47d2fdbc27c8c86a4dfa5c7847c25a9e419750a315519bdbd17092660100b57c44541b1fb2e3942a84e076585fc80b4dd2c71cf2d0848273800a762bbbbb86cc11bc91937ae7365a2509c849d462abcac7ccc0a6b0fa9eeb54c93906c1106b16f5d24ab55aebcc201342449da27d40618481c8c75be291c201a6a605530108363579ae197b3e4f8367ba60a304ba87e1ad8fd8144ac2f94eae052100fc290c3996caaf5ed4e0ce5ff070356c46f23764d80b9b4ad7b2f54dc2deb4d0cdccae27241be4f3bfa86159f7fa94e8262cd4ef2ca2e88152c40dbd3ee6a7716f5e64bb2817f10bdcf9593daeddaae651e35b4963ff21b16c40f0c32528fd5e881689e6ddc3e5b31994968b8fc716949d38abd2c70f4d568e00939afb376f65dc850980635521e4b7c7397117e0ec2a2ff8b14d2b5f38227c80fe4c119c2f1caa2d089e4370c521f1ba38c994afd0f3c8d77d356ece9f6fe683550e7b903d181671a083ff4dd5f3123f292f11a54751619599e1746cd12a23165947e3d969026dc594fa2b87f3b09188b6b6534d99b52249387e7bf80f0dca97ee80c72a6930b85bc8e73c8af4d9fb4a75487805677a240b8ffd3130e7843e2de61d146e66e2ba8bf8237a6c3537f0d29e5f91e92070be437861075a9ec8081d6b6ab4df9773fc350cd5386d170ccbbf8bdf8d125117769e415ff3f53ab80b4538003031af829d20044b50b46d2c9f247f365d03a2f886890a9f8d7657056b13a70476009fa1398e72b7063d1fd60b10c12d51731efdb73a36b574de8c3dfab60f58ce8dec104a1806aa206692d517a7d7468d0dda8bc1aa1c701ac1a7818850c89be82178592e920b20bd70c8d5a2e6f3bb46f706521187493634cff0afaad6a78ef249e812d40581664c2e06c28a08e29a5214815db709c04295a3168c009db14152310672acaeb4ec8f8b1d757096c9b041ddc00fd91a52f00709cc61219fc6441b28120183e3f3c0357ae4c7deca63ccee69fe3771d903569e97b54fd4a9da51dcdc9df54ae486c94d80cd7c98055c98eaed762089bb7c25350ee5bf5105f8ba23319960f03efc501c11364a3a38ee52a4f641def0764ec7a271bf5ca957f72558893a1598da4769ac87d1b17e392276bf5fd5b54c5e9987655828a0f1d0ed1f5fac48a865f4415e4340015ac79ef6823637e5883d00ee07f48a8a9c24a4acf1640375b7f533634bd004a06a3b8c5a8aac30aab16791e54bbb6d6586a46ab6d0996bccdfc6bba713cade62295dc2254af686eaab5511809787773b186545c5849e856b61233b4ca497e18cd4546ae24b7555e37fa9714ce52cc840095889589f5b205babbc135ad8489a1147ad7075f3816f3722243f74812f654b36b2eae1d03ebb83ab21f2cfcf4152474d7c65acd59ff4517f3661f0681878abb58bb4bfab621038da800fa691c634b1481f7e58e36bbfdc772de513fafdb9a433ae41927bd7bb4d237c605b2328e8b44f0a231cb73e868a71d38997aaceadae56a9922a8a0a1cc66d58138b68284c9592fd48021d7ea1747f243921b50454bbb5463e337cf3b8df79becef8a70642ea796564f385a5ba48762dc8467cfe9c6f9527b8e82db0c21f9a650972a5f4599930d5300d1282ee75bf7423b7111e51280e4f6c42698aabb04a58f616c399d7a2902038b8f7f9403272acf59a5b7c76aae9056fab7a40d7018cb7113ae52c7cca837e6edd41dbbea1d951fb95365d7e57af731d30c8a3a2de84e5057418c9dc760990fc10c5ccc2a48fb4c5994e3ada0c9f70458193f8150ebe1d6150b7403bddd124e16aaf78b7bb3eedc393f028c3052be8643d9b74d827d0a070b6ffd0623d48e31202676f325a11e2bb154bd18fc4230b70e8bcc79bd23fb681f01959aeba4f30bf7ccd28c98dd95f66511e2c1e0df11a3b6d208e85cbaf10639d533728131db10e22b7b2d468dab114f259c34cd97553f6aa2ef61abeda82636187903cc9879df37606b646579838aa796e793452e7791c5a853c5f92ce29eb1ce0e12eefe275014d9ff213eb58706af5ba2779a1585c823d7af1b7793e73f5d277ad98ee5151718a18087998d20939b8676a92c93a5a0b0f5918ea7aafa833c2e623af94f12425695591084d7e9e37791b8e55bfc45ef231b58fb62e9681813974684dfd41fa055ac318f3b4b7a44285081c91f26772a3050f6f649b8ef6ddc22f4305e88acf6adc78fa5aecb051db70f8658e64605f7a437c2125ee931bb53d02e74fd372c6920345392d8614475377b56cbdb2d0c79f8b1eb9ec9c6e2a36689e281018895e73827f465a8e09ef2720172f22be8c161527052e46a29b5d38e088a777c8e9fcb59faf9d71421ed7ce5417cf1af5a21b228556fdfc3ffefa0c6df5cd61f012505b24648233df1138fbc3ab7de5bff2b228def42de4746e2ebfdba735821a6d48cdbe42de9e2621ce440a52bf6f3fa5b155d8663a36283ca88ec7d2a66085f6f616f3d4b6bcfbd432e2a8916bd62920285fb88f9fff377c6e7493fd27f197caa9c21af07e64d75a4857bb3ac6de47eede96893fc928a0ef7b0f8c2d53fdcdb86ed00edad75c1e43c7f0c67f278857af7bf2d274e174253bcab1f6a70c5b2e60d6cfd5cfaf24084e337ca233991b3c055e42892be31355d9bc87ab9cf0b38f97d84a65828a1eca5db2af39c3d7ef4f09ffd6aa03dffd74147d81fa329fae0a0bb1c38e03a8b03a816df25761479cf6ea807552331e13c677e54ac515c3b41b5fbef6e1e165664a4a78488d67f0ed334aa46f295c37d99ba51ea8d7ff4cdfa10e9f805c08aac0f92c1cde77037a728aa7d4a9ca9f9e62e271c53bad19b322894e560dd57e2165e3e58a990c4731d7bad459d5c6ee3435673d06451c8bea70f275bbd455aca8c6719c9d5e799ef8f90feb1a0f310276027e9cc84104ec6290fcc0ba5c9ae6513fb7ee2aebb93ab56a7027e331de30d5b9f7a6414826918e21bdfbc4f73cf876eb7e523090936a96f9e2ce153d60d1da7600a71e074ff46f4de23b10a1ff403e448a2d90f7cab54ba5ee18c25f60d06a01210f38c6b1318bbe3f8a89bf7af24e21aa9ee5ee649739884f48e8be6b9b7819f7014be1101c4ae99c654509c90ad2b5a49d2a5c4f125e501c436a6cc60c15dceaebe91be1095b03512b85516d2da043736e1f01e7dbfa23b6297a49d8e511b8fb7b7db1f3ac8931d70c8462f8a1fb8c85b21297e77a8b93266080fab05cf03b67260cd13234d3a3df7e5dd69e124ebe144abc91f557109264cb04049af8405fb11dbbeaaa81ea08fd29523861285240227aaefafadc175f607077bb76b0f9aa067c99253fd77cd605b9a72df0c3a3d63924ef36fd504d45ab4cffab53401852a7d032960a7c31d655915a91058affbfd267470c869d8955af7985c56f59f7f83f469cd2a53310f3eb3e5b1b8652df020e225ccc167eb3ed78d097e76102af5f7512714061f0914bbc3b899389ac9499079efde48ec0ab5431b0d9d1c5c02b707d81a9f90ad6494c3a292263f2d46c7f5c6e16748d9107bc8e8a6bdcff7ebc37f98fe320284d3650248e2afd0abb061ea059710c0fe80f9e2934a4789c81b57c7695ece2f1796a8e6034b9a3bcb5871986289a38211b5c4e6b016c25b18c7564dd3b36777d3863ed5cab5e3ed23f0b41434052d22fbaab2bf5b2b60bb694f5f40bbb9f1b6652d9addabbc5bf915f573bf2dbd509dbd0f60d40761b5d7fe08db3215adcaf98fb67d0273e97fc7165d608633cdaad23c9f7630301bdb8fbaf429a81baf7cf480f2e78e50717b86e32ea889f201bfbd2d6d8af9bf2adef6bc1c878ad964d47a718a041c8ec2de13f48fc9246713cda4f7720ae590c365a6e2a9ddf8c9bdc5f595e466db8ab532f398febb52d10dfe521f04a0da38977090b73b92076dce01379e0a7b8c5a3bce085b594740d2c799d5d2ce5c300b658646c0b03036c4b173fa6782948826968719752f4240fdc0c98b2734aa7f8aa4178063438e3a1a6471ffbb26ecd2d563eb9392e9635d899ded8220ade23dc1188c72953b2982ac10a6abd82856bfbab328f8d3e592d2f17fae75f7d8dc831c1df4dad9a6ea408b1b96736c75f85a5fa95c0b09233298ca6866b78e9a3623e8c1ca59bdde094e72612c79958ecc325850a6a561f08e407c8a32f4677781ace33afdda358b7c599b491847e63498ef14e5b2b6446853492f8718d2466c690e0dc03fe8cd0e28d55b1a22e04a0fd858b943911c51f01afc537ef491d2680675743b8eb462f18b55e95637a016d85e1cfb0dd1df065393322deb4426e72c23ee17ee586cb7318d1efa9430e78164785713a368138b4e3a6645bb513e84520d6dc3e984ffbacff16a004a3d106a6480d0b7c2284f68a7656d7337c679c80a82a434f919efe9f31a5f98da1c82a72d94eb17d4fdc84c5339ec2de43bfaf99b253df19fb11ada6f500f4601519af5cd2ddf2670d0bca6d0ba7a59726648c3f9869c9e5224b1ff23b2d332dbaffbe992c0a5e26acb5713e4fadf66911973a8e9424ff07dcf25a6b617e15427414f3646fb5203ec98e3ba761d146b10f84d962b75e2c5fc73a8ec69d68edb219eabe89bdcac62a8fbf69291c6939daf8234adc26380c07e99605dd7e2c8fea7db441424147850576f30ed49337086c0d867a2f455435aee18926c7d22c24ff1bc6663b8a5d74cf3115ed294397a087cf975d60bcf96981d353e3c7a8e94aa7676c602fcab39bcf39647a6d10d54c8934360ea7cc433331f7b54d8bc861159ae6281145b6a90bcea787044593b2f4cd9b8ef87c58db5c4898c34771b671b8a9615b26587edf56d8bd9c8eb17a441a00176efcee7c87089dee4e90d835ffc3e2a81b41e93b95853d9fd39967d503d8c380439db9baf4c48d612925ddfb33a549a6e8877ed7c3edd390ac274fa3958ba279e57313b0a004ae6f3f868958895ed7206cbd20dc5503a07721ec8007f46b3db52eb9d3ef8ac53eeee3b748d55214d6dfb5109fdac27d8bdf8060ca473283e0e6ab051f0b710194bbf517465e66daef5d3cb8fb97d630ebb0a594314ee087c66fc525417b53394a91987843760e159d5abda4f7f256361b2c70cae562c224608e5117354421f14b5a8b9cd0ab3b5e2d1a416498d9a1a0690f7c72fd8272439060939bfb7d68ff52bac7976b18674ce14c10751063699b5677bb8ec3245128f23e250bba1e36f03605a447bfd9d0b1aa58f47f941f00e30780117d28ed5b8035c461bed815aa900e7fe1cfb7cc1a05bab4719a75f57112246c9e1d176724a965051200b6010f9907281b2e0feb53286eb05cd386035581bdc47ed06c92aeeb61e27c2b20c116cb9c40f4bc49d78647346ea741cb43743fb1e15c9e45fe4cd24de581a63e28abe1eb3bccb0b9a3dfb59f3f47c2a11dfb1e94a8ec485ebdac1a95219b4f7dceb6708752b3a649d05b759690b136eff7f5607e3f29702e7edaa18764ada7486c6dfdf964773cc9b874342c71875394df73788683dc4fb7e46ae3b2b16a5560efb54438bd74a4cd4244f9e900e2545c2eee95da4436c3f027a796f3050c30c51703c7cafb7836a5068e7a57c868fbc46fdea3b1a237b0798f4cf390849d13a4f4ae0a62a2987c88d9816b3871fedfe1f5b90976d5b11415615ee4ac95a981e01e1c1726c9ca2cec04945faff90018e874e15a6e9fbf62cd65e2df2cc9d2ae5ced6cea50312a03faae599948d45172b63b8f15bdf73d0b2796d7a8dbe0c76054addd253a01e41be9eb4272f1fb581362f81d8e8dc6b77d2dafcccc344885c7e9eafebac7b7892da9d114615498d9e2c62f573621072099775a63c570e546984291dcc65b309d9e3c693a55f80251df49c3226b6fe4f392016dac72daa95cde9990b89b5590c6049edac46f5e586abec61e25616e614ef7ba8960119d3544207729ae4e55d83d53033749650055cda9d22ad61df67b3cf714c7c0d2ba11e61b52b4ccc65215db9aa4b1760c5836b1b07bdbe76f34f60826705cf6f56c40a4088c61516ba8c3f00d5bb4dbcafecc6396bbbd8327cb7bce1adab330293d35b008cf5dfbd1ea3a71607ead1ff9ad651d4f6f2f514be27a37eac92fddb52f31c13487f5327fc6b2a947122c64f727426c0ef3374f9b4df30cd35b51f1e906c8d3311c24952809998279b6f1f972a720e9cdaecbbc08efc9a01cee3d4ca2525aced468d9043f1e3e0f778a937f1bbb173f00fe3b09caea4d371dd18ec9a9d95ede6751f31d21957933b664da10501e9212e435cf59cba454a42df747c7ed33089d443d8d7e137bcafc5764aba0ccd693414e92b26f952271a121b8ada547d6112a1f787f452241eb05559cc80e21909091999e9f0d0f02f38d7e9f5b6e0c7bc755e343ab4d3270e12ec4fe18282207ae0b2f3b6f2a311839ec01719beaba8caf307bd999b9b6f17432d7cbf51baebd6648ed59294b4284215d213d26a546b1f4df72cbb8e3d8247e86750cb098ffd289ff98db132a475b0b6494de9270ca81298a9e076e8f1d39d5b8b73a1f8a7cf4b117eca0787dd91584f74fbd49b9300b93fc83b3c22f8021f55fc31bbe98201e715ac836620a5188d81ae2df70637ef77e500a5748138e3b9e3656de44a7cd0cec2e01aba10536cf31fcfc729a4581a3efab322ce0cd99deabcb513d923a3606241c65055eeb1bdb69d9301ca3a27fc6d2540bb5d2ca8133d97495f5cd153ba8623dba2e7081de421443e8b948afa1e2d2a7fb77d6684a5dbc0ba1b6312f772ae4c564d6caf92f05cb85496a776c4672d0139bba936d2e6e4dd39e6f959c6cb2bd1484e8749798a18b3b393e7425341b7367b1151f43af1b60ac1a1d6ae4ce4f788463aa7808232fae8a9c4d3eadd1bbcc85460be4fa7709d0bb7f236962221e9f37981073b3eefff1c98952f601d2c12d41f4aa511a0d9f7210207f72e3da4ea12ec6268425ceb1b104fe59475dd3e69a0f8564a06797c3564154fe260bfe828b25b8258649e2504437a76724e80bb5279624cb65a30ffbac8840bcae0cc57f97587fcbd099fb653d3acc9b9ce04cf1233181db8bfaca96a623b65c20e723305e11e0d576586153f1eae668a3c9ee6641725ad6e367f5f38f396fd18956f09cefb9b465749c162128b27ee946a43494eb0767fbcd4e2c2f97d1215db5015bc16ae7855809ae829577a167bbca07aaea30d9b548dea6ff0651a5bc33536bde514b491becbd637060011151798080627cf08a7f3eb7c7c639cad4bbbc330a9809f8089ceaf3ef129129974f567145496e725634ab0753930bbeb5b8c7349e9665c104bd7368d18ce0a3672f99e632db3d8ceeac3c31e16bf3b8d356bb3792f830d30ad13219ecd5d2e25d5e550f8ef18ccb207a6be2d9a83cf5b6b00a9e58e502904728f5064f6864ce4521df4037dfc6aeaa8c11b9892d1934e07b428315a3a9ecb47dcb99a9cc1550edd4fe3bc70ec603d01d0fc76c418c42ff1dd567eaa9d2e6ffe4150419d3bfc7008bbfc9c39506b102daa4f6defe7896802b88160ab7178175a7b525d0765ce7a74cca93344eec7a74af53bc7f3b263582d37b736a9e8a2b9818871c7eb99455ac632d76effa138d63ddc2e2bcb506bb12c8f0e052a44a66eab158be738c5e3869e346ae6b9a05317588106bf63ffc71b0c76a2c79de7650347bd96f12be8dd94211b206c8a00c2c6008218adeb689bbe2642b7e6b926eee79520cc589142c2414c6f6e014dc27ff8eb1a84a88f2616443a6681f762de55c8c5570059b7d77f8bf8723a2ebf8f978b5509bc26854f4a52d0c81c59d1213ef3e916ab227fbcf31dabca4978f4a826ae0a48f4490ce757b6f6176d5d69c8a6349389ef892280ac23251d877f81e01e6b261f6f97a17564864da516524f8858a02297d7238bbc55845b93d90e2339d057701ce4caa704a4472147867a6dcddcd201cbe884b8f2443ee691fa1d06176fae8ae5f796875fdfe94b897877b60f46388d3a474da9b11e60e2d912ecdfcc4997fa486358de252dbb10dba129775b77c27f18caa78221bcd536f1490d5c613c149653c49cdc1c757e766510cbf4389b6728125389b5fda997704a0a5b62524e00a7c65eb807ef49e19e79d3bfd3a33fdd16a18b79a9333fb74634e065562847f94d3ca985c310d1d82ffa4d76565620ecf68c4fec3a2bc20e0ebda207db8db2b6e6c2e1ac2ffa5162b80a51421cf1ba05f8988df06571e062c0d440c9087a34810039fc99c2b1ea8e9b535aa4b26504717081fede23863ebb195b79574a128ca694b071f993dcd02e46b89eb26fbcae16ecc4f8a2c4798e53dd46efb65ce78901f183fee44d128c89350a90e8f5bda444a4b19034940c4176965e61c56a4b888e777290b77dcf58ea6dc36f25fe9ff2479aebf88a02b11c110eb3916f9fff3735b330b24d066b1082965e8fcd3d032b405857c3f4134080d6c1fc0048399704064781f0d073eef9e3079a8f9f77052c6fcb0b93f9bef18b82e99b303471791c2b3c89d236a27e2ffd02e3120b8962aef73ed7e8cc355c992bb18218d0247f35a68f22c08ef32b2d527a585c9307a2798c6249ff2a34de68600b496f8a1fc769e41ad70a3514dd01d7c7f08d8e46efacb0eacea6d601a809798ab5e98e89fe5ddab0ea899773eaea63ddb2a4297c4335855284581dd257018046efa986d83ff3aade577e4a8172d68fbb355d4d99a890a515b46488de3a2f2859d7746b729666d9eab46132a44b9586fba711377b62135a9ee345de3c9891795535cab5c8d91fb4d846b33af140af367105e58d98cede220f9a80d72197b15e77e76d383869f9f3ebf28d43d085dd65fc90e4905adf47be70687aac965bfeaf72d11d61a75c85756a766924543a2f34df3b1d9df2d18d0c69bb75e56dba5efe06c6da6045800b60dde186d119e73e3771affcda30c2af75c9ffe8b42a6aabd469786b21b1b104748c6a61f020337b0ddafd3aceb3950a187c0a024b7390771733dc02bca17bd6ba9dd1f2b2aa6101bda10b7fad06d2c279d247188e99b44ac0d6241dadd0ac49f9f5a0d1c95ca602d56306563ea5ce885b1b8aeffa0b74e4e91a488e955541afecba6e276eaa04605a2d571296e0c1e41ef22be1cbce1a48543404fb5286fa88c1e7a54e543482ac4fdec52ee45100402085e38bf26b4e7d28c1858120252425d572da664d92aa28bd4d5fe2743f5622d78fdae60baf40c218ae8825e7d79867e8e1bd01bd5bb53d416943f51686150cb988b943a1c219882957e5cc403bd5721c9baeb7bc1507991f421d316c3a2e57825260d83126045f6d9aa305daa100ea3e954e054078c010d0092a8a5f2302a148aa040dd011d10e3091bb6d7f6817ba6332866da0168c7fab33eadc28cf7f0ef399e078e1c4a07acbbff01c082153c61b23e8baa975d9e4","isRememberEnabled":true,"rememberDurationInDays":0,"staticryptSaltUniqueVariableName":"5691a91fccdacae8f785b1c5eff52da4"};

            // you can edit these values to customize some of the behavior of StatiCrypt
            const templateConfig = {
                rememberExpirationKey: "staticrypt_expiration",
                rememberPassphraseKey: "staticrypt_passphrase",
                replaceHtmlCallback: null,
                clearLocalStorageCallback: null,
            };

            // init the staticrypt engine
            const staticrypt = staticryptInitiator.init(staticryptConfig, templateConfig);

            // try to automatically decrypt on load if there is a saved password
            window.onload = async function () {
                const { isSuccessful } = await staticrypt.handleDecryptOnLoad();

                // if we didn't decrypt anything on load, show the password prompt. Otherwise the content has already been
                // replaced, no need to do anything
                if (!isSuccessful) {
                    // hide loading screen
                    document.getElementById("staticrypt_loading").classList.add("hidden");
                    document.getElementById("staticrypt_content").classList.remove("hidden");
                    document.getElementById("staticrypt-password").focus();

                    // show the remember me checkbox
                    if (isRememberEnabled) {
                        document.getElementById("staticrypt-remember-label").classList.remove("hidden");
                    }
                }
            };

            // toggle password visibility
            const toggleIcon = document.querySelector(".staticrypt-toggle-password-visibility");
            // these two icons are coming from FontAwesome
            const imgSrcEyeClosed =
                "data:image/svg+xml;base64,PHN2ZyB4bWxucz0iaHR0cDovL3d3dy53My5vcmcvMjAwMC9zdmciIHZpZXdCb3g9IjAgMCA2NDAgNTEyIj48IS0tIUZvbnQgQXdlc29tZSBGcmVlIDYuNS4yIGJ5IEBmb250YXdlc29tZSAtIGh0dHBzOi8vZm9udGF3ZXNvbWUuY29tIExpY2Vuc2UgLSBodHRwczovL2ZvbnRhd2Vzb21lLmNvbS9saWNlbnNlL2ZyZWUgQ29weXJpZ2h0IDIwMjQgRm9udGljb25zLCBJbmMuLS0+PHBhdGggZD0iTTM4LjggNS4xQzI4LjQtMy4xIDEzLjMtMS4yIDUuMSA5LjJTLTEuMiAzNC43IDkuMiA0Mi45bDU5MiA0NjRjMTAuNCA4LjIgMjUuNSA2LjMgMzMuNy00LjFzNi4zLTI1LjUtNC4xLTMzLjdMNTI1LjYgMzg2LjdjMzkuNi00MC42IDY2LjQtODYuMSA3OS45LTExOC40YzMuMy03LjkgMy4zLTE2LjcgMC0yNC42Yy0xNC45LTM1LjctNDYuMi04Ny43LTkzLTEzMS4xQzQ2NS41IDY4LjggNDAwLjggMzIgMzIwIDMyYy02OC4yIDAtMTI1IDI2LjMtMTY5LjMgNjAuOEwzOC44IDUuMXpNMjIzLjEgMTQ5LjVDMjQ4LjYgMTI2LjIgMjgyLjcgMTEyIDMyMCAxMTJjNzkuNSAwIDE0NCA2NC41IDE0NCAxNDRjMCAyNC45LTYuMyA0OC4zLTE3LjQgNjguN0w0MDggMjk0LjVjOC40LTE5LjMgMTAuNi00MS40IDQuOC02My4zYy0xMS4xLTQxLjUtNDcuOC02OS40LTg4LjYtNzEuMWMtNS44LS4yLTkuMiA2LjEtNy40IDExLjdjMi4xIDYuNCAzLjMgMTMuMiAzLjMgMjAuM2MwIDEwLjItMi40IDE5LjgtNi42IDI4LjNsLTkwLjMtNzAuOHpNMzczIDM4OS45Yy0xNi40IDYuNS0zNC4zIDEwLjEtNTMgMTAuMWMtNzkuNSAwLTE0NC02NC41LTE0NC0xNDRjMC02LjkgLjUtMTMuNiAxLjQtMjAuMkw4My4xIDE2MS41QzYwLjMgMTkxLjIgNDQgMjIwLjggMzQuNSAyNDMuN2MtMy4zIDcuOS0zLjMgMTYuNyAwIDI0LjZjMTQuOSAzNS43IDQ2LjIgODcuNyA5MyAxMzEuMUMxNzQuNSA0NDMuMiAyMzkuMiA0ODAgMzIwIDQ4MGM0Ny44IDAgODkuOS0xMi45IDEyNi4yLTMyLjVMMzczIDM4OS45eiIvPjwvc3ZnPg==";
            const imgSrcEyeOpened =
                "data:image/svg+xml;base64,PHN2ZyB4bWxucz0iaHR0cDovL3d3dy53My5vcmcvMjAwMC9zdmciIHZpZXdCb3g9IjAgMCA1NzYgNTEyIj48IS0tIUZvbnQgQXdlc29tZSBGcmVlIDYuNS4yIGJ5IEBmb250YXdlc29tZSAtIGh0dHBzOi8vZm9udGF3ZXNvbWUuY29tIExpY2Vuc2UgLSBodHRwczovL2ZvbnRhd2Vzb21lLmNvbS9saWNlbnNlL2ZyZWUgQ29weXJpZ2h0IDIwMjQgRm9udGljb25zLCBJbmMuLS0+PHBhdGggZD0iTTI4OCAzMmMtODAuOCAwLTE0NS41IDM2LjgtMTkyLjYgODAuNkM0OC42IDE1NiAxNy4zIDIwOCAyLjUgMjQzLjdjLTMuMyA3LjktMy4zIDE2LjcgMCAyNC42QzE3LjMgMzA0IDQ4LjYgMzU2IDk1LjQgMzk5LjRDMTQyLjUgNDQzLjIgMjA3LjIgNDgwIDI4OCA0ODBzMTQ1LjUtMzYuOCAxOTIuNi04MC42YzQ2LjgtNDMuNSA3OC4xLTk1LjQgOTMtMTMxLjFjMy4zLTcuOSAzLjMtMTYuNyAwLTI0LjZjLTE0LjktMzUuNy00Ni4yLTg3LjctOTMtMTMxLjFDNDMzLjUgNjguOCAzNjguOCAzMiAyODggMzJ6TTE0NCAyNTZhMTQ0IDE0NCAwIDEgMSAyODggMCAxNDQgMTQ0IDAgMSAxIC0yODggMHptMTQ0LTY0YzAgMzUuMy0yOC43IDY0LTY0IDY0Yy03LjEgMC0xMy45LTEuMi0yMC4zLTMuM2MtNS41LTEuOC0xMS45IDEuNi0xMS43IDcuNGMuMyA2LjkgMS4zIDEzLjggMy4yIDIwLjdjMTMuNyA1MS4yIDY2LjQgODEuNiAxMTcuNiA2Ny45czgxLjYtNjYuNCA2Ny45LTExNy42Yy0xMS4xLTQxLjUtNDcuOC02OS40LTg4LjYtNzEuMWMtNS44LS4yLTkuMiA2LjEtNy40IDExLjdjMi4xIDYuNCAzLjMgMTMuMiAzLjMgMjAuM3oiLz48L3N2Zz4=";
            toggleIcon.addEventListener("click", function () {
                const passwordInput = document.getElementById("staticrypt-password");
                if (passwordInput.type === "password") {
                    passwordInput.type = "text";
                    toggleIcon.src = imgSrcEyeOpened;
                    toggleIcon.alt = templateToggleAltHide;
                    toggleIcon.title = templateToggleAltHide;
                } else {
                    passwordInput.type = "password";
                    toggleIcon.src = imgSrcEyeClosed;
                    toggleIcon.alt = templateToggleAltShow;
                    toggleIcon.title = templateToggleAltShow;
                }
            });

            // handle password form submission
            document.getElementById("staticrypt-form").addEventListener("submit", async function (e) {
                e.preventDefault();

                const password = document.getElementById("staticrypt-password").value,
                    isRememberChecked = document.getElementById("staticrypt-remember").checked;

                const { isSuccessful } = await staticrypt.handleDecryptionOfPage(password, isRememberChecked);

                if (!isSuccessful) {
                    alert(templateError);
                }
            });
        </script>
    </body>
</html>
