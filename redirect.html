<!DOCTYPE html>
<html class="staticrypt-html">
    <head>
        <meta charset="utf-8" />
        <title>Protected Page</title>
        <meta name="viewport" content="width=device-width, initial-scale=1" />

        <!-- do not cache this page -->
        <meta http-equiv="cache-control" content="max-age=0" />
        <meta http-equiv="cache-control" content="no-cache" />
        <meta http-equiv="expires" content="0" />
        <meta http-equiv="expires" content="Tue, 01 Jan 1980 1:00:00 GMT" />
        <meta http-equiv="pragma" content="no-cache" />

        <style>
            .staticrypt-hr {
                margin-top: 20px;
                margin-bottom: 20px;
                border: 0;
                border-top: 1px solid #eee;
            }

            .staticrypt-page {
                width: 360px;
                padding: 8% 0 0;
                margin: auto;
                box-sizing: border-box;
            }

            .staticrypt-form {
                position: relative;
                z-index: 1;
                background: #ffffff;
                max-width: 360px;
                margin: 0 auto 100px;
                padding: 45px;
                text-align: center;
                box-shadow: 0 0 20px 0 rgba(0, 0, 0, 0.2), 0 5px 5px 0 rgba(0, 0, 0, 0.24);
            }

            .staticrypt-form input[type="password"],
            input[type="text"] {
                background: inherit;
                border: 0;
                box-sizing: border-box; /* This ensures padding is included in the total width */
                font-size: 14px;
                outline: 0;
                padding: 15px 30px 15px 15px; /* Adjust the padding to ensure there is space for the icon */
                width: 100%;
            }

            .staticrypt-password-container {
                position: relative;
                outline: 0;
                background: #f2f2f2;
                width: 100%;
                border: 0;
                margin: 0 0 15px;
                box-sizing: border-box;
            }

            .staticrypt-toggle-password-visibility {
                cursor: pointer;
                height: 20px;
                opacity: 60%;
                padding: 13px;
                position: absolute;
                right: 0;
                top: 50%;
                transform: translateY(-50%);
                width: 20px;
            }

            .staticrypt-form .staticrypt-decrypt-button {
                text-transform: uppercase;
                outline: 0;
                background: #4CAF50;
                width: 100%;
                border: 0;
                padding: 15px;
                color: #ffffff;
                font-size: 14px;
                cursor: pointer;
            }

            .staticrypt-form .staticrypt-decrypt-button:hover,
            .staticrypt-form .staticrypt-decrypt-button:active,
            .staticrypt-form .staticrypt-decrypt-button:focus {
                background: #4CAF50;
                filter: brightness(92%);
            }

            .staticrypt-html {
                height: 100%;
            }

            .staticrypt-body {
                height: 100%;
                margin: 0;
            }

            .staticrypt-content {
                height: 100%;
                margin-bottom: 1em;
                background: #76B852;
                font-family: "Arial", sans-serif;
                -webkit-font-smoothing: antialiased;
                -moz-osx-font-smoothing: grayscale;
            }

            .staticrypt-instructions {
                margin-top: -1em;
                margin-bottom: 1em;
            }

            .staticrypt-title {
                font-size: 1.5em;
            }

            label.staticrypt-remember {
                display: flex;
                align-items: center;
                margin-bottom: 1em;
            }

            .staticrypt-remember input[type="checkbox"] {
                transform: scale(1.5);
                margin-right: 1em;
            }

            .hidden {
                display: none !important;
            }

            .staticrypt-spinner-container {
                height: 100%;
                display: flex;
                align-items: center;
                justify-content: center;
            }

            .staticrypt-spinner {
                display: inline-block;
                width: 2rem;
                height: 2rem;
                vertical-align: text-bottom;
                border: 0.25em solid gray;
                border-right-color: transparent;
                border-radius: 50%;
                -webkit-animation: spinner-border 0.75s linear infinite;
                animation: spinner-border 0.75s linear infinite;
                animation-duration: 0.75s;
                animation-timing-function: linear;
                animation-delay: 0s;
                animation-iteration-count: infinite;
                animation-direction: normal;
                animation-fill-mode: none;
                animation-play-state: running;
                animation-name: spinner-border;
            }

            @keyframes spinner-border {
                100% {
                    transform: rotate(360deg);
                }
            }
        </style>
    </head>

    <body class="staticrypt-body">
        <div id="staticrypt_loading" class="staticrypt-spinner-container">
            <div class="staticrypt-spinner"></div>
        </div>

        <div id="staticrypt_content" class="staticrypt-content hidden">
            <div class="staticrypt-page">
                <div class="staticrypt-form">
                    <div class="staticrypt-instructions">
                        <p class="staticrypt-title">Protected Page</p>
                        <p></p>
                    </div>

                    <hr class="staticrypt-hr" />

                    <form id="staticrypt-form" action="#" method="post">
                        <div class="staticrypt-password-container">
                            <input
                                id="staticrypt-password"
                                type="password"
                                name="password"
                                placeholder="Password"
                                autofocus
                            />

                            <img
                                class="staticrypt-toggle-password-visibility"
                                alt="template_toggle_show"
                                title="template_toggle_show"
                                src="data:image/svg+xml;base64,PHN2ZyB4bWxucz0iaHR0cDovL3d3dy53My5vcmcvMjAwMC9zdmciIHZpZXdCb3g9IjAgMCA2NDAgNTEyIj48IS0tIUZvbnQgQXdlc29tZSBGcmVlIDYuNS4yIGJ5IEBmb250YXdlc29tZSAtIGh0dHBzOi8vZm9udGF3ZXNvbWUuY29tIExpY2Vuc2UgLSBodHRwczovL2ZvbnRhd2Vzb21lLmNvbS9saWNlbnNlL2ZyZWUgQ29weXJpZ2h0IDIwMjQgRm9udGljb25zLCBJbmMuLS0+PHBhdGggZD0iTTM4LjggNS4xQzI4LjQtMy4xIDEzLjMtMS4yIDUuMSA5LjJTLTEuMiAzNC43IDkuMiA0Mi45bDU5MiA0NjRjMTAuNCA4LjIgMjUuNSA2LjMgMzMuNy00LjFzNi4zLTI1LjUtNC4xLTMzLjdMNTI1LjYgMzg2LjdjMzkuNi00MC42IDY2LjQtODYuMSA3OS45LTExOC40YzMuMy03LjkgMy4zLTE2LjcgMC0yNC42Yy0xNC45LTM1LjctNDYuMi04Ny43LTkzLTEzMS4xQzQ2NS41IDY4LjggNDAwLjggMzIgMzIwIDMyYy02OC4yIDAtMTI1IDI2LjMtMTY5LjMgNjAuOEwzOC44IDUuMXpNMjIzLjEgMTQ5LjVDMjQ4LjYgMTI2LjIgMjgyLjcgMTEyIDMyMCAxMTJjNzkuNSAwIDE0NCA2NC41IDE0NCAxNDRjMCAyNC45LTYuMyA0OC4zLTE3LjQgNjguN0w0MDggMjk0LjVjOC40LTE5LjMgMTAuNi00MS40IDQuOC02My4zYy0xMS4xLTQxLjUtNDcuOC02OS40LTg4LjYtNzEuMWMtNS44LS4yLTkuMiA2LjEtNy40IDExLjdjMi4xIDYuNCAzLjMgMTMuMiAzLjMgMjAuM2MwIDEwLjItMi40IDE5LjgtNi42IDI4LjNsLTkwLjMtNzAuOHpNMzczIDM4OS45Yy0xNi40IDYuNS0zNC4zIDEwLjEtNTMgMTAuMWMtNzkuNSAwLTE0NC02NC41LTE0NC0xNDRjMC02LjkgLjUtMTMuNiAxLjQtMjAuMkw4My4xIDE2MS41QzYwLjMgMTkxLjIgNDQgMjIwLjggMzQuNSAyNDMuN2MtMy4zIDcuOS0zLjMgMTYuNyAwIDI0LjZjMTQuOSAzNS43IDQ2LjIgODcuNyA5MyAxMzEuMUMxNzQuNSA0NDMuMiAyMzkuMiA0ODAgMzIwIDQ4MGM0Ny44IDAgODkuOS0xMi45IDEyNi4yLTMyLjVMMzczIDM4OS45eiIvPjwvc3ZnPg=="
                            />
                        </div>

                        <label id="staticrypt-remember-label" class="staticrypt-remember hidden">
                            <input id="staticrypt-remember" type="checkbox" name="remember" />
                            Remember me
                        </label>

                        <input type="submit" class="staticrypt-decrypt-button" value="DECRYPT" />
                    </form>
                </div>
            </div>
        </div>

        <script>
            // these variables will be filled when generating the file - the template format is 'variable_name'
            const staticryptInitiator = 
            ((function(){
  const exports = {};
  const cryptoEngine = ((function(){
  const exports = {};
  const { subtle } = crypto;

const IV_BITS = 16 * 8;
const HEX_BITS = 4;
const ENCRYPTION_ALGO = "AES-CBC";

/**
 * Translates between utf8 encoded hexadecimal strings
 * and Uint8Array bytes.
 */
const HexEncoder = {
    /**
     * hex string -> bytes
     * @param {string} hexString
     * @returns {Uint8Array}
     */
    parse: function (hexString) {
        if (hexString.length % 2 !== 0) throw "Invalid hexString";
        const arrayBuffer = new Uint8Array(hexString.length / 2);

        for (let i = 0; i < hexString.length; i += 2) {
            const byteValue = parseInt(hexString.substring(i, i + 2), 16);
            if (isNaN(byteValue)) {
                throw "Invalid hexString";
            }
            arrayBuffer[i / 2] = byteValue;
        }
        return arrayBuffer;
    },

    /**
     * bytes -> hex string
     * @param {Uint8Array} bytes
     * @returns {string}
     */
    stringify: function (bytes) {
        const hexBytes = [];

        for (let i = 0; i < bytes.length; ++i) {
            let byteString = bytes[i].toString(16);
            if (byteString.length < 2) {
                byteString = "0" + byteString;
            }
            hexBytes.push(byteString);
        }
        return hexBytes.join("");
    },
};

/**
 * Translates between utf8 strings and Uint8Array bytes.
 */
const UTF8Encoder = {
    parse: function (str) {
        return new TextEncoder().encode(str);
    },

    stringify: function (bytes) {
        return new TextDecoder().decode(bytes);
    },
};

/**
 * Salt and encrypt a msg with a password.
 */
async function encrypt(msg, hashedPassword) {
    // Must be 16 bytes, unpredictable, and preferably cryptographically random. However, it need not be secret.
    // https://developer.mozilla.org/en-US/docs/Web/API/SubtleCrypto/encrypt#parameters
    const iv = crypto.getRandomValues(new Uint8Array(IV_BITS / 8));

    const key = await subtle.importKey("raw", HexEncoder.parse(hashedPassword), ENCRYPTION_ALGO, false, ["encrypt"]);

    const encrypted = await subtle.encrypt(
        {
            name: ENCRYPTION_ALGO,
            iv: iv,
        },
        key,
        UTF8Encoder.parse(msg)
    );

    // iv will be 32 hex characters, we prepend it to the ciphertext for use in decryption
    return HexEncoder.stringify(iv) + HexEncoder.stringify(new Uint8Array(encrypted));
}
exports.encrypt = encrypt;

/**
 * Decrypt a salted msg using a password.
 *
 * @param {string} encryptedMsg
 * @param {string} hashedPassword
 * @returns {Promise<string>}
 */
async function decrypt(encryptedMsg, hashedPassword) {
    const ivLength = IV_BITS / HEX_BITS;
    const iv = HexEncoder.parse(encryptedMsg.substring(0, ivLength));
    const encrypted = encryptedMsg.substring(ivLength);

    const key = await subtle.importKey("raw", HexEncoder.parse(hashedPassword), ENCRYPTION_ALGO, false, ["decrypt"]);

    const outBuffer = await subtle.decrypt(
        {
            name: ENCRYPTION_ALGO,
            iv: iv,
        },
        key,
        HexEncoder.parse(encrypted)
    );

    return UTF8Encoder.stringify(new Uint8Array(outBuffer));
}
exports.decrypt = decrypt;

/**
 * Salt and hash the password so it can be stored in localStorage without opening a password reuse vulnerability.
 *
 * @param {string} password
 * @param {string} salt
 * @returns {Promise<string>}
 */
async function hashPassword(password, salt) {
    // we hash the password in multiple steps, each adding more iterations. This is because we used to allow less
    // iterations, so for backward compatibility reasons, we need to support going from that to more iterations.
    let hashedPassword = await hashLegacyRound(password, salt);

    hashedPassword = await hashSecondRound(hashedPassword, salt);

    return hashThirdRound(hashedPassword, salt);
}
exports.hashPassword = hashPassword;

/**
 * This hashes the password with 1k iterations. This is a low number, we need this function to support backwards
 * compatibility.
 *
 * @param {string} password
 * @param {string} salt
 * @returns {Promise<string>}
 */
function hashLegacyRound(password, salt) {
    return pbkdf2(password, salt, 1000, "SHA-1");
}
exports.hashLegacyRound = hashLegacyRound;

/**
 * Add a second round of iterations. This is because we used to use 1k, so for backwards compatibility with
 * remember-me/autodecrypt links, we need to support going from that to more iterations.
 *
 * @param hashedPassword
 * @param salt
 * @returns {Promise<string>}
 */
function hashSecondRound(hashedPassword, salt) {
    return pbkdf2(hashedPassword, salt, 14000, "SHA-256");
}
exports.hashSecondRound = hashSecondRound;

/**
 * Add a third round of iterations to bring total number to 600k. This is because we used to use 1k, then 15k, so for
 * backwards compatibility with remember-me/autodecrypt links, we need to support going from that to more iterations.
 *
 * @param hashedPassword
 * @param salt
 * @returns {Promise<string>}
 */
function hashThirdRound(hashedPassword, salt) {
    return pbkdf2(hashedPassword, salt, 585000, "SHA-256");
}
exports.hashThirdRound = hashThirdRound;

/**
 * Salt and hash the password so it can be stored in localStorage without opening a password reuse vulnerability.
 *
 * @param {string} password
 * @param {string} salt
 * @param {int} iterations
 * @param {string} hashAlgorithm
 * @returns {Promise<string>}
 */
async function pbkdf2(password, salt, iterations, hashAlgorithm) {
    const key = await subtle.importKey("raw", UTF8Encoder.parse(password), "PBKDF2", false, ["deriveBits"]);

    const keyBytes = await subtle.deriveBits(
        {
            name: "PBKDF2",
            hash: hashAlgorithm,
            iterations,
            salt: UTF8Encoder.parse(salt),
        },
        key,
        256
    );

    return HexEncoder.stringify(new Uint8Array(keyBytes));
}

function generateRandomSalt() {
    const bytes = crypto.getRandomValues(new Uint8Array(128 / 8));

    return HexEncoder.stringify(new Uint8Array(bytes));
}
exports.generateRandomSalt = generateRandomSalt;

async function signMessage(hashedPassword, message) {
    const key = await subtle.importKey(
        "raw",
        HexEncoder.parse(hashedPassword),
        {
            name: "HMAC",
            hash: "SHA-256",
        },
        false,
        ["sign"]
    );
    const signature = await subtle.sign("HMAC", key, UTF8Encoder.parse(message));

    return HexEncoder.stringify(new Uint8Array(signature));
}
exports.signMessage = signMessage;

function getRandomAlphanum() {
    const possibleCharacters = "abcdefghijklmnopqrstuvwxyzABCDEFGHIJKLMNOPQRSTUVWXYZ0123456789";

    let byteArray;
    let parsedInt;

    // Keep generating new random bytes until we get a value that falls
    // within a range that can be evenly divided by possibleCharacters.length
    do {
        byteArray = crypto.getRandomValues(new Uint8Array(1));
        // extract the lowest byte to get an int from 0 to 255 (probably unnecessary, since we're only generating 1 byte)
        parsedInt = byteArray[0] & 0xff;
    } while (parsedInt >= 256 - (256 % possibleCharacters.length));

    // Take the modulo of the parsed integer to get a random number between 0 and totalLength - 1
    const randomIndex = parsedInt % possibleCharacters.length;

    return possibleCharacters[randomIndex];
}

/**
 * Generate a random string of a given length.
 *
 * @param {int} length
 * @returns {string}
 */
function generateRandomString(length) {
    let randomString = "";

    for (let i = 0; i < length; i++) {
        randomString += getRandomAlphanum();
    }

    return randomString;
}
exports.generateRandomString = generateRandomString;

  return exports;
})());
const codec = ((function(){
  const exports = {};
  /**
 * Initialize the codec with the provided cryptoEngine - this return functions to encode and decode messages.
 *
 * @param cryptoEngine - the engine to use for encryption / decryption
 */
function init(cryptoEngine) {
    const exports = {};

    /**
     * Top-level function for encoding a message.
     * Includes password hashing, encryption, and signing.
     *
     * @param {string} msg
     * @param {string} password
     * @param {string} salt
     *
     * @returns {string} The encoded text
     */
    async function encode(msg, password, salt) {
        const hashedPassword = await cryptoEngine.hashPassword(password, salt);

        const encrypted = await cryptoEngine.encrypt(msg, hashedPassword);

        // we use the hashed password in the HMAC because this is effectively what will be used a password (so we can store
        // it in localStorage safely, we don't use the clear text password)
        const hmac = await cryptoEngine.signMessage(hashedPassword, encrypted);

        return hmac + encrypted;
    }
    exports.encode = encode;

    /**
     * Encode using a password that has already been hashed. This is useful to encode multiple messages in a row, that way
     * we don't need to hash the password multiple times.
     *
     * @param {string} msg
     * @param {string} hashedPassword
     *
     * @returns {string} The encoded text
     */
    async function encodeWithHashedPassword(msg, hashedPassword) {
        const encrypted = await cryptoEngine.encrypt(msg, hashedPassword);

        // we use the hashed password in the HMAC because this is effectively what will be used a password (so we can store
        // it in localStorage safely, we don't use the clear text password)
        const hmac = await cryptoEngine.signMessage(hashedPassword, encrypted);

        return hmac + encrypted;
    }
    exports.encodeWithHashedPassword = encodeWithHashedPassword;

    /**
     * Top-level function for decoding a message.
     * Includes signature check and decryption.
     *
     * @param {string} signedMsg
     * @param {string} hashedPassword
     * @param {string} salt
     * @param {int} backwardCompatibleAttempt
     * @param {string} originalPassword
     *
     * @returns {Object} {success: true, decoded: string} | {success: false, message: string}
     */
    async function decode(signedMsg, hashedPassword, salt, backwardCompatibleAttempt = 0, originalPassword = "") {
        const encryptedHMAC = signedMsg.substring(0, 64);
        const encryptedMsg = signedMsg.substring(64);
        const decryptedHMAC = await cryptoEngine.signMessage(hashedPassword, encryptedMsg);

        if (decryptedHMAC !== encryptedHMAC) {
            // we have been raising the number of iterations in the hashing algorithm multiple times, so to support the old
            // remember-me/autodecrypt links we need to try bringing the old hashes up to speed.
            originalPassword = originalPassword || hashedPassword;
            if (backwardCompatibleAttempt === 0) {
                const updatedHashedPassword = await cryptoEngine.hashThirdRound(originalPassword, salt);

                return decode(signedMsg, updatedHashedPassword, salt, backwardCompatibleAttempt + 1, originalPassword);
            }
            if (backwardCompatibleAttempt === 1) {
                let updatedHashedPassword = await cryptoEngine.hashSecondRound(originalPassword, salt);
                updatedHashedPassword = await cryptoEngine.hashThirdRound(updatedHashedPassword, salt);

                return decode(signedMsg, updatedHashedPassword, salt, backwardCompatibleAttempt + 1, originalPassword);
            }

            return { success: false, message: "Signature mismatch" };
        }

        return {
            success: true,
            decoded: await cryptoEngine.decrypt(encryptedMsg, hashedPassword),
        };
    }
    exports.decode = decode;

    return exports;
}
exports.init = init;

  return exports;
})());
const decode = codec.init(cryptoEngine).decode;

/**
 * Initialize the staticrypt module, that exposes functions callbable by the password_template.
 *
 * @param {{
 *  staticryptEncryptedMsgUniqueVariableName: string,
 *  isRememberEnabled: boolean,
 *  rememberDurationInDays: number,
 *  staticryptSaltUniqueVariableName: string,
 * }} staticryptConfig - object of data that is stored on the password_template at encryption time.
 *
 * @param {{
 *  rememberExpirationKey: string,
 *  rememberPassphraseKey: string,
 *  replaceHtmlCallback: function,
 *  clearLocalStorageCallback: function,
 * }} templateConfig - object of data that can be configured by a custom password_template.
 */
function init(staticryptConfig, templateConfig) {
    const exports = {};

    /**
     * Decrypt our encrypted page, replace the whole HTML.
     *
     * @param {string} hashedPassword
     * @returns {Promise<boolean>}
     */
    async function decryptAndReplaceHtml(hashedPassword) {
        const { staticryptEncryptedMsgUniqueVariableName, staticryptSaltUniqueVariableName } = staticryptConfig;
        const { replaceHtmlCallback } = templateConfig;

        const result = await decode(
            staticryptEncryptedMsgUniqueVariableName,
            hashedPassword,
            staticryptSaltUniqueVariableName
        );
        if (!result.success) {
            return false;
        }
        const plainHTML = result.decoded;

        // if the user configured a callback call it, otherwise just replace the whole HTML
        if (typeof replaceHtmlCallback === "function") {
            replaceHtmlCallback(plainHTML);
        } else {
            document.write(plainHTML);
            document.close();
        }

        return true;
    }

    /**
     * Attempt to decrypt the page and replace the whole HTML.
     *
     * @param {string} password
     * @param {boolean} isRememberChecked
     *
     * @returns {Promise<{isSuccessful: boolean, hashedPassword?: string}>} - we return an object, so that if we want to
     *   expose more information in the future we can do it without breaking the password_template
     */
    async function handleDecryptionOfPage(password, isRememberChecked) {
        const { staticryptSaltUniqueVariableName } = staticryptConfig;

        // decrypt and replace the whole page
        const hashedPassword = await cryptoEngine.hashPassword(password, staticryptSaltUniqueVariableName);
        return handleDecryptionOfPageFromHash(hashedPassword, isRememberChecked);
    }
    exports.handleDecryptionOfPage = handleDecryptionOfPage;

    async function handleDecryptionOfPageFromHash(hashedPassword, isRememberChecked) {
        const { isRememberEnabled, rememberDurationInDays } = staticryptConfig;
        const { rememberExpirationKey, rememberPassphraseKey } = templateConfig;

        const isDecryptionSuccessful = await decryptAndReplaceHtml(hashedPassword);

        if (!isDecryptionSuccessful) {
            return {
                isSuccessful: false,
                hashedPassword,
            };
        }

        // remember the hashedPassword and set its expiration if necessary
        if (isRememberEnabled && isRememberChecked) {
            window.localStorage.setItem(rememberPassphraseKey, hashedPassword);

            // set the expiration if the duration isn't 0 (meaning no expiration)
            if (rememberDurationInDays > 0) {
                window.localStorage.setItem(
                    rememberExpirationKey,
                    (new Date().getTime() + rememberDurationInDays * 24 * 60 * 60 * 1000).toString()
                );
            }
        }

        return {
            isSuccessful: true,
            hashedPassword,
        };
    }
    exports.handleDecryptionOfPageFromHash = handleDecryptionOfPageFromHash;

    /**
     * Clear localstorage from staticrypt related values
     */
    function clearLocalStorage() {
        const { clearLocalStorageCallback, rememberExpirationKey, rememberPassphraseKey } = templateConfig;

        if (typeof clearLocalStorageCallback === "function") {
            clearLocalStorageCallback();
        } else {
            localStorage.removeItem(rememberPassphraseKey);
            localStorage.removeItem(rememberExpirationKey);
        }
    }

    async function handleDecryptOnLoad() {
        let isSuccessful = await decryptOnLoadFromUrl();

        if (!isSuccessful) {
            isSuccessful = await decryptOnLoadFromRememberMe();
        }

        return { isSuccessful };
    }
    exports.handleDecryptOnLoad = handleDecryptOnLoad;

    /**
     * Clear storage if we are logging out
     *
     * @returns {boolean} - whether we logged out
     */
    function logoutIfNeeded() {
        const logoutKey = "staticrypt_logout";

        // handle logout through query param
        const queryParams = new URLSearchParams(window.location.search);
        if (queryParams.has(logoutKey)) {
            clearLocalStorage();
            return true;
        }

        // handle logout through URL fragment
        const hash = window.location.hash.substring(1);
        if (hash.includes(logoutKey)) {
            clearLocalStorage();
            return true;
        }

        return false;
    }

    /**
     * To be called on load: check if we want to try to decrypt and replace the HTML with the decrypted content, and
     * try to do it if needed.
     *
     * @returns {Promise<boolean>} true if we derypted and replaced the whole page, false otherwise
     */
    async function decryptOnLoadFromRememberMe() {
        const { rememberDurationInDays } = staticryptConfig;
        const { rememberExpirationKey, rememberPassphraseKey } = templateConfig;

        // if we are login out, terminate
        if (logoutIfNeeded()) {
            return false;
        }

        // if there is expiration configured, check if we're not beyond the expiration
        if (rememberDurationInDays && rememberDurationInDays > 0) {
            const expiration = localStorage.getItem(rememberExpirationKey),
                isExpired = expiration && new Date().getTime() > parseInt(expiration);

            if (isExpired) {
                clearLocalStorage();
                return false;
            }
        }

        const hashedPassword = localStorage.getItem(rememberPassphraseKey);

        if (hashedPassword) {
            // try to decrypt
            const isDecryptionSuccessful = await decryptAndReplaceHtml(hashedPassword);

            // if the decryption is unsuccessful the password might be wrong - silently clear the saved data and let
            // the user fill the password form again
            if (!isDecryptionSuccessful) {
                clearLocalStorage();
                return false;
            }

            return true;
        }

        return false;
    }

    async function decryptOnLoadFromUrl() {
        const passwordKey = "staticrypt_pwd";
        const rememberMeKey = "remember_me";

        // try to get the password from the query param (for backward compatibility - we now want to avoid this method,
        // since it sends the hashed password to the server which isn't needed)
        const queryParams = new URLSearchParams(window.location.search);
        const hashedPasswordQuery = queryParams.get(passwordKey);
        const rememberMeQuery = queryParams.get(rememberMeKey);

        const urlFragment = window.location.hash.substring(1);
        // get the password from the url fragment
        const hashedPasswordRegexMatch = urlFragment.match(new RegExp(passwordKey + "=([^&]*)"));
        const hashedPasswordFragment = hashedPasswordRegexMatch ? hashedPasswordRegexMatch[1] : null;
        const rememberMeFragment = urlFragment.includes(rememberMeKey);

        const hashedPassword = hashedPasswordFragment || hashedPasswordQuery;
        const rememberMe = rememberMeFragment || rememberMeQuery;

        if (hashedPassword) {
            return handleDecryptionOfPageFromHash(hashedPassword, rememberMe);
        }

        return false;
    }

    return exports;
}
exports.init = init;

  return exports;
})());
        ;
            const templateError = "template_error",
                templateToggleAltShow = "template_toggle_show",
                templateToggleAltHide = "template_toggle_hide",
                isRememberEnabled = true,
                staticryptConfig = {"staticryptEncryptedMsgUniqueVariableName":"d033efbb184ad535d5f73bf33c61f7b04af12fadb191ee2b438651fdea2768e73588247dc3ed1d3b09fa55c148247f676f1c086181373b16df2e4ffe8bddd84cad03b7d20a45a429403b368349f5a8f0845d3353f474141302af10a2f71fc37db9bedd218baf017c0c80aa95539fe0d5a7039f9003964c90de2919f59fbd79ce0157ce06575228ca8bf15138dcf673ae96c0e617341b8a0164f120f94b04f01c419c0829024e06bf318edcbfe6bf9d47ee467089a32aaa5060073de4659686c71e6df19b28209eaaee6d9eb3a5277b409d1deea880e6f1a65b9cc98f6ac77223f8adfae2d6700070b61b59d5a7ca4571777b5d5d6239396aa26b4f655b1d353f9721c99d268eb134f86c58c093eb051e6c8b67bee8b733b35085f287a25512c1b41507642c3db235dd9f633b80c1c219bbcf3d63f3538da8cf8dca0ad851652b2048b456452983ab36ff3b11e80b6d6ea9fc4dd3d01be147ed058fbb2a3b3f932b05457cca6c15ab117b014b30f10d8d25730a1b51923d828f86a737bcc72732bf49c92706f948c9cce9af5148a50e7974cbf7e842385c91e4d7dbe6e5db5ba50ff72fc3896409359b9b3772e3a2ee2082bf17bb416676479d8557256221ad67c4ae50405493fbe5397d60dc90296deb8f404c5a72d8411b00cd48e6fbd303a408f88ab1ea22c907f3c4ebbd010b79e8b07fa2f586842fd0e01134129c6b7b53c4c5e9c22973298bcd3fc3c28dcb0187ab6ebee180a950a2b4cb99ecd418632665583c2a89179a3eb4268a89963c5065b49030bfde8c9edfeef65c54b5ed8ec2bfb35cca45d6d6c9a296a2e9cbfd8ca4416da4f7c5b0fbd731fd260260cdb6ed0fbea76da795f248f3c5d1fdc88613431962219e3e2b3554ad003c723b9cea99a1bee2ca6531c082d024aa50adccee6caedfb313a75861cbfb186f3aa17858971bdef3366edf1b2fc5d29cb1416973744ec3c7cdf9571b8f0185ccb38e2d7cde667b651c5725f68662b1f6fd7888012a32ce023277b9a061330a09a0218ed5bef1f233f3945b8f4685893aae1eebcc0f11b12c8cf5eda42e61bf750e174ac172ae1b9c28c0ac700fe7bdf37fe0341b6828b47d9b73cde0b76ca3ec41b3b28b99d4c6641428f82e8cc12973940e6577a001441de704ea51f48255a6a5d7944d806b610544aa38afe3023e0955f5f1f058678afac1bb589b1237d92f24ea55c12a729479b5e38f20fcb114bee133d1b2172a404a02c6e0c9e2958553d94458c06dd45644fc8398e3273d33a3af86e90d80c7a1a805d5b21a47ce0ba4e48e8960455825b8f5d3d652d2151ee78993d40a99b3d70e8376c95b7249fd45c7bc43a4821d24340f9699264ea57db63216381b4db7790fa59be73bcaa3dbb10b675cca56710e205ad16571c1625e9f13b2cbbcc7c87aaff8e024ca07acaa23ce2eca55556475c31b55fa36d823c1081986c4912ff3cb2433e0246077d919da76677f9537b69b5251f18e4ce56ecbfa6d29c6144b40b5182e0cc3e9687c2d1ca34c70c68e7393700b7ce807c4e1f0cd3043511332c0d23b6fecd6f8370d758913db219346fd3c02bfbc5cd9fa9892fcf5117957a8123ae0831286bb1693f7e89c0e18d39d6fba26b9370f1d452a90bcdab5d97029094e2d55b5645eb83fbed6da9678540e9a6213373e4cbfbe089eadedb22ef48c5fb28fc4b70219c77025a266662a987257f52fe5e2a07ca22f2049d66fc9c6b7c4848ddf95836932ecd2dd4bc3474a5b75561fbb311179c4efa2fd5eb1b642b8933b136826f0cfb7e11993943c50b2fe9c4054dd1986b0eea67cbcc665fcd265f22e50f7fa30b8325db714ba021615f7eac308ab84069bf9bc42d94643ea0cd853acfe06b3b79bce3247ce4f3d6045010bc06a47298808f99342c586f2bdbd7ae99d551d840fa38eee5fa6a94e08968cee6aa2bd62f3388a62ab9d5ef1fa8522654fb9f44d6e73b3e9a1ba6604ffdb110d72df62f9986c666329ae22b1032b2da9688c97ad1c45728079559202877a2889ac17a554413e9f216a743219b7ff1904a11e8c91e792b9369494f68499101dfa2a9d77dc0dab6dfec8cea15309b06948e83f46acc680a987a7961e238f5ca3a690e7101a3900389897411ccd94b0e6b6b6f27ed6aaa237590ebabfac012213e0e63be8da97a319b79126046b3010a1458da8fdb6657220c27c8425f4d76d8ccd2bb0af8b9c7d3a6ff2eddb74300f4ace98e01d1a40e88271a89e9601510952596a1da32ffbbdf7f55082ed4a4c55effb6579ff3986729a3e02d6babb7ea3d3c8503f0bfe802cb1e705d0d7c6d2a5fb852af6d4da19eda5899be4bfd446758a041eb4a6a0676c79a39c76351dfb72db63b7433b8bb52205aa5a284bd278bcc68982463d583175d9dc82f54471f0ec98d4a929ecd4ec67adab05580c281f2a20c64633ba034e1371a915b25bf85f3d38292b8666f7207455b5d69456ec2288512d562aaaeb669479e123ff35a2bbb4760d2e4cc060ad24ea9dac14d206c95de181b7a620021ffc6b3823759568839123b11f180f1355d66f06a65a2cd38f3597a36dd939da4b4952317ff93bb058a2efdeaa1e569afe9906e8745587a9bafef010916a102789557f8f017b86ffc7a6aa5f4652b0aee9733bc560ca8515cfa7eb9c9be462d7a8d0f63bf9b8b2db839af6dbea389e6fd834764d9f27d2b367048de4773a8966797c0c2c872eae697f3cea40d250ebafcc072c6f6849ecfec9370837e668e8f75669f8cd03c59629017c8ac59844ee8dcf1cf88a221cd4595f1cd21b9156c222eaf86b5865b0ee0732c9299e82826e2c7b5a79b1233ebc2b2f59af1e692b4782304d290504757c504a831cec235ab67660d4b3f9f64685fb8a94fa09f910617fd9bad00ab0e7607b94e01d2f2fc3799abbf716c181f11f3fc55ecd5f911fcc4aa45b23bde4d57271f7998e20e1962885b2e851f5dcbcf026a426bf6105b0f36d5c4fc8a99ff0f6c458cc10a4d347e0847634500672ff9c46f8d4b6edb9f6fe4dd5c23f20186fc2a50fd924f5919fd74a325eaab2db1658b1113290bedbdd5f16e7d3e567e2dc09cbaf0bf01c24cb54ecc12359b9357104197f7fa707ee5d4bf274fed5cf29dc82316c1a47dc53e6667587641cd56f744bf6c27cbf0e4474424b9c10c45b5a66752163ed608df0c25138f18a1cbf0bb60e5bb20c4a49cecf1cef49ae2e8a134be28fdd19d24a7950a4ed58bba3d4a901ead58018333d24c39dbe41123b005343f25951aa9bb2730540e4c588c6c07b20b8c54a0d68d3baf070685a792a275836cee8cf5b669c7fa6bde6c6ef31ef704dc9cf6dda60a3f23974c297969a550427fe73d87ea10ab939bbc0620bef1953c851045a6e6fc30d54444681c445046a8c4272154ead0554c6024723eaf61d200a9a266c741a25cb2d4d0cb89fde2f73530a309a9b80a45ede354b289f0077e3a1237402cad123fe968292ace8141087fc3ead147aaef5927959ffc7ae0ce8b6b0c394e18478937ad78d5f9b6b1d69e296ed8ec419601df4d4e2a6c4943b4dc2de29013ac1f496698dfad9d6cb2e4c9a42b94569a14d676a78839844ce995d4d08beca2dddf97505fd554b8a5b8951a2d283ed3272116e43fec17c378e9aca2512d7fd7d018a19a18d9884be1610cdd130218a897ca9fd56ad1950de1ef8162f9643c207169b0389227e5af4983844f2944b121c6edc6a10c4a26b96fa8dd9b2a0e0ab2709ef929a5407da383f261a5e12affd2ab9d99af65b6626ef9b7cd218f610d636bae0a09a92d55cd59fa16f1765dea9ab31274744af2920c5ff42cece61fdd394f07e604ba839e2c10e16e7da8ab07cdff8534465438e7c2d56270e975a18b465ca5a211664ce2dc1570e07dea8b71e06d01537e23f9dcaca436ceafcb84ca622ed4dda2b3fdac80b3ac3c1cb8514bfb535deaccfb6de98a9ef1c5dac5d8c70ecbb241ee874f7dc3de4aabea60657e9d214d0e7a083b14c5ed9951f245a962b33e6271a6e00e2d350de04f70f99a1ba922e6a9110ca8940adc96b69bbb174a1a281ff4af7c2da8d6f43bcade7ce4178f2925d2c722485ce0cc4dcc8a5250222222180f1621c559793c3d4c664c3f459157c702dcaf1db0aae46cf7e34dd15244e03d9d2621c791f5cf3129d5121a3986110835aadb420f6dcb335b241205284a5f886ac359391c60f6ddfbf0a970c4a0e21286e17e1c5b2a7df68f5215149cbb78a374f725c6aa45a667a4e2a6fa7099c78019e77cf02e3a3cf733a2029144d6de4862f2649f213f3c7d1c2234259eb73c17c399a26e0e704ae6569d7e929ddfe556af306fd95c1dce5a56432ae494ee10782776b3d43913845cbc52571be29a6fa0d5083e7f215926596c71d5c6672d13062e917762b838a82d47d872a46cd5a5449b35e42d4156fa33c21f71665b3f9857d12d2904fd3938d7be89205c8f226fa876eea7a1ebc00255eeebe9e8f427682e214edc2bef2168cc1462f0ac75a18cef514ae083d2c1004eaefdecda3ed9c83cb49802950cb10c150f57c642b4514df64eb9bcb9986a8aafaebed6138d01d35e765f5a157a579e3d122ba5d4dea35bfcfbe1c7518d6fd7604f52b7a29c814a0ed94740aa24c645369e4b544d50ccf04da4c2b3a2aa8729dbc08f920dad835af93e4a66cf706fac76355fd28bf28adc75c9c108ae3b936e5d604f594d2ebf7ab414bdc76b37a2dc1f2255dc41bca0737d56a56a6b11854e2f0b63582fd3b7d283f0619408754e177dc38cdbf8ba4daa124a52958c50690e5eff0f29e9a20d3e77b40dba3359439845a0674a23ec24307c2a8b8e52e7bccf4a410ee6d5032583baae7814288dbdd4be46c8cba01f4dee39c61d683de4613898836174cf01764ed14f410618e518f989a0dfaa1f893a2edcf09e5e76ddedcb3402562e667009fa66a077cbefc0a40a29787d11eccd1afa2b9c1af81d12595d991111d9d3a474b373358b3dde449803d68db76b6459e7bf6d3b8d1ada7911b1f7faf7ccb36b274a7d952dbec6c6c7cc72c96a677e856d1187900ebc0c334b86eb7bec87e110e0207c84167321b039b57c5879f1451fdffbbb8646562864db0fe952d0d2fd57d07a380f11e3ac5f3962d5594a8a7d94eb27cfd9d5083806d0b90a9bc4fd9696bfcdea89a1064b111c1fef814d7601ad0d781614441ad597f4184f838acdf4e99aa02abe6d814e1c2f2a724d24f1a46d13671aacb85ab873283efdbfd368b397edcc207e97c410a40fd2d729cd797c5e2b5316e27fecc0af828ea38ac2ff0a093c889cd01597bee37a9ceaa436947fcb1ad6a8644cebd4537a9654f44395be531aa97a9c7656034727fad9f170f31915f5a234c2015b2b737d1f44f01a67840629a38977502d26e03d9ab0c783e4a6901fe92605c08daf5ab850412d4b6a5502c913e42803e3560463956e4169535deb4d8280e5da67f4588b4675c310aaa111e8d0f1a13fcb81996e83bd86d77d5f24cc8e0a6c31b7ed146f882759df7970bb2f26f175325373874c721d02c5ce3b339780ab0872b2d985a813e7105858dff2899c64dcfc8dc0ac59310adcdfa5e978320bc62535648c5e9846a53db71cb486bb09f62aada1beae3fda239a10dec32f6a9b34b290ef052f57b6d133ff4d4d96baad7e52dfeaf83aa6f555786047db298545e5c252dc386dcc0006dafc2cbb8a452b753d4dfbe55e6e560511b360b9af612c54f602c3fa065e1a54c8997969e06e634c51603def54102d9317c443f105b51f0e96f7db41729d6e862caa4b0e0010d36528bc62a424d234a5caa3c2c6de4c3ba670a6b5b36d2503333fe0bcd4c3671fd12574a078c519decf479df221ae2266ce5ac0ba42fe86b30e709600c5eb86f6ecfcbcbc061a80e30ae2f97007b0262aa806677bd3a37458e5fc319d6cba06f9b06c08888833d5a9b28f3f43bd2e59be1c677ba32482e6c4ab09bda41a058945f83ca0499c313834f0d46a2be9b3aa473d3cf31ce5e3c0aa9e7ccc709c1f9f1180a3db30a0b1fc32358618fe55ee6a0fb2e57e4259238274f932c42da9e48e617eb08ce9215d9e28d738746cadf47bcd4514ccaf9e807242a1fd334603074b76633b546dfa5e2d42e2898dfc6321464f535cb2e3a72e2de6fb97291094cce2a662d0655b5309e2267e4bc9d5d38167865856267c982cc3b92a9fb2df8486e712a14e9b73aee5870d8abd86053839a026883c5657f4c38a8449c3255c1506ec65c1ab2d433dd3cbf72995ad743d445189264c19febf1e56a945315ddeaed577839d1e25a702b96e30882b84f894ca531aac8f982fa9363aa9eb8a9507742f21d82c6c3d5d8c15c90ea565de46548deed9a23c6833ea46144b8a8a0fa27c4a0497945ae71e2205716856796ac97f0644a8cbee1088a411ec9fbbbc13b686808c92f11321b829f6020f0f4b3dd82dcb13b289866ecd3df1f0b1e67b186aab1a55cf73444a5963eab369dba720d7c96df775bf3f3c47ecbd523f625c697f1b88a684c40b517600d8bccdb409db586ed2a652ea9bb9138bd5985907e3831684f41d9b442db26b89dee3b4cfb248e75a6babd9cb4bb961363e0ac2f38fbb4bdf08d63b8108cbab2b4130c40d7495ee118ba9c01e514e1f127974c29ea5e7c15ba3087e028bd46686e4561925beef54b2c5e6616d8ea4914b30f0d6c9b46f78ca3e461c35e7c1620a462457a6ec6315efacd4be22b650afaa15c96a296e7dbbd37ba2555787dcdaf5d7b774aa8811a2efb316ecf9e4dfac4bdcb1ed5d2b8440e984f5fc659486b7992139a386d156146d5e61f5a7a1a54d51be38445573b26c09aa78994b50db189585f6f42140973b8f392daf65955c73374b834fdf12c9cfe7fa40c013a4d0313915d0a449ff4a2f7d8b349d5060f19b2705acd27644483d976a409309b06e576ed4539f964b6a64c06f07c91c68492f73e55383a8bd2a15c44377a939d4e6724379c83f89f9d6dc05f72a526c36b526506d09ba3afc347494ef24e623e0d3acd8faa43920e2ebd0408ad24881504be121fb8a69e5a4d492aed5d6af10f6f2616ab9ab0c7f629d8bba7a86463b00ecd53b6687c507632a11883876ebf3d25cbb4c6f05ee3f72a8ff007971d0190e7aaef2bae43a7855d870f928af69043c1e0196722b4c96e77dac9f45de98f5e984e496b347e99c1e1f1159405d186c7946089ca0f4ee2ea48f3ba871162c9d2c997573a6ec56620d68bd6878f6cbd15d07962f6d555678065100d46e38cfa07a1f6ea580c0f3e25e504393ade09c7793d9a97ad8a21544b4835db89908ca84fbf3e59349041464da0b56bdb06b0e64156338bf844f2c036aa14d26e6eef6be3514d9310fab1bb92a649f13026fc03e4691084b0fc612ce8e7672e15842c3ae6a7f2749b5d829ed87e25e2d9ec7e570d8cd5ac1cc3580f8364ed53ec237f8e72bd0c09d8ba3aecc5214997616d526f5e214d44a5eaf5cfb6444342a7a0a6f0e600acc44f30d50887ddb7044b29c3c6c2d924e593ab858891a85b61dfcb0c28c4c0e0abb42ec02493a08bdb2670be869f1c6243245839be36a463031667d0cff81b55041636cd578e65204cda07fb0822acef081f04511a201992b634bf4b522983743c45019509ae0063df65d1be15ecc67f79ff6dfb3990b78453b1ebe8992a4a4f8633d73aab8eeb98ef662705b4d61c0707e190b54cc38e0875a15dad2ce622a94845d5d5a58558156169220458072526386b73644fedff4b9eb9e93ab969b8e535c7b52d0a61e1d3723ef7c2edaaca8591c914a1c413297805baf6101c4f64942f662452ee05cfd073118f431a2c6bdab5d06fdd28a54f0044564d81ddf765e6df57e4b2f3a781dc33b5ead1cb5b0ed5a1515607c9037b399e2095422cb1d9874be08a68ffc515c70ade933d29ef6ebda2e7d863a4e4a9471bb10d933aac5ef44eb028f9ba091da5fe815723752bec4eca053d7d903fdc1e6f8a62eae05e2eeb6b3adb21f068e5f94a1dc199795d82f8eb7bc1f29d41f91f25781efa98c44a99f7694e71cf84a194bb29ac41bd2b4f179d15e7a50180bc5060925d792ea4ce9f0d2f544c9417718b247cbb5d98583687d289e5ea8cd3cf865d0cfd445694760678ee88436da07e9eb9df26c9f8dd2cfdccac30d988884df97c2603af86b9fc4f6630af95d478166c9232b6f53fc7ef629c155ec0e37de7aa90d4a576ea211a186b5133a9ee439b8633879f4dccf18ef28700fa0107de071b78e08a487656caf3cdd544fb11a63ecff849c01f7931022085ad9cdb7c1694121f16fcc59f79213b5d0609e33641762c4b597fbde902efd9104c755489dbc7c258ec9912ce87f6d94ff405645053bd9c22733f2c0e18e4b15e35e0ce242174816e8c07b96759400abd42e119612de65dcaaf9207b941b4557f33aeb8bca9d6d7e351be7c5995ca314f69541ce472539a471f769783eb7d4d4ee812b49f1e9cf006b65f5026d706b1abaa10441cbbfcbb4d8724c18589a4aaed065f882f47da0b370b6005dd7244c77badc2aa2c3b065a4fd7b129bbf4d250836c2388433dd79808c893e5a4e7a51fff56ad436b9a90f0fef01717ddb3d833b5276de977718249b97a8fb58c6bbffd9a3071d0e9d320e1b763b4e9cf8e3d1334bdc7cf312e5b36366e9c1af92bfa7516ad74e3c2b56559e56df8d73dd68165bdef9a2f5add4e28d882dd6ba801b250af93cee9983c4840babe7a32bd61978ddcf1dc20386fb18c643ac5eadc926f60f7e3383d9c7f1397a3728b46e8364c46772249fb259aeab1993fc38e759ae9b9d6b7b7137c9f57e5aa6234e6b3b971e6bf58c0b1924ce1538709bbede9c6fe08544c8f0aba47146f6ba0c3ed1539e89efac4f201a99a6ddb035e801a595d397a6f2d36b0de17ee6b7000d935dfe1219c8501af86a0a80006c305dfe298fdea9296de42e355e5715d39cfd37caae0d3c57a63a0638a2ad623e068f5f830019f2c945d4b3cec82d7e948d2d684c21beed0bd11276f591e6d5e9ebf385c511489344b2b1fc7fd043ad53f77ea6dc888e1f7c08a791ff1acbd60c17386467a5ea3e19b8742da11699fab4a90a5d800bebfe6c7ace37980bb75bef2736315b775321236eee4fea79d8c79d36ec7467fd066ace6a4606fac95ca688f98f304d8daace3e7710b15385e211b71a7114b735847350f08e63ae4b44017bb2289645780b4c4b3d1a7a94085e427abc423ba80d2b42d4ed5d2ba673e75a1023228acf79964b2cc6957c687ee87d1b236c7df5c486cd12e77df4b20a18ea758ca1caa8d0c9e74118fd7ea6ccd26ab7e5bbcc695fafab40c6967e6f9ba05a70192eeea81bac9287c6908e27ea78c627c103e7ba9bec5253a889f243418eeba6f5b6e4fdbd6fdbed12681076114644b07de2bfa4427a20df931e6d40ca2a44cf474c6c0a4d93fc16f9e04baf1ff8ff6211b403c128c7d19d1ac01ab11e6ce5865df7a219023","isRememberEnabled":true,"rememberDurationInDays":0,"staticryptSaltUniqueVariableName":"9b1e0ab78ffe1129396896f9f80d74f4"};

            // you can edit these values to customize some of the behavior of StatiCrypt
            const templateConfig = {
                rememberExpirationKey: "staticrypt_expiration",
                rememberPassphraseKey: "staticrypt_passphrase",
                replaceHtmlCallback: null,
                clearLocalStorageCallback: null,
            };

            // init the staticrypt engine
            const staticrypt = staticryptInitiator.init(staticryptConfig, templateConfig);

            // try to automatically decrypt on load if there is a saved password
            window.onload = async function () {
                const { isSuccessful } = await staticrypt.handleDecryptOnLoad();

                // if we didn't decrypt anything on load, show the password prompt. Otherwise the content has already been
                // replaced, no need to do anything
                if (!isSuccessful) {
                    // hide loading screen
                    document.getElementById("staticrypt_loading").classList.add("hidden");
                    document.getElementById("staticrypt_content").classList.remove("hidden");
                    document.getElementById("staticrypt-password").focus();

                    // show the remember me checkbox
                    if (isRememberEnabled) {
                        document.getElementById("staticrypt-remember-label").classList.remove("hidden");
                    }
                }
            };

            // toggle password visibility
            const toggleIcon = document.querySelector(".staticrypt-toggle-password-visibility");
            // these two icons are coming from FontAwesome
            const imgSrcEyeClosed =
                "data:image/svg+xml;base64,PHN2ZyB4bWxucz0iaHR0cDovL3d3dy53My5vcmcvMjAwMC9zdmciIHZpZXdCb3g9IjAgMCA2NDAgNTEyIj48IS0tIUZvbnQgQXdlc29tZSBGcmVlIDYuNS4yIGJ5IEBmb250YXdlc29tZSAtIGh0dHBzOi8vZm9udGF3ZXNvbWUuY29tIExpY2Vuc2UgLSBodHRwczovL2ZvbnRhd2Vzb21lLmNvbS9saWNlbnNlL2ZyZWUgQ29weXJpZ2h0IDIwMjQgRm9udGljb25zLCBJbmMuLS0+PHBhdGggZD0iTTM4LjggNS4xQzI4LjQtMy4xIDEzLjMtMS4yIDUuMSA5LjJTLTEuMiAzNC43IDkuMiA0Mi45bDU5MiA0NjRjMTAuNCA4LjIgMjUuNSA2LjMgMzMuNy00LjFzNi4zLTI1LjUtNC4xLTMzLjdMNTI1LjYgMzg2LjdjMzkuNi00MC42IDY2LjQtODYuMSA3OS45LTExOC40YzMuMy03LjkgMy4zLTE2LjcgMC0yNC42Yy0xNC45LTM1LjctNDYuMi04Ny43LTkzLTEzMS4xQzQ2NS41IDY4LjggNDAwLjggMzIgMzIwIDMyYy02OC4yIDAtMTI1IDI2LjMtMTY5LjMgNjAuOEwzOC44IDUuMXpNMjIzLjEgMTQ5LjVDMjQ4LjYgMTI2LjIgMjgyLjcgMTEyIDMyMCAxMTJjNzkuNSAwIDE0NCA2NC41IDE0NCAxNDRjMCAyNC45LTYuMyA0OC4zLTE3LjQgNjguN0w0MDggMjk0LjVjOC40LTE5LjMgMTAuNi00MS40IDQuOC02My4zYy0xMS4xLTQxLjUtNDcuOC02OS40LTg4LjYtNzEuMWMtNS44LS4yLTkuMiA2LjEtNy40IDExLjdjMi4xIDYuNCAzLjMgMTMuMiAzLjMgMjAuM2MwIDEwLjItMi40IDE5LjgtNi42IDI4LjNsLTkwLjMtNzAuOHpNMzczIDM4OS45Yy0xNi40IDYuNS0zNC4zIDEwLjEtNTMgMTAuMWMtNzkuNSAwLTE0NC02NC41LTE0NC0xNDRjMC02LjkgLjUtMTMuNiAxLjQtMjAuMkw4My4xIDE2MS41QzYwLjMgMTkxLjIgNDQgMjIwLjggMzQuNSAyNDMuN2MtMy4zIDcuOS0zLjMgMTYuNyAwIDI0LjZjMTQuOSAzNS43IDQ2LjIgODcuNyA5MyAxMzEuMUMxNzQuNSA0NDMuMiAyMzkuMiA0ODAgMzIwIDQ4MGM0Ny44IDAgODkuOS0xMi45IDEyNi4yLTMyLjVMMzczIDM4OS45eiIvPjwvc3ZnPg==";
            const imgSrcEyeOpened =
                "data:image/svg+xml;base64,PHN2ZyB4bWxucz0iaHR0cDovL3d3dy53My5vcmcvMjAwMC9zdmciIHZpZXdCb3g9IjAgMCA1NzYgNTEyIj48IS0tIUZvbnQgQXdlc29tZSBGcmVlIDYuNS4yIGJ5IEBmb250YXdlc29tZSAtIGh0dHBzOi8vZm9udGF3ZXNvbWUuY29tIExpY2Vuc2UgLSBodHRwczovL2ZvbnRhd2Vzb21lLmNvbS9saWNlbnNlL2ZyZWUgQ29weXJpZ2h0IDIwMjQgRm9udGljb25zLCBJbmMuLS0+PHBhdGggZD0iTTI4OCAzMmMtODAuOCAwLTE0NS41IDM2LjgtMTkyLjYgODAuNkM0OC42IDE1NiAxNy4zIDIwOCAyLjUgMjQzLjdjLTMuMyA3LjktMy4zIDE2LjcgMCAyNC42QzE3LjMgMzA0IDQ4LjYgMzU2IDk1LjQgMzk5LjRDMTQyLjUgNDQzLjIgMjA3LjIgNDgwIDI4OCA0ODBzMTQ1LjUtMzYuOCAxOTIuNi04MC42YzQ2LjgtNDMuNSA3OC4xLTk1LjQgOTMtMTMxLjFjMy4zLTcuOSAzLjMtMTYuNyAwLTI0LjZjLTE0LjktMzUuNy00Ni4yLTg3LjctOTMtMTMxLjFDNDMzLjUgNjguOCAzNjguOCAzMiAyODggMzJ6TTE0NCAyNTZhMTQ0IDE0NCAwIDEgMSAyODggMCAxNDQgMTQ0IDAgMSAxIC0yODggMHptMTQ0LTY0YzAgMzUuMy0yOC43IDY0LTY0IDY0Yy03LjEgMC0xMy45LTEuMi0yMC4zLTMuM2MtNS41LTEuOC0xMS45IDEuNi0xMS43IDcuNGMuMyA2LjkgMS4zIDEzLjggMy4yIDIwLjdjMTMuNyA1MS4yIDY2LjQgODEuNiAxMTcuNiA2Ny45czgxLjYtNjYuNCA2Ny45LTExNy42Yy0xMS4xLTQxLjUtNDcuOC02OS40LTg4LjYtNzEuMWMtNS44LS4yLTkuMiA2LjEtNy40IDExLjdjMi4xIDYuNCAzLjMgMTMuMiAzLjMgMjAuM3oiLz48L3N2Zz4=";
            toggleIcon.addEventListener("click", function () {
                const passwordInput = document.getElementById("staticrypt-password");
                if (passwordInput.type === "password") {
                    passwordInput.type = "text";
                    toggleIcon.src = imgSrcEyeOpened;
                    toggleIcon.alt = templateToggleAltHide;
                    toggleIcon.title = templateToggleAltHide;
                } else {
                    passwordInput.type = "password";
                    toggleIcon.src = imgSrcEyeClosed;
                    toggleIcon.alt = templateToggleAltShow;
                    toggleIcon.title = templateToggleAltShow;
                }
            });

            // handle password form submission
            document.getElementById("staticrypt-form").addEventListener("submit", async function (e) {
                e.preventDefault();

                const password = document.getElementById("staticrypt-password").value,
                    isRememberChecked = document.getElementById("staticrypt-remember").checked;

                const { isSuccessful } = await staticrypt.handleDecryptionOfPage(password, isRememberChecked);

                if (!isSuccessful) {
                    alert(templateError);
                }
            });
        </script>
    </body>
</html>
