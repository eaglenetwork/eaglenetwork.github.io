<!DOCTYPE html>
<html class="staticrypt-html">
    <head>
        <meta charset="utf-8" />
        <title>EduLock</title>
        <meta name="viewport" content="width=device-width, initial-scale=1" />

        <!-- do not cache this page -->
        <meta http-equiv="cache-control" content="max-age=0" />
        <meta http-equiv="cache-control" content="no-cache" />
        <meta http-equiv="expires" content="0" />
        <meta http-equiv="expires" content="Tue, 01 Jan 1980 1:00:00 GMT" />
        <meta http-equiv="pragma" content="no-cache" />

        <style>
            .staticrypt-hr {
                margin-top: 20px;
                margin-bottom: 20px;
                border: 0;
                border-top: 1px solid #eee;
            }

            .staticrypt-page {
                width: 360px;
                padding: 8% 0 0;
                margin: auto;
                box-sizing: border-box;
            }

            .staticrypt-form {
                position: relative;
                z-index: 1;
                background: #ffffff;
                max-width: 360px;
                margin: 0 auto 100px;
                padding: 45px;
                text-align: center;
                box-shadow: 0 0 20px 0 rgba(0, 0, 0, 0.2), 0 5px 5px 0 rgba(0, 0, 0, 0.24);
            }

            .staticrypt-form input[type="password"],
            input[type="text"] {
                background: inherit;
                border: 0;
                box-sizing: border-box; /* This ensures padding is included in the total width */
                font-size: 14px;
                outline: 0;
                padding: 15px 30px 15px 15px; /* Adjust the padding to ensure there is space for the icon */
                width: 100%;
            }

            .staticrypt-password-container {
                position: relative;
                outline: 0;
                background: #f2f2f2;
                width: 100%;
                border: 0;
                margin: 0 0 15px;
                box-sizing: border-box;
            }

            .staticrypt-toggle-password-visibility {
                cursor: pointer;
                height: 20px;
                opacity: 60%;
                padding: 13px;
                position: absolute;
                right: 0;
                top: 50%;
                transform: translateY(-50%);
                width: 20px;
            }

            .staticrypt-form .staticrypt-decrypt-button {
                text-transform: uppercase;
                outline: 0;
                background: #4CAF50;
                width: 100%;
                border: 0;
                padding: 15px;
                color: #ffffff;
                font-size: 14px;
                cursor: pointer;
            }

            .staticrypt-form .staticrypt-decrypt-button:hover,
            .staticrypt-form .staticrypt-decrypt-button:active,
            .staticrypt-form .staticrypt-decrypt-button:focus {
                background: #4CAF50;
                filter: brightness(92%);
            }

            .staticrypt-html {
                height: 100%;
            }

            .staticrypt-body {
                height: 100%;
                margin: 0;
            }

            .staticrypt-content {
                height: 100%;
                margin-bottom: 1em;
                background: #76B852;
                font-family: "Arial", sans-serif;
                -webkit-font-smoothing: antialiased;
                -moz-osx-font-smoothing: grayscale;
            }

            .staticrypt-instructions {
                margin-top: -1em;
                margin-bottom: 1em;
            }

            .staticrypt-title {
                font-size: 1.5em;
            }

            label.staticrypt-remember {
                display: flex;
                align-items: center;
                margin-bottom: 1em;
            }

            .staticrypt-remember input[type="checkbox"] {
                transform: scale(1.5);
                margin-right: 1em;
            }

            .hidden {
                display: none !important;
            }

            .staticrypt-spinner-container {
                height: 100%;
                display: flex;
                align-items: center;
                justify-content: center;
            }

            .staticrypt-spinner {
                display: inline-block;
                width: 2rem;
                height: 2rem;
                vertical-align: text-bottom;
                border: 0.25em solid gray;
                border-right-color: transparent;
                border-radius: 50%;
                -webkit-animation: spinner-border 0.75s linear infinite;
                animation: spinner-border 0.75s linear infinite;
                animation-duration: 0.75s;
                animation-timing-function: linear;
                animation-delay: 0s;
                animation-iteration-count: infinite;
                animation-direction: normal;
                animation-fill-mode: none;
                animation-play-state: running;
                animation-name: spinner-border;
            }

            @keyframes spinner-border {
                100% {
                    transform: rotate(360deg);
                }
            }
        </style>
    </head>

    <body class="staticrypt-body">
        <div id="staticrypt_loading" class="staticrypt-spinner-container">
            <div class="staticrypt-spinner"></div>
        </div>

        <div id="staticrypt_content" class="staticrypt-content hidden">
            <div class="staticrypt-page">
                <div class="staticrypt-form">
                    <div class="staticrypt-instructions">
                        <p class="staticrypt-title">EduLock</p>
                        <p><p>Please ask Clark for the password to EduLock</p>

<p>&quot;Smarter, better, eater&quot;</p>
</p>
                    </div>

                    <hr class="staticrypt-hr" />

                    <form id="staticrypt-form" action="#" method="post">
                        <div class="staticrypt-password-container">
                            <input
                                id="staticrypt-password"
                                type="password"
                                name="password"
                                placeholder="Password"
                                autofocus
                            />

                            <img
                                class="staticrypt-toggle-password-visibility"
                                alt="template_toggle_show"
                                title="template_toggle_show"
                                src="data:image/svg+xml;base64,PHN2ZyB4bWxucz0iaHR0cDovL3d3dy53My5vcmcvMjAwMC9zdmciIHZpZXdCb3g9IjAgMCA2NDAgNTEyIj48IS0tIUZvbnQgQXdlc29tZSBGcmVlIDYuNS4yIGJ5IEBmb250YXdlc29tZSAtIGh0dHBzOi8vZm9udGF3ZXNvbWUuY29tIExpY2Vuc2UgLSBodHRwczovL2ZvbnRhd2Vzb21lLmNvbS9saWNlbnNlL2ZyZWUgQ29weXJpZ2h0IDIwMjQgRm9udGljb25zLCBJbmMuLS0+PHBhdGggZD0iTTM4LjggNS4xQzI4LjQtMy4xIDEzLjMtMS4yIDUuMSA5LjJTLTEuMiAzNC43IDkuMiA0Mi45bDU5MiA0NjRjMTAuNCA4LjIgMjUuNSA2LjMgMzMuNy00LjFzNi4zLTI1LjUtNC4xLTMzLjdMNTI1LjYgMzg2LjdjMzkuNi00MC42IDY2LjQtODYuMSA3OS45LTExOC40YzMuMy03LjkgMy4zLTE2LjcgMC0yNC42Yy0xNC45LTM1LjctNDYuMi04Ny43LTkzLTEzMS4xQzQ2NS41IDY4LjggNDAwLjggMzIgMzIwIDMyYy02OC4yIDAtMTI1IDI2LjMtMTY5LjMgNjAuOEwzOC44IDUuMXpNMjIzLjEgMTQ5LjVDMjQ4LjYgMTI2LjIgMjgyLjcgMTEyIDMyMCAxMTJjNzkuNSAwIDE0NCA2NC41IDE0NCAxNDRjMCAyNC45LTYuMyA0OC4zLTE3LjQgNjguN0w0MDggMjk0LjVjOC40LTE5LjMgMTAuNi00MS40IDQuOC02My4zYy0xMS4xLTQxLjUtNDcuOC02OS40LTg4LjYtNzEuMWMtNS44LS4yLTkuMiA2LjEtNy40IDExLjdjMi4xIDYuNCAzLjMgMTMuMiAzLjMgMjAuM2MwIDEwLjItMi40IDE5LjgtNi42IDI4LjNsLTkwLjMtNzAuOHpNMzczIDM4OS45Yy0xNi40IDYuNS0zNC4zIDEwLjEtNTMgMTAuMWMtNzkuNSAwLTE0NC02NC41LTE0NC0xNDRjMC02LjkgLjUtMTMuNiAxLjQtMjAuMkw4My4xIDE2MS41QzYwLjMgMTkxLjIgNDQgMjIwLjggMzQuNSAyNDMuN2MtMy4zIDcuOS0zLjMgMTYuNyAwIDI0LjZjMTQuOSAzNS43IDQ2LjIgODcuNyA5MyAxMzEuMUMxNzQuNSA0NDMuMiAyMzkuMiA0ODAgMzIwIDQ4MGM0Ny44IDAgODkuOS0xMi45IDEyNi4yLTMyLjVMMzczIDM4OS45eiIvPjwvc3ZnPg=="
                            />
                        </div>

                        <label id="staticrypt-remember-label" class="staticrypt-remember hidden">
                            <input id="staticrypt-remember" type="checkbox" name="remember" />
                            Remember me
                        </label>

                        <input type="submit" class="staticrypt-decrypt-button" value="DECRYPT" />
                    </form>
                </div>
            </div>
        </div>

        <script>
            // these variables will be filled when generating the file - the template format is 'variable_name'
            const staticryptInitiator = 
            ((function(){
  const exports = {};
  const cryptoEngine = ((function(){
  const exports = {};
  const { subtle } = crypto;

const IV_BITS = 16 * 8;
const HEX_BITS = 4;
const ENCRYPTION_ALGO = "AES-CBC";

/**
 * Translates between utf8 encoded hexadecimal strings
 * and Uint8Array bytes.
 */
const HexEncoder = {
    /**
     * hex string -> bytes
     * @param {string} hexString
     * @returns {Uint8Array}
     */
    parse: function (hexString) {
        if (hexString.length % 2 !== 0) throw "Invalid hexString";
        const arrayBuffer = new Uint8Array(hexString.length / 2);

        for (let i = 0; i < hexString.length; i += 2) {
            const byteValue = parseInt(hexString.substring(i, i + 2), 16);
            if (isNaN(byteValue)) {
                throw "Invalid hexString";
            }
            arrayBuffer[i / 2] = byteValue;
        }
        return arrayBuffer;
    },

    /**
     * bytes -> hex string
     * @param {Uint8Array} bytes
     * @returns {string}
     */
    stringify: function (bytes) {
        const hexBytes = [];

        for (let i = 0; i < bytes.length; ++i) {
            let byteString = bytes[i].toString(16);
            if (byteString.length < 2) {
                byteString = "0" + byteString;
            }
            hexBytes.push(byteString);
        }
        return hexBytes.join("");
    },
};

/**
 * Translates between utf8 strings and Uint8Array bytes.
 */
const UTF8Encoder = {
    parse: function (str) {
        return new TextEncoder().encode(str);
    },

    stringify: function (bytes) {
        return new TextDecoder().decode(bytes);
    },
};

/**
 * Salt and encrypt a msg with a password.
 */
async function encrypt(msg, hashedPassword) {
    // Must be 16 bytes, unpredictable, and preferably cryptographically random. However, it need not be secret.
    // https://developer.mozilla.org/en-US/docs/Web/API/SubtleCrypto/encrypt#parameters
    const iv = crypto.getRandomValues(new Uint8Array(IV_BITS / 8));

    const key = await subtle.importKey("raw", HexEncoder.parse(hashedPassword), ENCRYPTION_ALGO, false, ["encrypt"]);

    const encrypted = await subtle.encrypt(
        {
            name: ENCRYPTION_ALGO,
            iv: iv,
        },
        key,
        UTF8Encoder.parse(msg)
    );

    // iv will be 32 hex characters, we prepend it to the ciphertext for use in decryption
    return HexEncoder.stringify(iv) + HexEncoder.stringify(new Uint8Array(encrypted));
}
exports.encrypt = encrypt;

/**
 * Decrypt a salted msg using a password.
 *
 * @param {string} encryptedMsg
 * @param {string} hashedPassword
 * @returns {Promise<string>}
 */
async function decrypt(encryptedMsg, hashedPassword) {
    const ivLength = IV_BITS / HEX_BITS;
    const iv = HexEncoder.parse(encryptedMsg.substring(0, ivLength));
    const encrypted = encryptedMsg.substring(ivLength);

    const key = await subtle.importKey("raw", HexEncoder.parse(hashedPassword), ENCRYPTION_ALGO, false, ["decrypt"]);

    const outBuffer = await subtle.decrypt(
        {
            name: ENCRYPTION_ALGO,
            iv: iv,
        },
        key,
        HexEncoder.parse(encrypted)
    );

    return UTF8Encoder.stringify(new Uint8Array(outBuffer));
}
exports.decrypt = decrypt;

/**
 * Salt and hash the password so it can be stored in localStorage without opening a password reuse vulnerability.
 *
 * @param {string} password
 * @param {string} salt
 * @returns {Promise<string>}
 */
async function hashPassword(password, salt) {
    // we hash the password in multiple steps, each adding more iterations. This is because we used to allow less
    // iterations, so for backward compatibility reasons, we need to support going from that to more iterations.
    let hashedPassword = await hashLegacyRound(password, salt);

    hashedPassword = await hashSecondRound(hashedPassword, salt);

    return hashThirdRound(hashedPassword, salt);
}
exports.hashPassword = hashPassword;

/**
 * This hashes the password with 1k iterations. This is a low number, we need this function to support backwards
 * compatibility.
 *
 * @param {string} password
 * @param {string} salt
 * @returns {Promise<string>}
 */
function hashLegacyRound(password, salt) {
    return pbkdf2(password, salt, 1000, "SHA-1");
}
exports.hashLegacyRound = hashLegacyRound;

/**
 * Add a second round of iterations. This is because we used to use 1k, so for backwards compatibility with
 * remember-me/autodecrypt links, we need to support going from that to more iterations.
 *
 * @param hashedPassword
 * @param salt
 * @returns {Promise<string>}
 */
function hashSecondRound(hashedPassword, salt) {
    return pbkdf2(hashedPassword, salt, 14000, "SHA-256");
}
exports.hashSecondRound = hashSecondRound;

/**
 * Add a third round of iterations to bring total number to 600k. This is because we used to use 1k, then 15k, so for
 * backwards compatibility with remember-me/autodecrypt links, we need to support going from that to more iterations.
 *
 * @param hashedPassword
 * @param salt
 * @returns {Promise<string>}
 */
function hashThirdRound(hashedPassword, salt) {
    return pbkdf2(hashedPassword, salt, 585000, "SHA-256");
}
exports.hashThirdRound = hashThirdRound;

/**
 * Salt and hash the password so it can be stored in localStorage without opening a password reuse vulnerability.
 *
 * @param {string} password
 * @param {string} salt
 * @param {int} iterations
 * @param {string} hashAlgorithm
 * @returns {Promise<string>}
 */
async function pbkdf2(password, salt, iterations, hashAlgorithm) {
    const key = await subtle.importKey("raw", UTF8Encoder.parse(password), "PBKDF2", false, ["deriveBits"]);

    const keyBytes = await subtle.deriveBits(
        {
            name: "PBKDF2",
            hash: hashAlgorithm,
            iterations,
            salt: UTF8Encoder.parse(salt),
        },
        key,
        256
    );

    return HexEncoder.stringify(new Uint8Array(keyBytes));
}

function generateRandomSalt() {
    const bytes = crypto.getRandomValues(new Uint8Array(128 / 8));

    return HexEncoder.stringify(new Uint8Array(bytes));
}
exports.generateRandomSalt = generateRandomSalt;

async function signMessage(hashedPassword, message) {
    const key = await subtle.importKey(
        "raw",
        HexEncoder.parse(hashedPassword),
        {
            name: "HMAC",
            hash: "SHA-256",
        },
        false,
        ["sign"]
    );
    const signature = await subtle.sign("HMAC", key, UTF8Encoder.parse(message));

    return HexEncoder.stringify(new Uint8Array(signature));
}
exports.signMessage = signMessage;

function getRandomAlphanum() {
    const possibleCharacters = "abcdefghijklmnopqrstuvwxyzABCDEFGHIJKLMNOPQRSTUVWXYZ0123456789";

    let byteArray;
    let parsedInt;

    // Keep generating new random bytes until we get a value that falls
    // within a range that can be evenly divided by possibleCharacters.length
    do {
        byteArray = crypto.getRandomValues(new Uint8Array(1));
        // extract the lowest byte to get an int from 0 to 255 (probably unnecessary, since we're only generating 1 byte)
        parsedInt = byteArray[0] & 0xff;
    } while (parsedInt >= 256 - (256 % possibleCharacters.length));

    // Take the modulo of the parsed integer to get a random number between 0 and totalLength - 1
    const randomIndex = parsedInt % possibleCharacters.length;

    return possibleCharacters[randomIndex];
}

/**
 * Generate a random string of a given length.
 *
 * @param {int} length
 * @returns {string}
 */
function generateRandomString(length) {
    let randomString = "";

    for (let i = 0; i < length; i++) {
        randomString += getRandomAlphanum();
    }

    return randomString;
}
exports.generateRandomString = generateRandomString;

  return exports;
})());
const codec = ((function(){
  const exports = {};
  /**
 * Initialize the codec with the provided cryptoEngine - this return functions to encode and decode messages.
 *
 * @param cryptoEngine - the engine to use for encryption / decryption
 */
function init(cryptoEngine) {
    const exports = {};

    /**
     * Top-level function for encoding a message.
     * Includes password hashing, encryption, and signing.
     *
     * @param {string} msg
     * @param {string} password
     * @param {string} salt
     *
     * @returns {string} The encoded text
     */
    async function encode(msg, password, salt) {
        const hashedPassword = await cryptoEngine.hashPassword(password, salt);

        const encrypted = await cryptoEngine.encrypt(msg, hashedPassword);

        // we use the hashed password in the HMAC because this is effectively what will be used a password (so we can store
        // it in localStorage safely, we don't use the clear text password)
        const hmac = await cryptoEngine.signMessage(hashedPassword, encrypted);

        return hmac + encrypted;
    }
    exports.encode = encode;

    /**
     * Encode using a password that has already been hashed. This is useful to encode multiple messages in a row, that way
     * we don't need to hash the password multiple times.
     *
     * @param {string} msg
     * @param {string} hashedPassword
     *
     * @returns {string} The encoded text
     */
    async function encodeWithHashedPassword(msg, hashedPassword) {
        const encrypted = await cryptoEngine.encrypt(msg, hashedPassword);

        // we use the hashed password in the HMAC because this is effectively what will be used a password (so we can store
        // it in localStorage safely, we don't use the clear text password)
        const hmac = await cryptoEngine.signMessage(hashedPassword, encrypted);

        return hmac + encrypted;
    }
    exports.encodeWithHashedPassword = encodeWithHashedPassword;

    /**
     * Top-level function for decoding a message.
     * Includes signature check and decryption.
     *
     * @param {string} signedMsg
     * @param {string} hashedPassword
     * @param {string} salt
     * @param {int} backwardCompatibleAttempt
     * @param {string} originalPassword
     *
     * @returns {Object} {success: true, decoded: string} | {success: false, message: string}
     */
    async function decode(signedMsg, hashedPassword, salt, backwardCompatibleAttempt = 0, originalPassword = "") {
        const encryptedHMAC = signedMsg.substring(0, 64);
        const encryptedMsg = signedMsg.substring(64);
        const decryptedHMAC = await cryptoEngine.signMessage(hashedPassword, encryptedMsg);

        if (decryptedHMAC !== encryptedHMAC) {
            // we have been raising the number of iterations in the hashing algorithm multiple times, so to support the old
            // remember-me/autodecrypt links we need to try bringing the old hashes up to speed.
            originalPassword = originalPassword || hashedPassword;
            if (backwardCompatibleAttempt === 0) {
                const updatedHashedPassword = await cryptoEngine.hashThirdRound(originalPassword, salt);

                return decode(signedMsg, updatedHashedPassword, salt, backwardCompatibleAttempt + 1, originalPassword);
            }
            if (backwardCompatibleAttempt === 1) {
                let updatedHashedPassword = await cryptoEngine.hashSecondRound(originalPassword, salt);
                updatedHashedPassword = await cryptoEngine.hashThirdRound(updatedHashedPassword, salt);

                return decode(signedMsg, updatedHashedPassword, salt, backwardCompatibleAttempt + 1, originalPassword);
            }

            return { success: false, message: "Signature mismatch" };
        }

        return {
            success: true,
            decoded: await cryptoEngine.decrypt(encryptedMsg, hashedPassword),
        };
    }
    exports.decode = decode;

    return exports;
}
exports.init = init;

  return exports;
})());
const decode = codec.init(cryptoEngine).decode;

/**
 * Initialize the staticrypt module, that exposes functions callbable by the password_template.
 *
 * @param {{
 *  staticryptEncryptedMsgUniqueVariableName: string,
 *  isRememberEnabled: boolean,
 *  rememberDurationInDays: number,
 *  staticryptSaltUniqueVariableName: string,
 * }} staticryptConfig - object of data that is stored on the password_template at encryption time.
 *
 * @param {{
 *  rememberExpirationKey: string,
 *  rememberPassphraseKey: string,
 *  replaceHtmlCallback: function,
 *  clearLocalStorageCallback: function,
 * }} templateConfig - object of data that can be configured by a custom password_template.
 */
function init(staticryptConfig, templateConfig) {
    const exports = {};

    /**
     * Decrypt our encrypted page, replace the whole HTML.
     *
     * @param {string} hashedPassword
     * @returns {Promise<boolean>}
     */
    async function decryptAndReplaceHtml(hashedPassword) {
        const { staticryptEncryptedMsgUniqueVariableName, staticryptSaltUniqueVariableName } = staticryptConfig;
        const { replaceHtmlCallback } = templateConfig;

        const result = await decode(
            staticryptEncryptedMsgUniqueVariableName,
            hashedPassword,
            staticryptSaltUniqueVariableName
        );
        if (!result.success) {
            return false;
        }
        const plainHTML = result.decoded;

        // if the user configured a callback call it, otherwise just replace the whole HTML
        if (typeof replaceHtmlCallback === "function") {
            replaceHtmlCallback(plainHTML);
        } else {
            document.write(plainHTML);
            document.close();
        }

        return true;
    }

    /**
     * Attempt to decrypt the page and replace the whole HTML.
     *
     * @param {string} password
     * @param {boolean} isRememberChecked
     *
     * @returns {Promise<{isSuccessful: boolean, hashedPassword?: string}>} - we return an object, so that if we want to
     *   expose more information in the future we can do it without breaking the password_template
     */
    async function handleDecryptionOfPage(password, isRememberChecked) {
        const { staticryptSaltUniqueVariableName } = staticryptConfig;

        // decrypt and replace the whole page
        const hashedPassword = await cryptoEngine.hashPassword(password, staticryptSaltUniqueVariableName);
        return handleDecryptionOfPageFromHash(hashedPassword, isRememberChecked);
    }
    exports.handleDecryptionOfPage = handleDecryptionOfPage;

    async function handleDecryptionOfPageFromHash(hashedPassword, isRememberChecked) {
        const { isRememberEnabled, rememberDurationInDays } = staticryptConfig;
        const { rememberExpirationKey, rememberPassphraseKey } = templateConfig;

        const isDecryptionSuccessful = await decryptAndReplaceHtml(hashedPassword);

        if (!isDecryptionSuccessful) {
            return {
                isSuccessful: false,
                hashedPassword,
            };
        }

        // remember the hashedPassword and set its expiration if necessary
        if (isRememberEnabled && isRememberChecked) {
            window.localStorage.setItem(rememberPassphraseKey, hashedPassword);

            // set the expiration if the duration isn't 0 (meaning no expiration)
            if (rememberDurationInDays > 0) {
                window.localStorage.setItem(
                    rememberExpirationKey,
                    (new Date().getTime() + rememberDurationInDays * 24 * 60 * 60 * 1000).toString()
                );
            }
        }

        return {
            isSuccessful: true,
            hashedPassword,
        };
    }
    exports.handleDecryptionOfPageFromHash = handleDecryptionOfPageFromHash;

    /**
     * Clear localstorage from staticrypt related values
     */
    function clearLocalStorage() {
        const { clearLocalStorageCallback, rememberExpirationKey, rememberPassphraseKey } = templateConfig;

        if (typeof clearLocalStorageCallback === "function") {
            clearLocalStorageCallback();
        } else {
            localStorage.removeItem(rememberPassphraseKey);
            localStorage.removeItem(rememberExpirationKey);
        }
    }

    async function handleDecryptOnLoad() {
        let isSuccessful = await decryptOnLoadFromUrl();

        if (!isSuccessful) {
            isSuccessful = await decryptOnLoadFromRememberMe();
        }

        return { isSuccessful };
    }
    exports.handleDecryptOnLoad = handleDecryptOnLoad;

    /**
     * Clear storage if we are logging out
     *
     * @returns {boolean} - whether we logged out
     */
    function logoutIfNeeded() {
        const logoutKey = "staticrypt_logout";

        // handle logout through query param
        const queryParams = new URLSearchParams(window.location.search);
        if (queryParams.has(logoutKey)) {
            clearLocalStorage();
            return true;
        }

        // handle logout through URL fragment
        const hash = window.location.hash.substring(1);
        if (hash.includes(logoutKey)) {
            clearLocalStorage();
            return true;
        }

        return false;
    }

    /**
     * To be called on load: check if we want to try to decrypt and replace the HTML with the decrypted content, and
     * try to do it if needed.
     *
     * @returns {Promise<boolean>} true if we derypted and replaced the whole page, false otherwise
     */
    async function decryptOnLoadFromRememberMe() {
        const { rememberDurationInDays } = staticryptConfig;
        const { rememberExpirationKey, rememberPassphraseKey } = templateConfig;

        // if we are login out, terminate
        if (logoutIfNeeded()) {
            return false;
        }

        // if there is expiration configured, check if we're not beyond the expiration
        if (rememberDurationInDays && rememberDurationInDays > 0) {
            const expiration = localStorage.getItem(rememberExpirationKey),
                isExpired = expiration && new Date().getTime() > parseInt(expiration);

            if (isExpired) {
                clearLocalStorage();
                return false;
            }
        }

        const hashedPassword = localStorage.getItem(rememberPassphraseKey);

        if (hashedPassword) {
            // try to decrypt
            const isDecryptionSuccessful = await decryptAndReplaceHtml(hashedPassword);

            // if the decryption is unsuccessful the password might be wrong - silently clear the saved data and let
            // the user fill the password form again
            if (!isDecryptionSuccessful) {
                clearLocalStorage();
                return false;
            }

            return true;
        }

        return false;
    }

    async function decryptOnLoadFromUrl() {
        const passwordKey = "staticrypt_pwd";
        const rememberMeKey = "remember_me";

        // try to get the password from the query param (for backward compatibility - we now want to avoid this method,
        // since it sends the hashed password to the server which isn't needed)
        const queryParams = new URLSearchParams(window.location.search);
        const hashedPasswordQuery = queryParams.get(passwordKey);
        const rememberMeQuery = queryParams.get(rememberMeKey);

        const urlFragment = window.location.hash.substring(1);
        // get the password from the url fragment
        const hashedPasswordRegexMatch = urlFragment.match(new RegExp(passwordKey + "=([^&]*)"));
        const hashedPasswordFragment = hashedPasswordRegexMatch ? hashedPasswordRegexMatch[1] : null;
        const rememberMeFragment = urlFragment.includes(rememberMeKey);

        const hashedPassword = hashedPasswordFragment || hashedPasswordQuery;
        const rememberMe = rememberMeFragment || rememberMeQuery;

        if (hashedPassword) {
            return handleDecryptionOfPageFromHash(hashedPassword, rememberMe);
        }

        return false;
    }

    return exports;
}
exports.init = init;

  return exports;
})());
        ;
            const templateError = "template_error",
                templateToggleAltShow = "template_toggle_show",
                templateToggleAltHide = "template_toggle_hide",
                isRememberEnabled = true,
                staticryptConfig = {"staticryptEncryptedMsgUniqueVariableName":"916e7304563e93a96847dc6a9e5da69d117901d3451126aaf31ea563d328745e525078dcf9714e17c7801ab23cadfa583aa387dfeeba6121de3afa7766bc943774ef5b970dad7f2e8332a2165ce8e1325647be35f0793b71fedf0efe8e199a9c406067f0df3603c2871569df45b1a52d02b1fc5b80b0a3995b72211c2ac2e97db47537e478e1a5fa0f29c13997e76915d15fb8810da3a057c52002734e1e6cbd8aed35a803cb78b49f566af1e28babc58b54405ca2a86015da746523a2b965300298aeaae9560447a8da312fce650db834e9fc77c0aec7ddd21df833a70b89092249dd084d2346a63795c2f462dc8d79bd4df1356ce66e11adb8de8b30327c5de7b3f4ff290c8bdf531fea7e870170b3f502c42e194fd15c255ee21a444dbcc39c7171fc05191288fd5e0275898fb0b4df417d8042007e0e9f9a70f8829052563bf6b0a6c1f0bd586df5be0a6333f658c3b0f7ff9c89f685878b879989ec7f6ead5b4f40feccba7c3fc47fdfbbfd0676dd664160ddd9bd9b89331a80d0509c8e0f73405108ae57faebb7608136a72f0dd454cccd4095dbdc964a6c5fa87565f93e139dab7a76e912df56f262857d52cdebf8b80ac4175f4f7fbfbb2a1edc3f27d632ea96ad81528e447e696422d3461aa3e61422de7c10d94a728e997be175e27ff3739aad10808ea8b09243400fe144fd9501462347a50cbfd404224c5c073535d274f871ad896b5378915a1d1b8908b09775b93b93f27bbac014b08071c59fc7e5f8027ec2b745038c8b0c2c0c1d300c0c26f93cacfc5fe7a4eaded65738d2a91cdd8b115bd354e4bbb9c259771e83a99ce24e1793933f5ec70216943d8108d18deac21dd130206c58e244c7798075dc9eb8278ec044877754111c15df80e461ce464b0c78a43e6f4ed164438fd29eecc7db70ccc5acbcc7eebb9f3896c689b252d3025706820b332dd4af8acd973f123e3ae14cd86f98330cbf1773cec7f8bca5b2155be2694229e67b892c13f3b1a38e9ca1474bf6be6c1983feb943427e91f638887af1440abf3e6328958e535468baa1bdcd98e29418a8d0bad7a0accb4daa2ac7d171746a005a7becc651b5f309978f4b115c6bd91ee391ffa83fa1c8a912d40353ea69fb0a64785251da892c8d53faf6aa3a58dfcac0e5cb3fa37e7294837cfad2114bddb4efde563712c6c476a4b2f1ee58210c113a971586567204dced9fd7ba4810bcf25a0c1e219589bf66614e536718c88e4f95d14cc7518a0edcd5ab06bce57c4e4f6124dfe18ab7e97e5d41a7aff0a76b8585c1772e81b7047a93ec1f33b29e8c05c1edca38f4080655f88ffb85d5f9757e27998754769831814f3d2c25fb43d43d24ff0ef9d63d26a262a7aabb122e7421e90698a4b5974e9960a0e12748a7107cf75685a03e2309631403fa2fddfaf80faa9fe085905a36b5f615f3a3bc4d5fae3dd66cfb0303c13685095b4a3dcc6a51e63ad788ba6bb65fa6bd678018b197e4ac5949888ab445583da2849b7fe06ae227303ca2d8a24539b6258e53b2ff0f35ee9d1684db4553c77cce60a3b0c9e6cedf907a2e4f858fe36107a7c93edf251d3641f48aa7235a9742dffeff3545bcd2516ab3c381daf6c24ebbd7645ec8bc08971643ebf642137fc4d38aa60472cd73bcbd73c48537e0edb6058bf6abeeb0b6c18f9f9080a3202acb8dfb4f85788e97cacce59e2a1e4e775f82ae1a1b41356dc5e33fc9e9a4cfdd97bf4b0cf22a24d75dd228c75249b55e4acbb5ca05b98f4e65e1bbe88cb763e5c7fc17f01a6f10b5d73889d1662fa6dbdaa29b4ef88803943d578a4443e1e1fbba57ffe239349bce7d9b8c69176e2efacbcc69597b052a9bc00746c4a61e2ab5847171a9f6b9487aff2022e6cca237cbffb58f9624846dbb8326cd338b49056b7b366641cb9337795cab1df3ed43d9eddc819d6d4ea443ac84a477ad3a37b7edde1717143c3a81a34a045ea36906f6aa6c67c536a42f3768c8c5d6002a3e1dc3e1a495646eb09cc6444d4435524217438c1b63c0a53238f6bdbc6bd839d829cbc5bf56a0bd82781f69ff186db3faa13f48f8d94bf5da4e300090e7104bb763ced6b3754ecfc03f011931d7aebc847f7ca80f2a0ac7ee47130226edda57da55f7612bcfac77b94889f3a49f27f8c04908d151e6ebf66ab344007bb663524fb039f3ec397a4a84e00558d9dae29ecde4a548393a4e7a8ee3496f2136e9923ed58cb4b6b9c75b15b428dbe81a188fcadda57be830858e456bfea27904a58e14441d11a6a46dddf455675b6d8ea2e137a1df5759ac7eb2792fbf86cbdb1701386607ab974def64a1e2d3370f5a293b0928a19c0c586cd4e5f53d62e9b54966c1f4c60d50967b551b1671e0c71044286240ce5732c80721e92aaaf35a065455f904cb2a692bda3676b72bf6e735ae8f8e9ac1c450268a27c2ae0e6ba4305d593fd1fd17a1541956be1a96c6df1912d32d28319b9fe859618e7db83ac2ee9496324687257c1b3dab0cae80e813260c312d4b7ba276678cee00229a732b9e9baf30012e8814b0f7a0689b2990e64549e786c7b1e1fcd3f843d4102b49fc0ef52ae764e8d523a1e7f009e26ec3cb095cd8ad65e9250c32eafe6ce4f63912efb1078d88521433f4568af8c9868368808620745d5d257aa608e48e414c862e838490b28178f38fe0e12acb727c5256b63537857b1dd4f44bc8a898ac45e33e1406d33671c86bcb417cded43051ecc9a77a952212d6eaefccad2d805d9780a0283321b68a7ade9a92c37cb50a37e5efc9bc255ae8ef5361c5dfd3fe113206ab79358150854c30ef1065f77ffea41554bf8bc10fcefa8792e1b4358a8ecbbb6526359598f8b38237d5a8f9594b859c763783c26d156af111cde431fc50f69bee200f6f5f43dddfb830246336f168dba8e20b69b700f43be5957175f897c4e7641c44003dda998cdb0c7888934420fc9256c5a2521ce19620723564256499b02feba7194f1ae1a1fa5c724eaf34c5b29ba22bc79716dbd025174d96ef47b6b55eefcb1b8d6bf6d61f528d825222460b3e976811e27150ba000b3ba5064c49a0343b858e15ef2948c6c81cb274a22dfc987ea056f3c8685ae7e67d90f2c2f58dee4a2a615debdb23e684dc2024931ecd6d192056936b43a2e0558c29fa5a8a258f37b8c2f1175d0c5616675138e63d8e527e0a679ea8b443ade3e8a550ffad95e36bcd0dda71fabefeb3caff831c89d9a1dbb60fba8a9b50b46b91ee982baf7beba20abea50b62a4d8a311c1558a23085f06fcb3fc6ab5efc61065790e6b1bf41a5394783211ade03b492bf7f54553f4c367c1b2aafdb130cfd3ca8170dd8e9fc28324e3c5946b3e83bf14f0d041ed5baac7572cd03c08d55c74eb99bb8ec3788eebbfeee5864e9a024be8300e8379c8b5b592886c1431caf1085f8842f5328e214c806fae0c02f946854aba5dc07dc0207515161c52e240ab80fbfc7a13c6919f4b67caab82ca3a4dd2b348d1a5a3f6357b00461ee82465b1c07536a66c308fedf30eae98270f971e7747c0a48c305559504e9fabba1714710f71a415763ab1bd9f2884d66f6c7f0e9e85822f91710c419943a167c235c9accc9714538014f25ca8a096f80f32493451c6dc79ccfc7242df491bfb18d96338b062d7d6617bba8df17ba01292bd457f696ae3ad7e3238c9f60c97087dc96ddcae47a76a8d2b3c760c1244e6ba615edea08bb982eb8db00c15712d568c2b6339f419de11140f0d5651859025d914669811338007a5046da7bdfc908dddc9caf4de80dbac41cd1a4e7534a51d683831546c5ec3b39f8fa3acf74738cb8ca6ce2dc07254768143df01eb5f7d169191a4e536120d5b1a6663f8fdb7aac2fdca97615c8752a54aaa26877c6837cab6298c38aca81fd936e7dbda9909a6accbac1b8a3067d55435beba8e0e58480256255c51de54782bccc608cf38f46f0ab5acdb84969838606731bb906b87f3a58f038fd04b1fe97f11456c59c50953f38d6ab80947c11703d8cad1d375eaa8e2728a12c14d9c1c022f405ed38327e495a8f8f511b78badc8acc9eecc7f37bfad9278670677dde514dd91a95132d5d546e633e4305e85f72131e806f9e05b88a21a656b6d87a7ae9da1eb86c84eb70ea2d670f44747f2193c0e0294bdc731e521f00fe91c1b541257c7dd4959101e741580f12a1b9b9d99e3a737fbebe1b89ccb748fd229b3390c77f2667c77afee1b2c1fcdf03625c4a2371df216eebcc2d23e4653558ad50722fa8cf09d804367578207ccd82fa4e943ff9c9dacc965558ea112a9067762acaa95ac2cadd998c950b9e0c526c5222f4ef9a26757d7efe27838ee3fd4ced92bdba9fb4629456f19cd482ec47eb1f0efea21560792ce58f3915851a7383aad6a00cfeacaef8c0583795904417897f0b0d23a64dcc244a69a64e475389659a957d4612345c71e0ec7a0a62aa83ef0487f375c7352825417e1e06a02302e32c7fc4b888cf72ded47b3a9bfdd8a17e06c6c0ecd74601ea1cdb983b0d882afb5a74e1ec5b752718ce4778864f0662e450e484c3f195e80360ab147f21c85c81ece83096cfa95cb5d96f4928c33cb0f819c01b9bdf4924ed470c8ee61b508ac796289a37bb7430f39a277c6348c86e10df51f5f42bf1cfa448947b22cb64d3f1557fe42b9253dd3dbbcbf3d8f38b13b86133a3a0f4360ddc1abb543d6d60457ea966f2497462c422f3fa55c23da62742b814b6c846e516c5c61ac2595664bcb90b1e2e001e0fba5fc63d26c6b552cac7629ac6732e697f9848ba1037d566aacf9fbc8e4ef1fbfa693fbec573c5229d37423fd6863dfaa9bbd19056488b6faa4e8153559266abbd3210b22feb51cedbe14b277de9db4137f1d226dd6a254e7fdd90da9b18c6e2f4f3adacb620612185b2059bd6fab06876e268965c50dea7740b9aeeb08e725ca3a18b1501164429cea0821a73eb63aa94ecd5e5403e7da512bc3bdca8bc041f32fdf99a4d0d4a6dfbad1e6ec6f4284e4160a9854440c420884691d1491798e13e26b3ee38cf8e944f716631abaa42a8e55410ccf8d4d7e6e0fd88a563fc7fd3dc1905e8b72abe32d75bc95938057286370d55ca9cf6b5fa6aa47eefc2b4c2a6409f8f6905d259c2c2a23c21ba6fb350ab699de7392b3a11e28a7d9d685bed5ae0a3b054601619e6af7b013416609a34bf7293693a1adccc4113e064ff34016f06c6f6b049de6703575f4ffd06e5e588dd43d30c3c48cae11f1296bfdea128fe1da4e93af68586ec266bc4f56eea9bfba6b03bbd1b1ed9596dc90cf55e45c568be5bbfe6552c99ae517747e8e6ffe0ed0ee6cc6d3f5d08225fff1b1a529026399680e844e417d480ed38b87a9013aac8d70a0d359aca600089a393dcd5ee8e04c45ff15e3c00b199115cd265021d10cf607d5ae9207a3d50f3b38b41caab8f4c0da49da8094f1378fdd7db77e9feb785b62a21e0ff694d72e2df729dd887b0b5c3d1da7b267d36eabedfda6b56dbfb2d116dec352c51a26d6b9ed3843107a8f0b4f03237f63b3fc35e16291d40157575ca4ae7fdce6c365e93cb92139e313ed898d39a0bd5b4dc6f651efe9271ff9d153cd0bc42bffd6244ca562392b727627f4e0aaf62c3bd41def3c8b9698a8a0c17ce2801c7ed9fc65fb9a798de9bd982b77fed1e11358e9c4be52af95fadb8e278006dcb58e3ae7461c12b2320f29830943cd9934dad03bbe136fb4d228178c9a60d20eee00ed5b2bc5b4dccaa278df427b0831adcb44df884107e52162de090021e0282ed9518eac83b384ee71ec19918487b5dda7b3ea16b9c4e53a0ba6312b2d1c7affd0ac769a8063c24a33f173bbfe79ff77b07365e8226f8e232d0aa7d27b879a9672bb0880c7632c4e64ee8c4a3fbb79c52766b362d4be440f4a962961dc24321547c4357709359b98df73d863b6d80d2e47ce2fa96c83582756b6a67596c90bd10b55c92570926a153488559ce481555f597866e64332393621d6304b144faefdf00f01fd335d56ee8893a426d873e2f3ccf0292788c0f0b0c0e7499f49d2fef41246c9bb270b51d26eb9424e69ccd4bc1a433fc367b0b99faee4d745b35841b3fa802ffaafeb1167489fcce81be2e3f56fa800dc5e3ccac86b36273a3d2250fbab9217765509010ad53aaeb37a81b40ecf06bd057eb14266a50cd3553d0441d515f99e0729d91920b9602a6b33846342bb10eceef832abe49550c89c1f80e79138e33bb53bbc4b7cd06d68e4a8b64ed447a8718aee8cec51212a032bbe3b6ccc97ae607ed1dfb24dd406358c29f1ac63a0a55b400aa733183ee4eeb0b8dd38b8b760752aa2deaca23e96d9e3cacaded8d40621a1002fa6e0326ce98789450864948d9293fb173415b476a3c82b647ab8f56b50239ec841f8abfd9a85c068f703ab4aebe014c6edf4dbf38a58c3e915316d756f0ea19f8cbac66967a04dc4163b7470a5dcd87dae11351050bb9c5cd2d1695d9f5146b44e0260c72c5bdf5888cd06ed117d6f10730c7fc4656f642a40ae2e1fd62f6057d897eecb8e9256f6407ac5c5c82bc2dcffad3f62f508c2b59785ba8ffcd2ec928146e4176572765e0a0a7274f6aa3a911882abc2419e4c138bd8754bb2ec07419af27f0202875bc497b982dab8bd8e50948d4a93acdd5940bc9da5ede50538f7bd2bcc829a4cef5b16433f8342251eb8d1b5bea95df3b9a1884c4e25f737b21db900e91c3cbde65e71cbf09a0f2c390e681cca364e6ffa2b57b09553831089ce956fa25ffcd8e13ab7e8f59caccb4f92f6d2893e94658fcccdf4978a2afd3e52607bf79a4ed08695f20a6606b6c37a8fc4208f7a1f03668ff0c0069de2b492e973ce78a7d59bea026f061e82ea6cb6b2587731d9e7720c66e5d220edfed88abb8728f8cf11be2147076b91f96c5f70a85b4d5befeb5bcf34ecb27686e15be9e10ae18d56443db58bc3f44bec37e16ee7c15f9da0ba99f75d30822ecffa76d5d262b02bef09109228604aebd39ba34b7b33a889f7e83436bbd7b6c9beadf56730c03403af8a705cfffa60a621c29e123f432c745cc71d95aade73eddefd634cf4fafdb3fde2fb94b8284b02d8f1aa7237d137c22f4effd6c615dc5b0dee3222f1e07b19b633547f39d69a1c0edf8f55bccf0c3c8f7bdc1edee416923f98e834103742f8d4c3f29a4f21bd0bb2b8e75bff092e132c9443c6956e631aa90681e25037284dc21261fa5f9eaf1956e8f403ba346dec57b41b6b8b9790aa42bd97fcebad3621a219082a2a646bc230d1d6ae26d36fc1ddd2456359cba8a3898aeb17aa365bc96016b044151df77cc7d79fa9599fe2bc8bd006e258ced17ae4c4c5cc67749dc3ae67fea2132233452bafdfb52b383c0fe20a747623746ea1567156557c8c8955d54b6cbca6c680fc9a3a4ba44908f16596523e2392446669c74413daeadf15b8fee1b588753ac3e8f5092675c9267cd63c1a607aa9df6cfc161c629abef9f7cb5e3bf8f4872f3c59d5a7891cf128511f4cfcaa2caab4f155e807307a8bba14ef839ea279524945508f7d708f0c9d77f66ecd74fe3944726ca5aabc0869f343ddb9f48abe75b9f3751967a6b9d106823da5069a21c292b461ca5c44feeb5ec5c00ca9510525e00f4bf39263f62766de796954bf2f7af893357e14e4e388c7f3285d54d7b094f0751c906dc3b56da1bfa7f68c33e134c6c85803e659de41a86171572c38a16447f0c435fe3b998787036f2f7e8d0a1a767817b63851d85a11112fed718c5c762a880881ec7ff0f0cf403ae16145d70b84d36ef7d83306494a0cbf18d234877dd0148b6a725a49e37467071fb066e182a13fcf9dfc8e3ece056036e0bfe8b1d126ac0fb7ecdbe4face9fefed61b667d6b40947967f91cd2f5dec93155f102f8c89de374375186028be96f6962883cdd34a1d9f87366467bb8554ec8c48c2cebc2df49af30af41599a3cc85fdf1e372907cc87313dd552ff9994e1905e6db9e45866ef4eaa70e7d0728079635cf7dc26af5e7d207722df092ab5cb6bc699836763a9993d1ef2aa8e72cd7b6b74514eeab5c6fa56d05fa3d7518f7933e5c2619a7dd285f8a2d387de9802a707b02f7210cb50b661407480a45912b0f165de9c489841dcbf07c4d8c057bc8f907fa409e47fd428735fa8d77d6b7deb329920d51724927a1788e276d5abb1d5c8807ad343c9b25b08c272e78a4bcc39e7636ab19dba597fbba98f7fbf4f3b2772a15a6268d74e2ea783aa244df8af10c05936b97fe513ae1dac7d838c3d53505f680aa0a9426aae27fad4746efa9ab96aada277816c7c33deed7237d00967199e3da4c056016f97af9ba7ec6aa9114b7c936c37941f998da43ab26f58f0233f3f16d37276bef971fb53b6e981c44c680d93c766b70e89b264bc5a3996a00c574ad134ab897cab09704b2158ff1d18cbb6e9c65a7b8b690534f49551552581a9af285a3d023fc8f8d4a0eeae113937fb566cf8bc77dabd035e96980cd81ad155430fb63e37d56cc80df451aca247a3e74d522dcd6be97d7d288d77389c1b6a6bbe554ceb8d76fcb6c8e545f70a1ca73d0de3e9082f35eaeb84d4cc52bdcba978122b7ac2dff40988644b5f58d752c75a513fd4d46020ccadbb5ec9da363d754c0685cf250830b6913b08cf8ee0ef636eb180d716bec5a59aa191ae6a5cee9cb7cf653bfacaf6638f4a53c614c6298a1e1399e846b72e83bc40f42f9e3cd60d9e1defb384a71fe29334179f9e477cb135b170be860843e5e15fef93a143c449aa38701a87869c1bfc30b6af4cd4d5e5d5f7290d92d169510186f4ea50ef518b7f9ac5c931bf9a8195279f561b52b38ecac7a7e46e02b49953e1403d90b3a0798e925ec7534dbf4dec3b9c1b823a68e7edeae9a1bd02329ec7c180d2b1b2a24887fc63e514ec69da7ac21893553da1363a600a1e8400eb26cb6b2d071f9c7ba23ff2f2ce90113c64b0633b49c8cb096b14354ab91407a1bd25b0f9e500565b0c979dac414b3529d5b86286d7a5131d741401d90c1486d8c65f72014b74499a1c3971ef68957bab39ce6a3f53cc971910b5049bff087726a295478715cb26704238cd8929d9d76577af5583bea1031998f4cfdca1825a812fb72c882edbb111b00b0ab9029cefe38e65f555e86587f824962adbcbba5461159c032c38178e9082e1ebdf6834ac11bf4e478537042fd27dac4b33f93f67b8b3c9851427523bdb8f936499d1dd86344b06d4d98ef281fc9478009a51a5e89dc281f4f36a10d112b2c08f5e712a5654efe9654aaa43fc11608d38883cf50855b44d93fc9002a6063d4ab5b69771680b4b7076f5c8050693586cd0eafaed8d19b90490f1301f6f505a605aba62bb60e31bc4e8599d2319346ee8745cfb3dc4add9b0b5db871dc9625b8cc5ad6c20d010d300945ae6906c20c2ee0b9803200b44589f539d0024c2d89b63d5b764bab67d92838cb135f8103e32c83a1b89364280acc248ee040f49b58e281d747794de4d7172ddfe1a3368566b7b59cf4f54ecdafa6624919720abb8641e711db192b2dc87f08f62c3be45626b114d986dd200fd03706c127dba59e86a7f1760ea66824683aefca4ebc3beae2023b97c0677ad2c323289a18a29bcea9879419f09d9070254b5e731fb06994e4cdc1c762c45513b6394c86ee43a761ad1f1ce302f3e7460884d1c3c706809c5f416a8d6115e40852efb633045273d7aed68a53518612ef06a44a7ec7e2760df752e05bc63c506abf5df8d3ffadd0dd5550c0dd0c59bee062e0d68f7d96c7e272307ef0afeafb42aab8188d2cf4d1e51487cf7bab091ab66eb82a36b9a811bcf07c5d4f34952c107b7dff1ace86bac338ffc260840e80f3d9c7edc3be6a9bfbc3330c8e237de8e2a39280a5fa81675d5bd3f4870dbd03cdccd851a873edaae1341079b1ac0911c8c9a1fc3de8310320af7e95bfc3bc2d4c12c35897a3a1e5298df4821e59268a45945bce29c6bc09eb9b9af089fa202a7f70b194050ac74bdb0db842997a8775b81a1b669fc41593491c1fabb4c6002935452068461f40c4daae01ad554cab7f60c282f38b7b3edfdf617f84ea9ab90e66cad434417205e6a68283c7a96b6d8b77438954b990f6b83dd12d4435aeed159e6ae62ed0728ece36b2cc24c972bb53c07f2e7f6d57b5b8dc49808bdbb6d9970aaa9f5130fbc25458f69ad24133232b3faf41ef7b7299f669b882b2ecb63272916ceec560b115397c209102b24bd9588168a1a7e5a5aaa019df9a0277a1e7e7572bcf420c22b87e56c44534cbaef8cb468947202eb7c06b651a236cbcb62488875c6d28c9d582e1e2c4a52cbc8b93b668f1bad28c00b3e1407cdf24f699ab68b797fcaf62df762c1667f1156bed75096c9f951915d04d9b5b2e0c3f76e745c54b855d102aae64deab2c365ce0aaed73ad2524bf7ee75e1201220e749a32ebd33aa0157ca72bea8c16bcf84df44c087d2ebe2e0a9f398f41fbce336f2b4a048fc7456fe67f50d18039a1d139fee5864d33e4f7c4298a8171635cf23bb759663c7e887a723372c0ef8b01cd68e1ee3c3b4abef6811bbc903a835ea8dde76683ece3e02746433db75f18b953f60997bc6c00bc64df4b5f76eb15bd56ba071b23cbeb30ad67cf3d6ec8181b3b30e154bc507ca214486dff2af10cc7960a2765a36741f5086a0b3e39468998897ce40dbeb99387d9b8ab33f660eb474532fc7011dee85f43b40e7f2f","isRememberEnabled":true,"rememberDurationInDays":0,"staticryptSaltUniqueVariableName":"764f9720f93b348c3b33f8905cdacc21"};

            // you can edit these values to customize some of the behavior of StatiCrypt
            const templateConfig = {
                rememberExpirationKey: "staticrypt_expiration",
                rememberPassphraseKey: "staticrypt_passphrase",
                replaceHtmlCallback: null,
                clearLocalStorageCallback: null,
            };

            // init the staticrypt engine
            const staticrypt = staticryptInitiator.init(staticryptConfig, templateConfig);

            // try to automatically decrypt on load if there is a saved password
            window.onload = async function () {
                const { isSuccessful } = await staticrypt.handleDecryptOnLoad();

                // if we didn't decrypt anything on load, show the password prompt. Otherwise the content has already been
                // replaced, no need to do anything
                if (!isSuccessful) {
                    // hide loading screen
                    document.getElementById("staticrypt_loading").classList.add("hidden");
                    document.getElementById("staticrypt_content").classList.remove("hidden");
                    document.getElementById("staticrypt-password").focus();

                    // show the remember me checkbox
                    if (isRememberEnabled) {
                        document.getElementById("staticrypt-remember-label").classList.remove("hidden");
                    }
                }
            };

            // toggle password visibility
            const toggleIcon = document.querySelector(".staticrypt-toggle-password-visibility");
            // these two icons are coming from FontAwesome
            const imgSrcEyeClosed =
                "data:image/svg+xml;base64,PHN2ZyB4bWxucz0iaHR0cDovL3d3dy53My5vcmcvMjAwMC9zdmciIHZpZXdCb3g9IjAgMCA2NDAgNTEyIj48IS0tIUZvbnQgQXdlc29tZSBGcmVlIDYuNS4yIGJ5IEBmb250YXdlc29tZSAtIGh0dHBzOi8vZm9udGF3ZXNvbWUuY29tIExpY2Vuc2UgLSBodHRwczovL2ZvbnRhd2Vzb21lLmNvbS9saWNlbnNlL2ZyZWUgQ29weXJpZ2h0IDIwMjQgRm9udGljb25zLCBJbmMuLS0+PHBhdGggZD0iTTM4LjggNS4xQzI4LjQtMy4xIDEzLjMtMS4yIDUuMSA5LjJTLTEuMiAzNC43IDkuMiA0Mi45bDU5MiA0NjRjMTAuNCA4LjIgMjUuNSA2LjMgMzMuNy00LjFzNi4zLTI1LjUtNC4xLTMzLjdMNTI1LjYgMzg2LjdjMzkuNi00MC42IDY2LjQtODYuMSA3OS45LTExOC40YzMuMy03LjkgMy4zLTE2LjcgMC0yNC42Yy0xNC45LTM1LjctNDYuMi04Ny43LTkzLTEzMS4xQzQ2NS41IDY4LjggNDAwLjggMzIgMzIwIDMyYy02OC4yIDAtMTI1IDI2LjMtMTY5LjMgNjAuOEwzOC44IDUuMXpNMjIzLjEgMTQ5LjVDMjQ4LjYgMTI2LjIgMjgyLjcgMTEyIDMyMCAxMTJjNzkuNSAwIDE0NCA2NC41IDE0NCAxNDRjMCAyNC45LTYuMyA0OC4zLTE3LjQgNjguN0w0MDggMjk0LjVjOC40LTE5LjMgMTAuNi00MS40IDQuOC02My4zYy0xMS4xLTQxLjUtNDcuOC02OS40LTg4LjYtNzEuMWMtNS44LS4yLTkuMiA2LjEtNy40IDExLjdjMi4xIDYuNCAzLjMgMTMuMiAzLjMgMjAuM2MwIDEwLjItMi40IDE5LjgtNi42IDI4LjNsLTkwLjMtNzAuOHpNMzczIDM4OS45Yy0xNi40IDYuNS0zNC4zIDEwLjEtNTMgMTAuMWMtNzkuNSAwLTE0NC02NC41LTE0NC0xNDRjMC02LjkgLjUtMTMuNiAxLjQtMjAuMkw4My4xIDE2MS41QzYwLjMgMTkxLjIgNDQgMjIwLjggMzQuNSAyNDMuN2MtMy4zIDcuOS0zLjMgMTYuNyAwIDI0LjZjMTQuOSAzNS43IDQ2LjIgODcuNyA5MyAxMzEuMUMxNzQuNSA0NDMuMiAyMzkuMiA0ODAgMzIwIDQ4MGM0Ny44IDAgODkuOS0xMi45IDEyNi4yLTMyLjVMMzczIDM4OS45eiIvPjwvc3ZnPg==";
            const imgSrcEyeOpened =
                "data:image/svg+xml;base64,PHN2ZyB4bWxucz0iaHR0cDovL3d3dy53My5vcmcvMjAwMC9zdmciIHZpZXdCb3g9IjAgMCA1NzYgNTEyIj48IS0tIUZvbnQgQXdlc29tZSBGcmVlIDYuNS4yIGJ5IEBmb250YXdlc29tZSAtIGh0dHBzOi8vZm9udGF3ZXNvbWUuY29tIExpY2Vuc2UgLSBodHRwczovL2ZvbnRhd2Vzb21lLmNvbS9saWNlbnNlL2ZyZWUgQ29weXJpZ2h0IDIwMjQgRm9udGljb25zLCBJbmMuLS0+PHBhdGggZD0iTTI4OCAzMmMtODAuOCAwLTE0NS41IDM2LjgtMTkyLjYgODAuNkM0OC42IDE1NiAxNy4zIDIwOCAyLjUgMjQzLjdjLTMuMyA3LjktMy4zIDE2LjcgMCAyNC42QzE3LjMgMzA0IDQ4LjYgMzU2IDk1LjQgMzk5LjRDMTQyLjUgNDQzLjIgMjA3LjIgNDgwIDI4OCA0ODBzMTQ1LjUtMzYuOCAxOTIuNi04MC42YzQ2LjgtNDMuNSA3OC4xLTk1LjQgOTMtMTMxLjFjMy4zLTcuOSAzLjMtMTYuNyAwLTI0LjZjLTE0LjktMzUuNy00Ni4yLTg3LjctOTMtMTMxLjFDNDMzLjUgNjguOCAzNjguOCAzMiAyODggMzJ6TTE0NCAyNTZhMTQ0IDE0NCAwIDEgMSAyODggMCAxNDQgMTQ0IDAgMSAxIC0yODggMHptMTQ0LTY0YzAgMzUuMy0yOC43IDY0LTY0IDY0Yy03LjEgMC0xMy45LTEuMi0yMC4zLTMuM2MtNS41LTEuOC0xMS45IDEuNi0xMS43IDcuNGMuMyA2LjkgMS4zIDEzLjggMy4yIDIwLjdjMTMuNyA1MS4yIDY2LjQgODEuNiAxMTcuNiA2Ny45czgxLjYtNjYuNCA2Ny45LTExNy42Yy0xMS4xLTQxLjUtNDcuOC02OS40LTg4LjYtNzEuMWMtNS44LS4yLTkuMiA2LjEtNy40IDExLjdjMi4xIDYuNCAzLjMgMTMuMiAzLjMgMjAuM3oiLz48L3N2Zz4=";
            toggleIcon.addEventListener("click", function () {
                const passwordInput = document.getElementById("staticrypt-password");
                if (passwordInput.type === "password") {
                    passwordInput.type = "text";
                    toggleIcon.src = imgSrcEyeOpened;
                    toggleIcon.alt = templateToggleAltHide;
                    toggleIcon.title = templateToggleAltHide;
                } else {
                    passwordInput.type = "password";
                    toggleIcon.src = imgSrcEyeClosed;
                    toggleIcon.alt = templateToggleAltShow;
                    toggleIcon.title = templateToggleAltShow;
                }
            });

            // handle password form submission
            document.getElementById("staticrypt-form").addEventListener("submit", async function (e) {
                e.preventDefault();

                const password = document.getElementById("staticrypt-password").value,
                    isRememberChecked = document.getElementById("staticrypt-remember").checked;

                const { isSuccessful } = await staticrypt.handleDecryptionOfPage(password, isRememberChecked);

                if (!isSuccessful) {
                    alert(templateError);
                }
            });
        </script>
    </body>
</html>
