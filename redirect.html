<!DOCTYPE html>
<html class="staticrypt-html">
    <head>
        <meta charset="utf-8" />
        <title>Edulock</title>
        <meta name="viewport" content="width=device-width, initial-scale=1" />

        <!-- do not cache this page -->
        <meta http-equiv="cache-control" content="max-age=0" />
        <meta http-equiv="cache-control" content="no-cache" />
        <meta http-equiv="expires" content="0" />
        <meta http-equiv="expires" content="Tue, 01 Jan 1980 1:00:00 GMT" />
        <meta http-equiv="pragma" content="no-cache" />

        <style>
            .staticrypt-hr {
                margin-top: 20px;
                margin-bottom: 20px;
                border: 0;
                border-top: 1px solid #eee;
            }

            .staticrypt-page {
                width: 360px;
                padding: 8% 0 0;
                margin: auto;
                box-sizing: border-box;
            }

            .staticrypt-form {
                position: relative;
                z-index: 1;
                background: #ffffff;
                max-width: 360px;
                margin: 0 auto 100px;
                padding: 45px;
                text-align: center;
                box-shadow: 0 0 20px 0 rgba(0, 0, 0, 0.2), 0 5px 5px 0 rgba(0, 0, 0, 0.24);
            }

            .staticrypt-form input[type="password"],
            input[type="text"] {
                background: inherit;
                border: 0;
                box-sizing: border-box; /* This ensures padding is included in the total width */
                font-size: 14px;
                outline: 0;
                padding: 15px 30px 15px 15px; /* Adjust the padding to ensure there is space for the icon */
                width: 100%;
            }

            .staticrypt-password-container {
                position: relative;
                outline: 0;
                background: #f2f2f2;
                width: 100%;
                border: 0;
                margin: 0 0 15px;
                box-sizing: border-box;
            }

            .staticrypt-toggle-password-visibility {
                cursor: pointer;
                height: 20px;
                opacity: 60%;
                padding: 13px;
                position: absolute;
                right: 0;
                top: 50%;
                transform: translateY(-50%);
                width: 20px;
            }

            .staticrypt-form .staticrypt-decrypt-button {
                text-transform: uppercase;
                outline: 0;
                background: #4CAF50;
                width: 100%;
                border: 0;
                padding: 15px;
                color: #ffffff;
                font-size: 14px;
                cursor: pointer;
            }

            .staticrypt-form .staticrypt-decrypt-button:hover,
            .staticrypt-form .staticrypt-decrypt-button:active,
            .staticrypt-form .staticrypt-decrypt-button:focus {
                background: #4CAF50;
                filter: brightness(92%);
            }

            .staticrypt-html {
                height: 100%;
            }

            .staticrypt-body {
                height: 100%;
                margin: 0;
            }

            .staticrypt-content {
                height: 100%;
                margin-bottom: 1em;
                background: #76B852;
                font-family: "Arial", sans-serif;
                -webkit-font-smoothing: antialiased;
                -moz-osx-font-smoothing: grayscale;
            }

            .staticrypt-instructions {
                margin-top: -1em;
                margin-bottom: 1em;
            }

            .staticrypt-title {
                font-size: 1.5em;
            }

            label.staticrypt-remember {
                display: flex;
                align-items: center;
                margin-bottom: 1em;
            }

            .staticrypt-remember input[type="checkbox"] {
                transform: scale(1.5);
                margin-right: 1em;
            }

            .hidden {
                display: none !important;
            }

            .staticrypt-spinner-container {
                height: 100%;
                display: flex;
                align-items: center;
                justify-content: center;
            }

            .staticrypt-spinner {
                display: inline-block;
                width: 2rem;
                height: 2rem;
                vertical-align: text-bottom;
                border: 0.25em solid gray;
                border-right-color: transparent;
                border-radius: 50%;
                -webkit-animation: spinner-border 0.75s linear infinite;
                animation: spinner-border 0.75s linear infinite;
                animation-duration: 0.75s;
                animation-timing-function: linear;
                animation-delay: 0s;
                animation-iteration-count: infinite;
                animation-direction: normal;
                animation-fill-mode: none;
                animation-play-state: running;
                animation-name: spinner-border;
            }

            @keyframes spinner-border {
                100% {
                    transform: rotate(360deg);
                }
            }
        </style>
    </head>

    <body class="staticrypt-body">
        <div id="staticrypt_loading" class="staticrypt-spinner-container">
            <div class="staticrypt-spinner"></div>
        </div>

        <div id="staticrypt_content" class="staticrypt-content hidden">
            <div class="staticrypt-page">
                <div class="staticrypt-form">
                    <div class="staticrypt-instructions">
                        <p class="staticrypt-title">Edulock</p>
                        <p><p>Text you-know-who (definitely Voldemort) for the password</p>
</p>
                    </div>

                    <hr class="staticrypt-hr" />

                    <form id="staticrypt-form" action="#" method="post">
                        <div class="staticrypt-password-container">
                            <input
                                id="staticrypt-password"
                                type="password"
                                name="password"
                                placeholder="Password"
                                autofocus
                            />

                            <img
                                class="staticrypt-toggle-password-visibility"
                                alt="template_toggle_show"
                                title="template_toggle_show"
                                src="data:image/svg+xml;base64,PHN2ZyB4bWxucz0iaHR0cDovL3d3dy53My5vcmcvMjAwMC9zdmciIHZpZXdCb3g9IjAgMCA2NDAgNTEyIj48IS0tIUZvbnQgQXdlc29tZSBGcmVlIDYuNS4yIGJ5IEBmb250YXdlc29tZSAtIGh0dHBzOi8vZm9udGF3ZXNvbWUuY29tIExpY2Vuc2UgLSBodHRwczovL2ZvbnRhd2Vzb21lLmNvbS9saWNlbnNlL2ZyZWUgQ29weXJpZ2h0IDIwMjQgRm9udGljb25zLCBJbmMuLS0+PHBhdGggZD0iTTM4LjggNS4xQzI4LjQtMy4xIDEzLjMtMS4yIDUuMSA5LjJTLTEuMiAzNC43IDkuMiA0Mi45bDU5MiA0NjRjMTAuNCA4LjIgMjUuNSA2LjMgMzMuNy00LjFzNi4zLTI1LjUtNC4xLTMzLjdMNTI1LjYgMzg2LjdjMzkuNi00MC42IDY2LjQtODYuMSA3OS45LTExOC40YzMuMy03LjkgMy4zLTE2LjcgMC0yNC42Yy0xNC45LTM1LjctNDYuMi04Ny43LTkzLTEzMS4xQzQ2NS41IDY4LjggNDAwLjggMzIgMzIwIDMyYy02OC4yIDAtMTI1IDI2LjMtMTY5LjMgNjAuOEwzOC44IDUuMXpNMjIzLjEgMTQ5LjVDMjQ4LjYgMTI2LjIgMjgyLjcgMTEyIDMyMCAxMTJjNzkuNSAwIDE0NCA2NC41IDE0NCAxNDRjMCAyNC45LTYuMyA0OC4zLTE3LjQgNjguN0w0MDggMjk0LjVjOC40LTE5LjMgMTAuNi00MS40IDQuOC02My4zYy0xMS4xLTQxLjUtNDcuOC02OS40LTg4LjYtNzEuMWMtNS44LS4yLTkuMiA2LjEtNy40IDExLjdjMi4xIDYuNCAzLjMgMTMuMiAzLjMgMjAuM2MwIDEwLjItMi40IDE5LjgtNi42IDI4LjNsLTkwLjMtNzAuOHpNMzczIDM4OS45Yy0xNi40IDYuNS0zNC4zIDEwLjEtNTMgMTAuMWMtNzkuNSAwLTE0NC02NC41LTE0NC0xNDRjMC02LjkgLjUtMTMuNiAxLjQtMjAuMkw4My4xIDE2MS41QzYwLjMgMTkxLjIgNDQgMjIwLjggMzQuNSAyNDMuN2MtMy4zIDcuOS0zLjMgMTYuNyAwIDI0LjZjMTQuOSAzNS43IDQ2LjIgODcuNyA5MyAxMzEuMUMxNzQuNSA0NDMuMiAyMzkuMiA0ODAgMzIwIDQ4MGM0Ny44IDAgODkuOS0xMi45IDEyNi4yLTMyLjVMMzczIDM4OS45eiIvPjwvc3ZnPg=="
                            />
                        </div>

                        <label id="staticrypt-remember-label" class="staticrypt-remember hidden">
                            <input id="staticrypt-remember" type="checkbox" name="remember" />
                            Remember me
                        </label>

                        <input type="submit" class="staticrypt-decrypt-button" value="DECRYPT" />
                    </form>
                </div>
            </div>
        </div>

        <script>
            // these variables will be filled when generating the file - the template format is 'variable_name'
            const staticryptInitiator = 
            ((function(){
  const exports = {};
  const cryptoEngine = ((function(){
  const exports = {};
  const { subtle } = crypto;

const IV_BITS = 16 * 8;
const HEX_BITS = 4;
const ENCRYPTION_ALGO = "AES-CBC";

/**
 * Translates between utf8 encoded hexadecimal strings
 * and Uint8Array bytes.
 */
const HexEncoder = {
    /**
     * hex string -> bytes
     * @param {string} hexString
     * @returns {Uint8Array}
     */
    parse: function (hexString) {
        if (hexString.length % 2 !== 0) throw "Invalid hexString";
        const arrayBuffer = new Uint8Array(hexString.length / 2);

        for (let i = 0; i < hexString.length; i += 2) {
            const byteValue = parseInt(hexString.substring(i, i + 2), 16);
            if (isNaN(byteValue)) {
                throw "Invalid hexString";
            }
            arrayBuffer[i / 2] = byteValue;
        }
        return arrayBuffer;
    },

    /**
     * bytes -> hex string
     * @param {Uint8Array} bytes
     * @returns {string}
     */
    stringify: function (bytes) {
        const hexBytes = [];

        for (let i = 0; i < bytes.length; ++i) {
            let byteString = bytes[i].toString(16);
            if (byteString.length < 2) {
                byteString = "0" + byteString;
            }
            hexBytes.push(byteString);
        }
        return hexBytes.join("");
    },
};

/**
 * Translates between utf8 strings and Uint8Array bytes.
 */
const UTF8Encoder = {
    parse: function (str) {
        return new TextEncoder().encode(str);
    },

    stringify: function (bytes) {
        return new TextDecoder().decode(bytes);
    },
};

/**
 * Salt and encrypt a msg with a password.
 */
async function encrypt(msg, hashedPassword) {
    // Must be 16 bytes, unpredictable, and preferably cryptographically random. However, it need not be secret.
    // https://developer.mozilla.org/en-US/docs/Web/API/SubtleCrypto/encrypt#parameters
    const iv = crypto.getRandomValues(new Uint8Array(IV_BITS / 8));

    const key = await subtle.importKey("raw", HexEncoder.parse(hashedPassword), ENCRYPTION_ALGO, false, ["encrypt"]);

    const encrypted = await subtle.encrypt(
        {
            name: ENCRYPTION_ALGO,
            iv: iv,
        },
        key,
        UTF8Encoder.parse(msg)
    );

    // iv will be 32 hex characters, we prepend it to the ciphertext for use in decryption
    return HexEncoder.stringify(iv) + HexEncoder.stringify(new Uint8Array(encrypted));
}
exports.encrypt = encrypt;

/**
 * Decrypt a salted msg using a password.
 *
 * @param {string} encryptedMsg
 * @param {string} hashedPassword
 * @returns {Promise<string>}
 */
async function decrypt(encryptedMsg, hashedPassword) {
    const ivLength = IV_BITS / HEX_BITS;
    const iv = HexEncoder.parse(encryptedMsg.substring(0, ivLength));
    const encrypted = encryptedMsg.substring(ivLength);

    const key = await subtle.importKey("raw", HexEncoder.parse(hashedPassword), ENCRYPTION_ALGO, false, ["decrypt"]);

    const outBuffer = await subtle.decrypt(
        {
            name: ENCRYPTION_ALGO,
            iv: iv,
        },
        key,
        HexEncoder.parse(encrypted)
    );

    return UTF8Encoder.stringify(new Uint8Array(outBuffer));
}
exports.decrypt = decrypt;

/**
 * Salt and hash the password so it can be stored in localStorage without opening a password reuse vulnerability.
 *
 * @param {string} password
 * @param {string} salt
 * @returns {Promise<string>}
 */
async function hashPassword(password, salt) {
    // we hash the password in multiple steps, each adding more iterations. This is because we used to allow less
    // iterations, so for backward compatibility reasons, we need to support going from that to more iterations.
    let hashedPassword = await hashLegacyRound(password, salt);

    hashedPassword = await hashSecondRound(hashedPassword, salt);

    return hashThirdRound(hashedPassword, salt);
}
exports.hashPassword = hashPassword;

/**
 * This hashes the password with 1k iterations. This is a low number, we need this function to support backwards
 * compatibility.
 *
 * @param {string} password
 * @param {string} salt
 * @returns {Promise<string>}
 */
function hashLegacyRound(password, salt) {
    return pbkdf2(password, salt, 1000, "SHA-1");
}
exports.hashLegacyRound = hashLegacyRound;

/**
 * Add a second round of iterations. This is because we used to use 1k, so for backwards compatibility with
 * remember-me/autodecrypt links, we need to support going from that to more iterations.
 *
 * @param hashedPassword
 * @param salt
 * @returns {Promise<string>}
 */
function hashSecondRound(hashedPassword, salt) {
    return pbkdf2(hashedPassword, salt, 14000, "SHA-256");
}
exports.hashSecondRound = hashSecondRound;

/**
 * Add a third round of iterations to bring total number to 600k. This is because we used to use 1k, then 15k, so for
 * backwards compatibility with remember-me/autodecrypt links, we need to support going from that to more iterations.
 *
 * @param hashedPassword
 * @param salt
 * @returns {Promise<string>}
 */
function hashThirdRound(hashedPassword, salt) {
    return pbkdf2(hashedPassword, salt, 585000, "SHA-256");
}
exports.hashThirdRound = hashThirdRound;

/**
 * Salt and hash the password so it can be stored in localStorage without opening a password reuse vulnerability.
 *
 * @param {string} password
 * @param {string} salt
 * @param {int} iterations
 * @param {string} hashAlgorithm
 * @returns {Promise<string>}
 */
async function pbkdf2(password, salt, iterations, hashAlgorithm) {
    const key = await subtle.importKey("raw", UTF8Encoder.parse(password), "PBKDF2", false, ["deriveBits"]);

    const keyBytes = await subtle.deriveBits(
        {
            name: "PBKDF2",
            hash: hashAlgorithm,
            iterations,
            salt: UTF8Encoder.parse(salt),
        },
        key,
        256
    );

    return HexEncoder.stringify(new Uint8Array(keyBytes));
}

function generateRandomSalt() {
    const bytes = crypto.getRandomValues(new Uint8Array(128 / 8));

    return HexEncoder.stringify(new Uint8Array(bytes));
}
exports.generateRandomSalt = generateRandomSalt;

async function signMessage(hashedPassword, message) {
    const key = await subtle.importKey(
        "raw",
        HexEncoder.parse(hashedPassword),
        {
            name: "HMAC",
            hash: "SHA-256",
        },
        false,
        ["sign"]
    );
    const signature = await subtle.sign("HMAC", key, UTF8Encoder.parse(message));

    return HexEncoder.stringify(new Uint8Array(signature));
}
exports.signMessage = signMessage;

function getRandomAlphanum() {
    const possibleCharacters = "abcdefghijklmnopqrstuvwxyzABCDEFGHIJKLMNOPQRSTUVWXYZ0123456789";

    let byteArray;
    let parsedInt;

    // Keep generating new random bytes until we get a value that falls
    // within a range that can be evenly divided by possibleCharacters.length
    do {
        byteArray = crypto.getRandomValues(new Uint8Array(1));
        // extract the lowest byte to get an int from 0 to 255 (probably unnecessary, since we're only generating 1 byte)
        parsedInt = byteArray[0] & 0xff;
    } while (parsedInt >= 256 - (256 % possibleCharacters.length));

    // Take the modulo of the parsed integer to get a random number between 0 and totalLength - 1
    const randomIndex = parsedInt % possibleCharacters.length;

    return possibleCharacters[randomIndex];
}

/**
 * Generate a random string of a given length.
 *
 * @param {int} length
 * @returns {string}
 */
function generateRandomString(length) {
    let randomString = "";

    for (let i = 0; i < length; i++) {
        randomString += getRandomAlphanum();
    }

    return randomString;
}
exports.generateRandomString = generateRandomString;

  return exports;
})());
const codec = ((function(){
  const exports = {};
  /**
 * Initialize the codec with the provided cryptoEngine - this return functions to encode and decode messages.
 *
 * @param cryptoEngine - the engine to use for encryption / decryption
 */
function init(cryptoEngine) {
    const exports = {};

    /**
     * Top-level function for encoding a message.
     * Includes password hashing, encryption, and signing.
     *
     * @param {string} msg
     * @param {string} password
     * @param {string} salt
     *
     * @returns {string} The encoded text
     */
    async function encode(msg, password, salt) {
        const hashedPassword = await cryptoEngine.hashPassword(password, salt);

        const encrypted = await cryptoEngine.encrypt(msg, hashedPassword);

        // we use the hashed password in the HMAC because this is effectively what will be used a password (so we can store
        // it in localStorage safely, we don't use the clear text password)
        const hmac = await cryptoEngine.signMessage(hashedPassword, encrypted);

        return hmac + encrypted;
    }
    exports.encode = encode;

    /**
     * Encode using a password that has already been hashed. This is useful to encode multiple messages in a row, that way
     * we don't need to hash the password multiple times.
     *
     * @param {string} msg
     * @param {string} hashedPassword
     *
     * @returns {string} The encoded text
     */
    async function encodeWithHashedPassword(msg, hashedPassword) {
        const encrypted = await cryptoEngine.encrypt(msg, hashedPassword);

        // we use the hashed password in the HMAC because this is effectively what will be used a password (so we can store
        // it in localStorage safely, we don't use the clear text password)
        const hmac = await cryptoEngine.signMessage(hashedPassword, encrypted);

        return hmac + encrypted;
    }
    exports.encodeWithHashedPassword = encodeWithHashedPassword;

    /**
     * Top-level function for decoding a message.
     * Includes signature check and decryption.
     *
     * @param {string} signedMsg
     * @param {string} hashedPassword
     * @param {string} salt
     * @param {int} backwardCompatibleAttempt
     * @param {string} originalPassword
     *
     * @returns {Object} {success: true, decoded: string} | {success: false, message: string}
     */
    async function decode(signedMsg, hashedPassword, salt, backwardCompatibleAttempt = 0, originalPassword = "") {
        const encryptedHMAC = signedMsg.substring(0, 64);
        const encryptedMsg = signedMsg.substring(64);
        const decryptedHMAC = await cryptoEngine.signMessage(hashedPassword, encryptedMsg);

        if (decryptedHMAC !== encryptedHMAC) {
            // we have been raising the number of iterations in the hashing algorithm multiple times, so to support the old
            // remember-me/autodecrypt links we need to try bringing the old hashes up to speed.
            originalPassword = originalPassword || hashedPassword;
            if (backwardCompatibleAttempt === 0) {
                const updatedHashedPassword = await cryptoEngine.hashThirdRound(originalPassword, salt);

                return decode(signedMsg, updatedHashedPassword, salt, backwardCompatibleAttempt + 1, originalPassword);
            }
            if (backwardCompatibleAttempt === 1) {
                let updatedHashedPassword = await cryptoEngine.hashSecondRound(originalPassword, salt);
                updatedHashedPassword = await cryptoEngine.hashThirdRound(updatedHashedPassword, salt);

                return decode(signedMsg, updatedHashedPassword, salt, backwardCompatibleAttempt + 1, originalPassword);
            }

            return { success: false, message: "Signature mismatch" };
        }

        return {
            success: true,
            decoded: await cryptoEngine.decrypt(encryptedMsg, hashedPassword),
        };
    }
    exports.decode = decode;

    return exports;
}
exports.init = init;

  return exports;
})());
const decode = codec.init(cryptoEngine).decode;

/**
 * Initialize the staticrypt module, that exposes functions callbable by the password_template.
 *
 * @param {{
 *  staticryptEncryptedMsgUniqueVariableName: string,
 *  isRememberEnabled: boolean,
 *  rememberDurationInDays: number,
 *  staticryptSaltUniqueVariableName: string,
 * }} staticryptConfig - object of data that is stored on the password_template at encryption time.
 *
 * @param {{
 *  rememberExpirationKey: string,
 *  rememberPassphraseKey: string,
 *  replaceHtmlCallback: function,
 *  clearLocalStorageCallback: function,
 * }} templateConfig - object of data that can be configured by a custom password_template.
 */
function init(staticryptConfig, templateConfig) {
    const exports = {};

    /**
     * Decrypt our encrypted page, replace the whole HTML.
     *
     * @param {string} hashedPassword
     * @returns {Promise<boolean>}
     */
    async function decryptAndReplaceHtml(hashedPassword) {
        const { staticryptEncryptedMsgUniqueVariableName, staticryptSaltUniqueVariableName } = staticryptConfig;
        const { replaceHtmlCallback } = templateConfig;

        const result = await decode(
            staticryptEncryptedMsgUniqueVariableName,
            hashedPassword,
            staticryptSaltUniqueVariableName
        );
        if (!result.success) {
            return false;
        }
        const plainHTML = result.decoded;

        // if the user configured a callback call it, otherwise just replace the whole HTML
        if (typeof replaceHtmlCallback === "function") {
            replaceHtmlCallback(plainHTML);
        } else {
            document.write(plainHTML);
            document.close();
        }

        return true;
    }

    /**
     * Attempt to decrypt the page and replace the whole HTML.
     *
     * @param {string} password
     * @param {boolean} isRememberChecked
     *
     * @returns {Promise<{isSuccessful: boolean, hashedPassword?: string}>} - we return an object, so that if we want to
     *   expose more information in the future we can do it without breaking the password_template
     */
    async function handleDecryptionOfPage(password, isRememberChecked) {
        const { staticryptSaltUniqueVariableName } = staticryptConfig;

        // decrypt and replace the whole page
        const hashedPassword = await cryptoEngine.hashPassword(password, staticryptSaltUniqueVariableName);
        return handleDecryptionOfPageFromHash(hashedPassword, isRememberChecked);
    }
    exports.handleDecryptionOfPage = handleDecryptionOfPage;

    async function handleDecryptionOfPageFromHash(hashedPassword, isRememberChecked) {
        const { isRememberEnabled, rememberDurationInDays } = staticryptConfig;
        const { rememberExpirationKey, rememberPassphraseKey } = templateConfig;

        const isDecryptionSuccessful = await decryptAndReplaceHtml(hashedPassword);

        if (!isDecryptionSuccessful) {
            return {
                isSuccessful: false,
                hashedPassword,
            };
        }

        // remember the hashedPassword and set its expiration if necessary
        if (isRememberEnabled && isRememberChecked) {
            window.localStorage.setItem(rememberPassphraseKey, hashedPassword);

            // set the expiration if the duration isn't 0 (meaning no expiration)
            if (rememberDurationInDays > 0) {
                window.localStorage.setItem(
                    rememberExpirationKey,
                    (new Date().getTime() + rememberDurationInDays * 24 * 60 * 60 * 1000).toString()
                );
            }
        }

        return {
            isSuccessful: true,
            hashedPassword,
        };
    }
    exports.handleDecryptionOfPageFromHash = handleDecryptionOfPageFromHash;

    /**
     * Clear localstorage from staticrypt related values
     */
    function clearLocalStorage() {
        const { clearLocalStorageCallback, rememberExpirationKey, rememberPassphraseKey } = templateConfig;

        if (typeof clearLocalStorageCallback === "function") {
            clearLocalStorageCallback();
        } else {
            localStorage.removeItem(rememberPassphraseKey);
            localStorage.removeItem(rememberExpirationKey);
        }
    }

    async function handleDecryptOnLoad() {
        let isSuccessful = await decryptOnLoadFromUrl();

        if (!isSuccessful) {
            isSuccessful = await decryptOnLoadFromRememberMe();
        }

        return { isSuccessful };
    }
    exports.handleDecryptOnLoad = handleDecryptOnLoad;

    /**
     * Clear storage if we are logging out
     *
     * @returns {boolean} - whether we logged out
     */
    function logoutIfNeeded() {
        const logoutKey = "staticrypt_logout";

        // handle logout through query param
        const queryParams = new URLSearchParams(window.location.search);
        if (queryParams.has(logoutKey)) {
            clearLocalStorage();
            return true;
        }

        // handle logout through URL fragment
        const hash = window.location.hash.substring(1);
        if (hash.includes(logoutKey)) {
            clearLocalStorage();
            return true;
        }

        return false;
    }

    /**
     * To be called on load: check if we want to try to decrypt and replace the HTML with the decrypted content, and
     * try to do it if needed.
     *
     * @returns {Promise<boolean>} true if we derypted and replaced the whole page, false otherwise
     */
    async function decryptOnLoadFromRememberMe() {
        const { rememberDurationInDays } = staticryptConfig;
        const { rememberExpirationKey, rememberPassphraseKey } = templateConfig;

        // if we are login out, terminate
        if (logoutIfNeeded()) {
            return false;
        }

        // if there is expiration configured, check if we're not beyond the expiration
        if (rememberDurationInDays && rememberDurationInDays > 0) {
            const expiration = localStorage.getItem(rememberExpirationKey),
                isExpired = expiration && new Date().getTime() > parseInt(expiration);

            if (isExpired) {
                clearLocalStorage();
                return false;
            }
        }

        const hashedPassword = localStorage.getItem(rememberPassphraseKey);

        if (hashedPassword) {
            // try to decrypt
            const isDecryptionSuccessful = await decryptAndReplaceHtml(hashedPassword);

            // if the decryption is unsuccessful the password might be wrong - silently clear the saved data and let
            // the user fill the password form again
            if (!isDecryptionSuccessful) {
                clearLocalStorage();
                return false;
            }

            return true;
        }

        return false;
    }

    async function decryptOnLoadFromUrl() {
        const passwordKey = "staticrypt_pwd";
        const rememberMeKey = "remember_me";

        // try to get the password from the query param (for backward compatibility - we now want to avoid this method,
        // since it sends the hashed password to the server which isn't needed)
        const queryParams = new URLSearchParams(window.location.search);
        const hashedPasswordQuery = queryParams.get(passwordKey);
        const rememberMeQuery = queryParams.get(rememberMeKey);

        const urlFragment = window.location.hash.substring(1);
        // get the password from the url fragment
        const hashedPasswordRegexMatch = urlFragment.match(new RegExp(passwordKey + "=([^&]*)"));
        const hashedPasswordFragment = hashedPasswordRegexMatch ? hashedPasswordRegexMatch[1] : null;
        const rememberMeFragment = urlFragment.includes(rememberMeKey);

        const hashedPassword = hashedPasswordFragment || hashedPasswordQuery;
        const rememberMe = rememberMeFragment || rememberMeQuery;

        if (hashedPassword) {
            return handleDecryptionOfPageFromHash(hashedPassword, rememberMe);
        }

        return false;
    }

    return exports;
}
exports.init = init;

  return exports;
})());
        ;
            const templateError = "template_error",
                templateToggleAltShow = "template_toggle_show",
                templateToggleAltHide = "template_toggle_hide",
                isRememberEnabled = true,
                staticryptConfig = {"staticryptEncryptedMsgUniqueVariableName":"c7f4e944b66d729450864319cdad61c2159af396bee7de26048a028012c7b7d61e7b6293acff976ab9d4d62b8ac11f536895cc1fa45f5d641dc6e161e6b3cd00d2f9a88545139d52cf38382748308984b5dbd043149e91501d70d8de94862961883f2d6862d7e706c4a34706700eefff348da53e0b6ee687385e0b6f3c873bc0da2f17ae2b0241d45e48b3be0859751a0eb0b714ca1444d990980528a0c5a341aa13f409fd30990cc6a2fe8a94e7ef153aadef3068e90fcf5457a475d68ed1d31f5bfaab2e08fc5d59e0d2000f4c2c743c239bdc77b3a2c830917e342e6a5dfb7d441cf5d3a35591710b774d43b09f223996b831772a176163f8058d9139efbe4bd8a48cedf7a639a3be53fa66f8f71533fcc0ebd0ae0f7149baac9407c22e04f7e54b63c846f51987d1ddd9434bc66ac31374ec209fdaa81e6c0e0f965e9ff9b71b0ccbde97276e117698903cea04537fac619c06122cf96c3983fc2da88eb76f04ed59295e3c205d26556496c8e659ec583726c105756bda1ec8a1d91d973a037980d1743a78e330daa2759f03985c39bf0c38e5817d149715c1d81465098876c0b4a289394f6805d815e12c52b1b789a8ee9d49ae6477271278f47edb4f8fd9f353a4d0efe3a91a7adf8d2529dc56ac66afe6f8c32f46b1a268f74aca2eae0410cb7d430bcfcbf2d6bb8a51a0b521b69f4bafbd4c2a66be251df587389bdd5d530a43e73c62baddb80f42c5b446068cddacd378827f811f383925f1bd85d740afee085b3ef4956fc559d1672a6eba6d445c08939df70da75183ba7970b504de03f888d75fc0157e63330693bcbe09f3cde07eabb5b85d4ca4200f50882cdc1c834821303cb363b22d61668b4b654715c6a54bab715c7b877329679833a627142ef5dd8fa32b539ef6eb98ae56a81966d05f149733bb6b9e0fad4b4b14acbbb76b1126575a11922af21d5d7270c23fc42ebcd44fa3c3897e9d5e342c9cbee56901520ddd8a18abbed508a651596f2dafae3c728d76cf849cc34eff79503ec396048049d81ba973c672e85e3fd7ff330a25907741e15fb5723dc19863354eaa5a91e7e0f45162a67ff0c76c78f988f82093bd2c03d1ed7c38edf248f8bf5821059894c386390dffab2c4f18009a4b212bd38b4eee9e338a0218df5ca0fc2a7a523381274e73b5a8e4cb9ad9d151ae1132cd48aee8f7e2877a520f80803178fe29f709ed70702ff611773ebe9b32b43a003d09bb939aa66bc87884aefc1922a69b3aa83d06e58c99f09435768f11a3ef9055a14b3deac5ef76b242e4ad452345022b0352bdb49d609e5fc3283c6f8cda25d3558a1cc2b48a2bc00b7170994ad372050d47eed7315e262f358ecf67acd26eb1326aa96ec0794cec4cbd696aa4d4079a9ccd738c84a92ef4e24c4c5a48f327a7f155c7ccb8188ba259b1efa402b4224ca0d5126d652133d96b82b6062d5f3fbf81805bd3e8c5e39ace9a9acc7e432b2dce51251a29edf1bb06c11bfbe3a66d1cb4938940a81d1e20b3ce0f9c1ac499e19d3b2d253f28f462fc0571dbf8b7d81fd173f1e9a6fb67812ec7bec528d09a98b7aeebc25084297b7c3ce18641401bff06e1b76a2d55597c52c1f8f8c40c4549a687a327e4e5c0acd96c133ce3a36b08bbda0b7f63cf3611d0ab994869417c789ae3f11686e6dc0141e695c566bedefb5deb15aaae9e772ac4573ad0bb89376beb84f507a8318c842f9871ca013ce73adbf4853d855288abd9e17698133994fb0e5e78a0a855aeaee52154ef5e1224bd6e4c3433845ad17a4306c4008f75fa2a2515b8307276a2658095e6321f51a36b86bee760c6bf03310cf7683878257151d3833ae121975bface7369ec460aab44e03448cd063ea89c454e76d13c79b86337b0b6a967d7734594311f21b9550db8fc9b42ad832a1af283514c646d1e25522809eeaab421f8cacb3e0335e7f04c90136710c323aaecd1e4c43c7a1184218a43d55d2082b0ff6d6662ad58846ea57341a5da13d043dcd55906fc6b87407fa9a205a1063fd5f26196aca4e13315bdedf2b8620549bba54a3b9a91efcc2a77a9db4613360b9a587d75dbef84932eae20f055dda1614e173c7e90654ca0f66eadebd5773102c08d1487fbba7115ae566de6547a86110e1d0a4842db3583defee3837bf938ce08ff99dad44924c18fedfbf86b2557c77c79fd9565f358ce7d1f2d7186a2e8b1e8e9ca947e446d54366e6922659afaefc138ee31ccf3fa0d861258920fb5cce6df63d00d3d2749031ea93a10faa28d8e86163d2e23257bca50a3a9b2c01b3ffb77f8e0dc6211a38cbd826b2c763e9871be0bd8f36643e3ae973366894c0d9f5e21eeeae766a71a9cc516f38597066ee992fdef2b6763849548ef463ba4f180c477cd22e2d49a980f301da2d1b600851cd6ef3182d4ed9692ab8fb9a45c1502b054e8fbdef70d11ed2e8bcbd0ff8148ab2d73450015f9f876bf169ffcf6ee5938c934c21da61bdb375bcb26995d6a96ea715bfb0c77de6617faecb88a049e3cd132bb5720f274d894aa2ee26c0e98fc3fdb6600c347973abe02f6e21d219a3d09d52e593d93c57c5d6ab473abe0480293ed014cf392e92e9e96331de3d0d8a2f8e40dd570fb2d7756164538ce117fe30a688ac1975cc5e28e7827de0d5a4c2a9fc898c200aa2d85c6e4fc09c53573a39d116e146fb30548b8665915fa8e5bdcda26c6e9b4742a8bda2f92b2945383f4721fac747a862ab953b564aa081312c8c38217a319f19a95c78ca05760c5931755525971fd2c63271ffb5b031617eeca8b86cb3c5fdbb7edbf5424454f3ce0145fb2765bcea3bfed786cd7c27c9275b47bbeeecbb2d060349b431172fc50088efd1bb423387b5505a5053f3926db3253c92b14d8af3df2e32cb407ca8f81b1f20d1fecb0b178a175f2163382ffdc2e820c600d49ff7d76d1b5abb13b3c431078b0f674908ae267ed2476ebaf64884de73fe9ccd6c1e8208fda36903ba980f1754a096366796dc3bd2eb6bad6c9f8e054002d2eff97011b985aad438b95f733a4227bb8106e8f460ce8155de14eb15c22ecfa158ba6bbef3d4b222a2d436cd9339c2a8d968b176cacc82fe866a7327078082a52b8e7f42ec0eb2abe6f67a1ddfef9548cc51f127d243406c89ea80149b63b00f5dcf5d1e0dc1f01595588909273dbf1c523ece1626fdf61e56bc40d18b4c9166ca64c3527f4ea42f8f589582b878d9d39cb357c987070aab32f9d23fdbb979a21ffeb7c4183062aee2785e1cba43941c9a730535c348b50b2bf89ae85a3f07530f3c7a2f3dc2057f83b70042f7dede9955c76c7c7b9a63736ec145a8efb249c50286dacec8b347eece66a0e668907acaf410c5b8776e6b5242abf3764063cebbf8478d85472a2521724276f0a6f13409d3ae56e69ab5721c302686c199e5799eec2b56796f40a17966b25232a257d33858bbbc130a94b022be14e6dd65790ef144cc640b765393a97735e84903531c218aab30e2afb4efdd50517f6b51582604194dc52db8e63353e18872fea0e6dfc8cbccf6e48211f714090a0ac04dac9eac9e5dc05f98cca979f0353a9ba6124df3b2e525657d21f5deb081cc585aa991122f4084b69968e3b26b45c8fdd88d1a0e036cf9dc57f266ace14e1d68facb12857bf90515e0c7bb592693b937cb5f38f443b0f85ab7745aae88d7e6f17b0f480e407abc144515b38b047bf4fd2cbc3e4a49bd64406b745d4b69982eae30eafd400bb58658792d43026118ba6ee59d1091be439cc25a53592e46614aa5c68147511dddc6ad4538493c612fac68ad2b1b56c3aed133d62f265bd8e11a53b34470657ca66e8a5b2cda35116f9abbd702c80259d7988ef51ade932ff237acf4b417bfd45e9d3ffc4c386f301884f682447b084a649869942b212c20102732464ba1be1b4a5cbbecf59ea82e2996436d9ce9a4fb39bc729056f21eca5dca51392503d38174f84d94b89024dc8875fdd3aa64b9e58de6e90774ebc8beec550feb77e873f0a9487153cd01ea1fcdc088108f44384da729ee575b9f200078e3796584450f18182739444b61dd6ca702008b39a2978934df8154d94d57448a12f7398613b37382fa6acad77fff6e6e531a0f1d67d7998123cb64bbe451a15894527d03c4449374e2126760cbd89ef30c7f9b69b8c5fcc13870ccd35a93cb96bc16426e48b2e6ff22e7d936397bd9249db20f4f2e3ba9db109ce51c27cdb1ab9e92263a99063298fbad8a15f3e3d650f0b3c9cb0b8cbb66e4088257fd7561b57c1fc33206cf6648c9dc1863b5cbe08dc095c03bd1536a1bfee22844b8e48073690cf39c71c5d534624b662d1a31d93fac781006b065076cb962b43fcfdca961805d985d0e2a8816b99d6b9d138445323d9ffabfe78b7ad69ac82b897b174a1370c161020a0f90d019b57936b656d5bc5a6788c16315fd35b0b8f8b5dcab6ac88c3ddf6457d77931521f977af39d790ffff501464b86e27d0acfe61d9ecd27814735a3764121e349ec7fbb6add7688e5c83a60136b1f98c6fd9c557b9b60fa845c7a481dc198b531129d193c9d1726ec51092a445224967934bdc06107d9779c07872ba66679851a08943112493ccb30b8318c61749d87c548beb211486f07f77f12f0b1e449fa03b6a33e7d6f1a2ef7987ec3b2e06bf6cc294c0673348f7622518289b254a40179a20c846c2fd001be80dfa64263af4784844d9a1b8f3a4c917bda17515e47a44aa1a330d1fa12416fef7cce9842e7ed4e28f065cd11c445c88653fcff9061118f0a9d382fabc7b93c0910b0349d6df6bef88300488a9c303677ad7642d6a601d20c301369ca02ade70f2653f44632d4ffc5a4acf84715c73d121e8140aa4f3e61a26a78b8ff808d8b54c7ee9b6eccfc95535368ce29468d2cb52564e9d38a565154339bc1c0b1f9fd22f07d0a47449e442db7cadcdd64d344d869135c28345ab2de13cac5b9292295da64948cfa24bdee12a33635d4d67afeaeb7a16bda0e5b43ba3e6087572a868ca42316a15d1b4ad3247571055c9f64337d080ad9d6c80ab0d7ccf0cb22eee73aec41cd5df79fb56036b3843454f7d2220d7b83f133a6c749d89cb3765064b24485d901f15f43ce0b18961b97315ef9e4047ad5cc96f9f41c062039c0d17a965c282548529770b211d980fc72f9300412b75881e26dd982fbf36941964e30b6b74c88cc1e93d93b3bde9e9e9cdf0c829c8b7c453cf14ec2c37361df15baca699921493f1f8c6c67e21819d14eebac4405bf6a19d6a5aa778f7a094a12f455688f56bded346a76e49953bab132ddcde221f46a8b516ddae8a82e47f7ee4f6c2c3fefd7b50f98544e137bfb1ecdf73359e64495469d941741eaa66db304dcfa145e31a3f51d614d7f6fc7d32ea83230bc64b38d6a9cce9d650f0e67cd4fde4c4d7a3d1f8c2583c293f2c3677f4c967f2d6d0a722599f18049a5fc664dfed6d16e8c6286edb5a2e9cf774787eaf790c611ead7fe13a8cabb709993cdec09b9c68ea504419a7ae51362b47202bf44464e976ca3ded10803363135e514ece983ce97cf0193b6713a35ffdeeda4efd4d9c04970e43ec0c122d13253f784096f0a290a67dfc79e80b4c504ddd42e47e09b25f1029fbc7b34430180a460855fc1e9200d4a41b70c73c360f02a9d0e816f775bf07a4a19313b18bb4432ffb45cfbdcff4f57207943b73f7ec888c57f12069b72773af269d63129594fdce58dfd35183f242624fb805713687c86277826df6b1841bd4adfbb5fbc397013df3be4c4ad83c13df375f57dc4db4b37924d6bf3fc5057c7ccb0a2505d6101a64b892b4c6c2bce70f8e83cdff85623150f0a6d2a0f3926a4d5e2c8d429c841e1648ab29ca226481c8506d0825ac96b924eebe6266f7d53c5472775c6880c5ffca05011222aaa9f8775781273a1c6a6c9372413d96cabd0fa021dae0332953876c36324c462d1222efc58a5f25e8afec0a5f0ede2fa7d410cc9b0e06a7a302a7bc73eac0ba0293089330e5fe8884a31d458e617297208b2ca86f1f0a0310dbb36b6fe531e966c418a10b5bf748a43bccaa537b74cf364a9c880ec5e0329142c0aeb39502eaab44c7504b8e5148755475325dd449edc2a9268fad6198d4d6b77d519deca8ed3746c3d76905d7dce83b40fcfe8524689b89f0dbf043da0d9c40ee1a089b65e46b1b871b16960a789649ec02ebdfc01bf8cd7d00be740807f8894316f6ec668ad547f55720d3e62bdf3ec47601a588f484f238e54beebfa3dc5b6d9b93c4728c9a45da0827df456fc36e8340425ca57b1b0e236087ac488dd91391b5ba5d6450323b82e3ef22a24be6bd0f43343ada4e68ac35a12a4b7c947f85e5b1512ade703ac621c8418213c866edd5c3ea166ee1682ecc6b9c5f15554ef881955771b1d6ced736fcf2d59995e2ef1534990cca0965b7d536862ac7bef36694d133ec4afaf8440e7dd939ca4c4ccf8ee3fe5e9d06ba83b1cf49c79766ed5bf5120cda3ec2ea727b2a8754c30c0d21a521c0a20c936ba55b72120df8fe2bb1ee8f2f3a0ed61864acd4a03ce158aea5ad5400db19f959ea9aaea7147d0695063e2d4b0ae376d5aefb2195dc896175f238ec9a44e6e47ef5f9179a25e96b7d82f3c05e608f493bc68a57fe9cf9f1bc28188dd21a3ba7d512578f26bfb76f28a930015fe5b6c631de755e10c02f608fec14d0e465aa59889aa006f2d3a0bd7de4216b97785351b4ad83ac49a5cd6dd29f660e0e6302813dfb54a10b4523d3d76cbd8e163208b7e9200c5e9df0327d6f2c00de40317959bfc45da54200db4bfa2449c56a4ae4cf71690dfe85ac19c0205c068fe52f07f0a353f39df32f86b2b98f0653ca8b6b9eeb56aef5cae77287ec06786722edc53c17e0e9b6f270ccbcbfde780be2c1b8eebee4924f45a9838b32330e0a8ca28394ae400d1f352e4774e45ff256948e0e95fd49ad7f648f3d08b359010ca6c028a7c026dc9103436c6b646919168a901497f72c1d92b75058f3f472a955e7fbd70c5ea02ecf5b24696a2579e8226d070f0743960bc62a54780e6fa8cd48454a92df56a97d884923c61e931f34565e86581f626cb6471cc9f6ab3ea83b0976cc1ebda7bf61406c04ab926489645eb75e54174156203e03140cee5af7d40474efc4bba3ab51ab6b0ca0ce101cf043af724bd961761fa59599599ae6396544bf26e5f672a711d3face87607ec88cc864be7a8c2719e5dc3234dd40dd80856572262b0ba602c1ae4f1568cdd78a576c32e8e1830bb23c5b5f86d7dd3fc201b0463d0867620c46351514cc387a2ccdff834df8c57fe4b247425a30b7b89788121bab4605d63e82b020dc636747ca1bdbe4a3ccc485898341f51da2da07d6b3783d014fbc69c2c19fa88ea0bac6a70e7530fcf4166d9063dbcdd4e69d9670c19dd04b8bb6689049da3e94fa23d1e1f46fefe3459c6b457871b1d824550af5127854166dbb9ce462a06eb360b12df915a308a7a47af584f01429d78a9ac4b1d0e97c0c59f7135804d4b8deba7567176eacf21ddd53a83a22719af7656158e96fdddba1bb35e140b8fea96d47049c1764b0c7e87086dd59278538d197f046dd6cf369c1be7bc907365ef12f7857f50a19242ba77766b1f2372af8080b733ce708d81ce2ba73778e80158777b21660bfc2597960faa7afd4454f0abce954d5174576ce2605cccdaa98896b2bb75426f10ff8a377016c9336420e5b3a1bd1191d279fdf823a3a1d39fcd40ae18ed32bf663c6fdf60a3e0a796068dc1f228be77830fe7234e379dcba1e21c8b225f85f321465c9963e19be52f8dc1e3af4987ffc0770ce8406482ffbd36038536801aa5199f16cd3c53c1947a083c575021c5257e83639d13a68f555d8864a1bfdc502c21fbac278a92e65be00d073bc3cd255b8534b4623a67901a2cae01bf7e8ef89f9f790d3ba60a70f9296e4c1426950d53b3f9a8f3a8641ca124f4ac2cd39dfe795629ef7927e4e61a2f476d951463e7fba2c31dce749e4917cd7216ca4db4e3ed0cc59e733a5cf449e7ebdd89ecbd69ab7ee52698f233c1aab7f1ab333f7bf7f33a51643a1919b6d0c7e90d0c45db49f922bae73dd95a9fadf5427dc3e6b1a08c0c840081e1cba7c8990a562cfb8f7d29c4a35a9166ca6ba499639dd2aeec8e7b4a7fca15c2777bb6f82b01d354a9ba50339ff8ba0b2374b6a5ac4a584d5eeb7697059729599b669cccd760d238d7c234cc8bbc400d5b622d1b984cee5dc515108ad079b424fa40eadb478a4c3793acd701427e7808f43bdf22bfef6e840a563b8fd45e3cfe66ab94d526e4d3c7a7d96c7ec2db82bedc46cfca3b5c61235b56981cabf35650014725d398b6cef70f914b3285bac721020f7c8eea5e5daa88a3efa68a29e993b351dc7c6deb005656b3d7f66a504f242e980e466a99bad55af3b576d371d176e325d1d60dd039c1d8877dd8904ffeffe941a13a9a7319f658ab83433381115b96c9248ca90db5c3757be51f1462b3ced9ba0d28d0495b6df9457c102e95eaeb666f7ce38b9188e79f22cee7920369e3674644dad5a42071cf88c16d3ecce6a9fcec7832537600e5269ab3cd48529127ede874fd3e48755c983449eb1bf9c4d12e92635fe15a81b0bff987aa3840433829517310618d27c5df21b5a2b0d3e9ab4174193f7a11ebe5534c7188742f45de15988c0122e783883745b29fbbe5a493ef338b1ad6a9b03e2960328a4e80623cca5c1a590b7e1234900d71e41a8c713a3e012c4a1237a49e672bce0b6821f6b3074d52e4746138a3fc54aa6444d61990df44503b2b1d5226e599f42cbb3b1c4e647f5859c76f6a4aad7f28a8a1e49167e523d2a9e40282a6e6693a66b6a1b9fbc099223021348efdaf78cefa22c2cc3d471b250725d3d92aaa35acd10906bb5df9998dea2d0487d11605919f6e0f7c35d761f93ba5ad52ec0a6feee82d5616537f540ad7604fb4afa3e788e012b1b6e2d87e44ed320bd606e1aa180135f53e6710462c60f57afc0fbfa3ab9f9e6a42764b5068f6c75f1fcc82d1f77eddffbbe742a5316d4f5a550238f4bed3ca170de29b3fbf4792e8eeb5d188d11653f820f90ca4393206ca9b037f0dd2095cf2b04317ccda7d25facf514de0fe029b0b91ac746f4c3f3594c2089840d7d3c3ac76bd0e6cf6194bc71357d0cae54a35881e8fb5a1ac3fba15b5ea1f1da1ba3492eb12124d98f5587740735537938351cc3591eab81ddceed7561f4c0f22977d53a4f8febae711cdba8645b0021b93b57998efd9ff4cea2503b59c3d5f3a93abca62a7641b078b20f5e110e6e0f2d36bc82c8f715ab7c8f93a98f5796048d652ff3aae8d19a22ad13041afb4d6094ea09081bc53abf3f25cd46e1d80f39ac7c63e8d5c1b80de2f44b8280d4727ab9b53e09b712c61a7fb24736c2b6d4843838e0e45f172c8576164bdeb6d26040c561f9d7fbcaa7690f80f35b8c9a9022ce3e9441f15f8e9ea20edb9956f94b464787f2357982e62ea6853db752614bd625a0d8bd56112af68fdc59d028ce415a635d99b569c7e7458fe2d0f29c2d9a5b55de45a276d89c9d54b3a186961f69b3466dcb40d1a7a58d6a903fba0b547ab28495d0b92389ceefd4d74ffba2e5abc1dab8645f5f071ca663a7e2bd58415a2d0db76e3ba80a81f4b3aeaa6787c4fdca862b5a7fecdc90da69d4b28ae75d284e1d9a73998d826c878672a9338a077f176470121c3c64b534fea5568a1374e1b21d92c088767d43264a397d1cbba738d02c7bdd5483944989b7b5d86f961a3de885df40e6aec9872031aa7e490f5e9c834503cc3baa15a892c7d7b4e32ff1324e78e3bafc4718d6ee524ef5470930679661a7e7e2722cdd9347c8c6924694d9aa8b4d4c0cf844bc784a50e8a7f7dd46a4f1775e0081f462b0aa544dbc083439871b7d2fa7fa089b0ede8ed4a60e2529254d17049f3c30ec4e01171afda4fb35fed1d9bfc333e95a577868874d237d0f3d3f4789eeea2a20f35945277e278f0195658ab0419eb6abb6e96603b23cb48b0869daca84b6709df93474af64a96663662153106c560755aeaac4a9bee5b78082672f92ebc57d82e7b0401a78b3ea70cc20e753cac272975b7a006a0b536ce2ad3ad52bf2d8da3a485cb4d6bc2269dc37fcbc6a56b98b4e20170edc5af2ec189a7ecac998e9515a7a8e2fda94edc2c6f215850df83d7a3f4cd9abcf6363beb913625980069f2f84e4813921a0df77ea8620a551154cad4e1f17b07130525571b3c24cb2f7f4435906b31dcb2b7d4a2e40ad2a12ec42144d7f339eaf63cffffeedeafa963b9d6d700b64cfcec6048233eca065a195a8e9ceced2bf19bfd15f32e4b7592c286c3f568f44d20e6d090600e1dba3f234552e2e9064e1a1c25fb3f6ca53c95478aee88edd37f6136423575495b7d6771a4dbe0db03b32828f7d957e9cb5bb1cabffa9fd7382b8ea234db8708b2fe7db2d54fb128cfba9a073428bfc66d2bbc15f1c1373e08aa808fc217572fa5b987d37b77ea43111f18c54f7649827fd31ad02d955dfc7a976cffb8918d7d7b5c21f355385692c18d408876d2b8d8a9b3f0ef46c65b641431951aef4d1f5f096864fca575850c763e80f3db7ab74f0dec5d88d738bc58c961fc3c7a146fc3ded47cec95fdbc3ec882516a62c105d08243cfb3e7eaaa3904a66e2e462f2c6e94cf40c7ba11f9f7925afa00893bd3952653cf8b7199420c93fccef648e7c69686ef3b0981bbd9edb983d03165e7c0a61105a5a000be2c643b3fc3995b4f32a6dcc2e80b993decf28aaa6c85bf379454d0d58d5761fb01e9e7d0c57c0312a54e553b0b6212b77c5651b9531924b1ceb917105126d2a290e46924947280b768cd20cb1ac14ff178923f0cfaab43a79833a296e8d0338b2bc6c46971421d9e7a4ca06cc356f0b4fcc370b9ff71d03ef8ba7c68c8a9b12bb7dc04831470a5a3d17af94f0c1421d15c15f7d9363329c0ef13692b4b90919620caa167076f207a1b7cbfed292fdf83e0d30ac1b48aaba183b32bf725bab7d0fabcfa5198d30063422b32ef2cda5c3ec7813a7d11ecb2513de978002e090a6678d780590772a57653f9a5e698f72e0c4e17cca6bc5564b26dfed4220d3fdd8ef2cb7848c33a291280fd729f391cd033cfad8b76719115cbcde4a61492d4a813f29a18070ea5c191b1802e7ccda2946f2a55de85190955d2ed049073e182ad40f2877813211e5ff0d5813512e8146bb203189cb6b98a63de679a406a2b268fc0baf1b243e7ee06836343b3a587645d196c7cca5e3adaf0000fd0d579cba8b80c7cb2871482619332f00292091a40013adc101e2ed9be7c38d5a2e60ea06090cdc73839ce80173061c60bfa3aed883a461817f8966b1cdfb1e55b446fcdb4ed39587053ed5150967edceddf263dc9eb523b436988bf9f84ff3e53275c62b2aab0675744f4aeb4aec0e519e0b65317283f1ba00f5b7c5b06d47c6b864d723737e6e9ad77234c753088031a7e6e0736fbbd81ef08a95c730c8b784454a47721fd003b50d9ff9b54cb13b4ef7fc90ddb0957f7dc5e41d2beb94de276dc7f79718fb9d514abcc39de8fe5d504cfb40f899c773168658dc0ee634e5608960342f0288e4cae78505b7c508193dbdc627e47c61841387be34867dfc36bdae11959f0b03c7c485e4b1a5dbfb95b4978183e5502152339d6abe06b303c07ee7bfca1aa12cd84825d155aa62b6db0409748cfaf4515ee2ca93c7cc8dca33b3266a93351866140bd3fdb3bfb5bd84b3a42309eb5d994fab97cb52b99e2b5cd48f856453f3b5fcb6a2728e12df0b849d066d53a311edd59f82ed7c7caee79db35905351adca08da7364cbec58850fb617a396555acadfb56826622f0bf75bb512d99fe65372caafafbb37b662670c446a38a8299ef06b99ded56ee9cdda86ad4df2f18e2acfc9e736e37ccc285cfc2349a2db912c9e1f5304e96d23d2040393fbc3e142d02c11aa1d114297c597cc6f19b199a3e848824549a895b5733c7ec70679a54e7da8bffc4282f10fe40ca1ef130adb543b48b79580b02fbb946f56c728dbccb2c66f09a9100617d6ca5a9a3a1e82776f110d104463e9efd55462eb0484ed58d766c6f3850f42d6c4f241a1597a9e8badef4aa3bd55b205c4189060b32076fa759a52a43451c8a4fb964489f4572010679cd4bd6af440c0234d0e2b90f9b584bd0e1f6745860","isRememberEnabled":true,"rememberDurationInDays":0,"staticryptSaltUniqueVariableName":"7b321ec33569d77923ec413c8c546f9a"};

            // you can edit these values to customize some of the behavior of StatiCrypt
            const templateConfig = {
                rememberExpirationKey: "staticrypt_expiration",
                rememberPassphraseKey: "staticrypt_passphrase",
                replaceHtmlCallback: null,
                clearLocalStorageCallback: null,
            };

            // init the staticrypt engine
            const staticrypt = staticryptInitiator.init(staticryptConfig, templateConfig);

            // try to automatically decrypt on load if there is a saved password
            window.onload = async function () {
                const { isSuccessful } = await staticrypt.handleDecryptOnLoad();

                // if we didn't decrypt anything on load, show the password prompt. Otherwise the content has already been
                // replaced, no need to do anything
                if (!isSuccessful) {
                    // hide loading screen
                    document.getElementById("staticrypt_loading").classList.add("hidden");
                    document.getElementById("staticrypt_content").classList.remove("hidden");
                    document.getElementById("staticrypt-password").focus();

                    // show the remember me checkbox
                    if (isRememberEnabled) {
                        document.getElementById("staticrypt-remember-label").classList.remove("hidden");
                    }
                }
            };

            // toggle password visibility
            const toggleIcon = document.querySelector(".staticrypt-toggle-password-visibility");
            // these two icons are coming from FontAwesome
            const imgSrcEyeClosed =
                "data:image/svg+xml;base64,PHN2ZyB4bWxucz0iaHR0cDovL3d3dy53My5vcmcvMjAwMC9zdmciIHZpZXdCb3g9IjAgMCA2NDAgNTEyIj48IS0tIUZvbnQgQXdlc29tZSBGcmVlIDYuNS4yIGJ5IEBmb250YXdlc29tZSAtIGh0dHBzOi8vZm9udGF3ZXNvbWUuY29tIExpY2Vuc2UgLSBodHRwczovL2ZvbnRhd2Vzb21lLmNvbS9saWNlbnNlL2ZyZWUgQ29weXJpZ2h0IDIwMjQgRm9udGljb25zLCBJbmMuLS0+PHBhdGggZD0iTTM4LjggNS4xQzI4LjQtMy4xIDEzLjMtMS4yIDUuMSA5LjJTLTEuMiAzNC43IDkuMiA0Mi45bDU5MiA0NjRjMTAuNCA4LjIgMjUuNSA2LjMgMzMuNy00LjFzNi4zLTI1LjUtNC4xLTMzLjdMNTI1LjYgMzg2LjdjMzkuNi00MC42IDY2LjQtODYuMSA3OS45LTExOC40YzMuMy03LjkgMy4zLTE2LjcgMC0yNC42Yy0xNC45LTM1LjctNDYuMi04Ny43LTkzLTEzMS4xQzQ2NS41IDY4LjggNDAwLjggMzIgMzIwIDMyYy02OC4yIDAtMTI1IDI2LjMtMTY5LjMgNjAuOEwzOC44IDUuMXpNMjIzLjEgMTQ5LjVDMjQ4LjYgMTI2LjIgMjgyLjcgMTEyIDMyMCAxMTJjNzkuNSAwIDE0NCA2NC41IDE0NCAxNDRjMCAyNC45LTYuMyA0OC4zLTE3LjQgNjguN0w0MDggMjk0LjVjOC40LTE5LjMgMTAuNi00MS40IDQuOC02My4zYy0xMS4xLTQxLjUtNDcuOC02OS40LTg4LjYtNzEuMWMtNS44LS4yLTkuMiA2LjEtNy40IDExLjdjMi4xIDYuNCAzLjMgMTMuMiAzLjMgMjAuM2MwIDEwLjItMi40IDE5LjgtNi42IDI4LjNsLTkwLjMtNzAuOHpNMzczIDM4OS45Yy0xNi40IDYuNS0zNC4zIDEwLjEtNTMgMTAuMWMtNzkuNSAwLTE0NC02NC41LTE0NC0xNDRjMC02LjkgLjUtMTMuNiAxLjQtMjAuMkw4My4xIDE2MS41QzYwLjMgMTkxLjIgNDQgMjIwLjggMzQuNSAyNDMuN2MtMy4zIDcuOS0zLjMgMTYuNyAwIDI0LjZjMTQuOSAzNS43IDQ2LjIgODcuNyA5MyAxMzEuMUMxNzQuNSA0NDMuMiAyMzkuMiA0ODAgMzIwIDQ4MGM0Ny44IDAgODkuOS0xMi45IDEyNi4yLTMyLjVMMzczIDM4OS45eiIvPjwvc3ZnPg==";
            const imgSrcEyeOpened =
                "data:image/svg+xml;base64,PHN2ZyB4bWxucz0iaHR0cDovL3d3dy53My5vcmcvMjAwMC9zdmciIHZpZXdCb3g9IjAgMCA1NzYgNTEyIj48IS0tIUZvbnQgQXdlc29tZSBGcmVlIDYuNS4yIGJ5IEBmb250YXdlc29tZSAtIGh0dHBzOi8vZm9udGF3ZXNvbWUuY29tIExpY2Vuc2UgLSBodHRwczovL2ZvbnRhd2Vzb21lLmNvbS9saWNlbnNlL2ZyZWUgQ29weXJpZ2h0IDIwMjQgRm9udGljb25zLCBJbmMuLS0+PHBhdGggZD0iTTI4OCAzMmMtODAuOCAwLTE0NS41IDM2LjgtMTkyLjYgODAuNkM0OC42IDE1NiAxNy4zIDIwOCAyLjUgMjQzLjdjLTMuMyA3LjktMy4zIDE2LjcgMCAyNC42QzE3LjMgMzA0IDQ4LjYgMzU2IDk1LjQgMzk5LjRDMTQyLjUgNDQzLjIgMjA3LjIgNDgwIDI4OCA0ODBzMTQ1LjUtMzYuOCAxOTIuNi04MC42YzQ2LjgtNDMuNSA3OC4xLTk1LjQgOTMtMTMxLjFjMy4zLTcuOSAzLjMtMTYuNyAwLTI0LjZjLTE0LjktMzUuNy00Ni4yLTg3LjctOTMtMTMxLjFDNDMzLjUgNjguOCAzNjguOCAzMiAyODggMzJ6TTE0NCAyNTZhMTQ0IDE0NCAwIDEgMSAyODggMCAxNDQgMTQ0IDAgMSAxIC0yODggMHptMTQ0LTY0YzAgMzUuMy0yOC43IDY0LTY0IDY0Yy03LjEgMC0xMy45LTEuMi0yMC4zLTMuM2MtNS41LTEuOC0xMS45IDEuNi0xMS43IDcuNGMuMyA2LjkgMS4zIDEzLjggMy4yIDIwLjdjMTMuNyA1MS4yIDY2LjQgODEuNiAxMTcuNiA2Ny45czgxLjYtNjYuNCA2Ny45LTExNy42Yy0xMS4xLTQxLjUtNDcuOC02OS40LTg4LjYtNzEuMWMtNS44LS4yLTkuMiA2LjEtNy40IDExLjdjMi4xIDYuNCAzLjMgMTMuMiAzLjMgMjAuM3oiLz48L3N2Zz4=";
            toggleIcon.addEventListener("click", function () {
                const passwordInput = document.getElementById("staticrypt-password");
                if (passwordInput.type === "password") {
                    passwordInput.type = "text";
                    toggleIcon.src = imgSrcEyeOpened;
                    toggleIcon.alt = templateToggleAltHide;
                    toggleIcon.title = templateToggleAltHide;
                } else {
                    passwordInput.type = "password";
                    toggleIcon.src = imgSrcEyeClosed;
                    toggleIcon.alt = templateToggleAltShow;
                    toggleIcon.title = templateToggleAltShow;
                }
            });

            // handle password form submission
            document.getElementById("staticrypt-form").addEventListener("submit", async function (e) {
                e.preventDefault();

                const password = document.getElementById("staticrypt-password").value,
                    isRememberChecked = document.getElementById("staticrypt-remember").checked;

                const { isSuccessful } = await staticrypt.handleDecryptionOfPage(password, isRememberChecked);

                if (!isSuccessful) {
                    alert(templateError);
                }
            });
        </script>
    </body>
</html>
