<!DOCTYPE html>
<html class="staticrypt-html">
    <head>
        <meta charset="utf-8" />
        <title>eaglenetwork</title>
        <meta name="viewport" content="width=device-width, initial-scale=1" />

        <!-- do not cache this page -->
        <meta http-equiv="cache-control" content="max-age=0" />
        <meta http-equiv="cache-control" content="no-cache" />
        <meta http-equiv="expires" content="0" />
        <meta http-equiv="expires" content="Tue, 01 Jan 1980 1:00:00 GMT" />
        <meta http-equiv="pragma" content="no-cache" />

        <style>
            .staticrypt-hr {
                margin-top: 20px;
                margin-bottom: 20px;
                border: 0;
                border-top: 1px solid #eee;
            }

            .staticrypt-page {
                width: 360px;
                padding: 8% 0 0;
                margin: auto;
                box-sizing: border-box;
            }

            .staticrypt-form {
                position: relative;
                z-index: 1;
                background: #ffffff;
                max-width: 360px;
                margin: 0 auto 100px;
                padding: 45px;
                text-align: center;
                box-shadow: 0 0 20px 0 rgba(0, 0, 0, 0.2), 0 5px 5px 0 rgba(0, 0, 0, 0.24);
            }

            .staticrypt-form input[type="password"] {
                outline: 0;
                background: #f2f2f2;
                width: 100%;
                border: 0;
                margin: 0 0 15px;
                padding: 15px;
                box-sizing: border-box;
                font-size: 14px;
            }

            .staticrypt-form .staticrypt-decrypt-button {
                text-transform: uppercase;
                outline: 0;
                background: #4CAF50;
                width: 100%;
                border: 0;
                padding: 15px;
                color: #ffffff;
                font-size: 14px;
                cursor: pointer;
            }

            .staticrypt-form .staticrypt-decrypt-button:hover,
            .staticrypt-form .staticrypt-decrypt-button:active,
            .staticrypt-form .staticrypt-decrypt-button:focus {
                background: #4CAF50;
                filter: brightness(92%);
            }

            .staticrypt-html {
                height: 100%;
            }

            .staticrypt-body {
                height: 100%;
                margin: 0;
            }

            .staticrypt-content {
                height: 100%;
                margin-bottom: 1em;
                background: #76B852;
                font-family: "Arial", sans-serif;
                -webkit-font-smoothing: antialiased;
                -moz-osx-font-smoothing: grayscale;
            }

            .staticrypt-instructions {
                margin-top: -1em;
                margin-bottom: 1em;
            }

            .staticrypt-title {
                font-size: 1.5em;
            }

            label.staticrypt-remember {
                display: flex;
                align-items: center;
                margin-bottom: 1em;
            }

            .staticrypt-remember input[type="checkbox"] {
                transform: scale(1.5);
                margin-right: 1em;
            }

            .hidden {
                display: none !important;
            }

            .staticrypt-spinner-container {
                height: 100%;
                display: flex;
                align-items: center;
                justify-content: center;
            }

            .staticrypt-spinner {
                display: inline-block;
                width: 2rem;
                height: 2rem;
                vertical-align: text-bottom;
                border: 0.25em solid gray;
                border-right-color: transparent;
                border-radius: 50%;
                -webkit-animation: spinner-border 0.75s linear infinite;
                animation: spinner-border 0.75s linear infinite;
                animation-duration: 0.75s;
                animation-timing-function: linear;
                animation-delay: 0s;
                animation-iteration-count: infinite;
                animation-direction: normal;
                animation-fill-mode: none;
                animation-play-state: running;
                animation-name: spinner-border;
            }

            @keyframes spinner-border {
                100% {
                    transform: rotate(360deg);
                }
            }
        </style>
    </head>

    <body class="staticrypt-body">
        <div id="staticrypt_loading" class="staticrypt-spinner-container">
            <div class="staticrypt-spinner"></div>
        </div>

        <div id="staticrypt_content" class="staticrypt-content hidden">
            <div class="staticrypt-page">
                <div class="staticrypt-form">
                    <div class="staticrypt-instructions">
                        <p class="staticrypt-title">eaglenetwork</p>
                        <p><p>this is an app specifically designed for&nbsp;<strong>studying</strong></p>
</p>
                    </div>

                    <hr class="staticrypt-hr" />

                    <form id="staticrypt-form" action="#" method="post">
                        <input
                            id="staticrypt-password"
                            type="password"
                            name="password"
                            placeholder="enter password"
                            autofocus
                        />

                        <label id="staticrypt-remember-label" class="staticrypt-remember hidden">
                            <input id="staticrypt-remember" type="checkbox" name="remember" />
                            stay logged in
                        </label>

                        <input type="submit" class="staticrypt-decrypt-button" value="decrypt" />
                    </form>
                </div>
            </div>
        </div>

        <script>
            // these variables will be filled when generating the file - the template format is 'variable_name'
            const staticryptInitiator = 
            ((function(){
  const exports = {};
  const cryptoEngine = ((function(){
  const exports = {};
  const { subtle } = crypto;

const IV_BITS = 16 * 8;
const HEX_BITS = 4;
const ENCRYPTION_ALGO = "AES-CBC";

/**
 * Translates between utf8 encoded hexadecimal strings
 * and Uint8Array bytes.
 */
const HexEncoder = {
    /**
     * hex string -> bytes
     * @param {string} hexString
     * @returns {Uint8Array}
     */
    parse: function (hexString) {
        if (hexString.length % 2 !== 0) throw "Invalid hexString";
        const arrayBuffer = new Uint8Array(hexString.length / 2);

        for (let i = 0; i < hexString.length; i += 2) {
            const byteValue = parseInt(hexString.substring(i, i + 2), 16);
            if (isNaN(byteValue)) {
                throw "Invalid hexString";
            }
            arrayBuffer[i / 2] = byteValue;
        }
        return arrayBuffer;
    },

    /**
     * bytes -> hex string
     * @param {Uint8Array} bytes
     * @returns {string}
     */
    stringify: function (bytes) {
        const hexBytes = [];

        for (let i = 0; i < bytes.length; ++i) {
            let byteString = bytes[i].toString(16);
            if (byteString.length < 2) {
                byteString = "0" + byteString;
            }
            hexBytes.push(byteString);
        }
        return hexBytes.join("");
    },
};

/**
 * Translates between utf8 strings and Uint8Array bytes.
 */
const UTF8Encoder = {
    parse: function (str) {
        return new TextEncoder().encode(str);
    },

    stringify: function (bytes) {
        return new TextDecoder().decode(bytes);
    },
};

/**
 * Salt and encrypt a msg with a password.
 */
async function encrypt(msg, hashedPassword) {
    // Must be 16 bytes, unpredictable, and preferably cryptographically random. However, it need not be secret.
    // https://developer.mozilla.org/en-US/docs/Web/API/SubtleCrypto/encrypt#parameters
    const iv = crypto.getRandomValues(new Uint8Array(IV_BITS / 8));

    const key = await subtle.importKey("raw", HexEncoder.parse(hashedPassword), ENCRYPTION_ALGO, false, ["encrypt"]);

    const encrypted = await subtle.encrypt(
        {
            name: ENCRYPTION_ALGO,
            iv: iv,
        },
        key,
        UTF8Encoder.parse(msg)
    );

    // iv will be 32 hex characters, we prepend it to the ciphertext for use in decryption
    return HexEncoder.stringify(iv) + HexEncoder.stringify(new Uint8Array(encrypted));
}
exports.encrypt = encrypt;

/**
 * Decrypt a salted msg using a password.
 *
 * @param {string} encryptedMsg
 * @param {string} hashedPassword
 * @returns {Promise<string>}
 */
async function decrypt(encryptedMsg, hashedPassword) {
    const ivLength = IV_BITS / HEX_BITS;
    const iv = HexEncoder.parse(encryptedMsg.substring(0, ivLength));
    const encrypted = encryptedMsg.substring(ivLength);

    const key = await subtle.importKey("raw", HexEncoder.parse(hashedPassword), ENCRYPTION_ALGO, false, ["decrypt"]);

    const outBuffer = await subtle.decrypt(
        {
            name: ENCRYPTION_ALGO,
            iv: iv,
        },
        key,
        HexEncoder.parse(encrypted)
    );

    return UTF8Encoder.stringify(new Uint8Array(outBuffer));
}
exports.decrypt = decrypt;

/**
 * Salt and hash the password so it can be stored in localStorage without opening a password reuse vulnerability.
 *
 * @param {string} password
 * @param {string} salt
 * @returns {Promise<string>}
 */
async function hashPassword(password, salt) {
    // we hash the password in multiple steps, each adding more iterations. This is because we used to allow less
    // iterations, so for backward compatibility reasons, we need to support going from that to more iterations.
    let hashedPassword = await hashLegacyRound(password, salt);

    hashedPassword = await hashSecondRound(hashedPassword, salt);

    return hashThirdRound(hashedPassword, salt);
}
exports.hashPassword = hashPassword;

/**
 * This hashes the password with 1k iterations. This is a low number, we need this function to support backwards
 * compatibility.
 *
 * @param {string} password
 * @param {string} salt
 * @returns {Promise<string>}
 */
function hashLegacyRound(password, salt) {
    return pbkdf2(password, salt, 1000, "SHA-1");
}
exports.hashLegacyRound = hashLegacyRound;

/**
 * Add a second round of iterations. This is because we used to use 1k, so for backwards compatibility with
 * remember-me/autodecrypt links, we need to support going from that to more iterations.
 *
 * @param hashedPassword
 * @param salt
 * @returns {Promise<string>}
 */
function hashSecondRound(hashedPassword, salt) {
    return pbkdf2(hashedPassword, salt, 14000, "SHA-256");
}
exports.hashSecondRound = hashSecondRound;

/**
 * Add a third round of iterations to bring total number to 600k. This is because we used to use 1k, then 15k, so for
 * backwards compatibility with remember-me/autodecrypt links, we need to support going from that to more iterations.
 *
 * @param hashedPassword
 * @param salt
 * @returns {Promise<string>}
 */
function hashThirdRound(hashedPassword, salt) {
    return pbkdf2(hashedPassword, salt, 585000, "SHA-256");
}
exports.hashThirdRound = hashThirdRound;

/**
 * Salt and hash the password so it can be stored in localStorage without opening a password reuse vulnerability.
 *
 * @param {string} password
 * @param {string} salt
 * @param {int} iterations
 * @param {string} hashAlgorithm
 * @returns {Promise<string>}
 */
async function pbkdf2(password, salt, iterations, hashAlgorithm) {
    const key = await subtle.importKey("raw", UTF8Encoder.parse(password), "PBKDF2", false, ["deriveBits"]);

    const keyBytes = await subtle.deriveBits(
        {
            name: "PBKDF2",
            hash: hashAlgorithm,
            iterations,
            salt: UTF8Encoder.parse(salt),
        },
        key,
        256
    );

    return HexEncoder.stringify(new Uint8Array(keyBytes));
}

function generateRandomSalt() {
    const bytes = crypto.getRandomValues(new Uint8Array(128 / 8));

    return HexEncoder.stringify(new Uint8Array(bytes));
}
exports.generateRandomSalt = generateRandomSalt;

async function signMessage(hashedPassword, message) {
    const key = await subtle.importKey(
        "raw",
        HexEncoder.parse(hashedPassword),
        {
            name: "HMAC",
            hash: "SHA-256",
        },
        false,
        ["sign"]
    );
    const signature = await subtle.sign("HMAC", key, UTF8Encoder.parse(message));

    return HexEncoder.stringify(new Uint8Array(signature));
}
exports.signMessage = signMessage;

function getRandomAlphanum() {
    const possibleCharacters = "abcdefghijklmnopqrstuvwxyzABCDEFGHIJKLMNOPQRSTUVWXYZ0123456789";

    let byteArray;
    let parsedInt;

    // Keep generating new random bytes until we get a value that falls
    // within a range that can be evenly divided by possibleCharacters.length
    do {
        byteArray = crypto.getRandomValues(new Uint8Array(1));
        // extract the lowest byte to get an int from 0 to 255 (probably unnecessary, since we're only generating 1 byte)
        parsedInt = byteArray[0] & 0xff;
    } while (parsedInt >= 256 - (256 % possibleCharacters.length));

    // Take the modulo of the parsed integer to get a random number between 0 and totalLength - 1
    const randomIndex = parsedInt % possibleCharacters.length;

    return possibleCharacters[randomIndex];
}

/**
 * Generate a random string of a given length.
 *
 * @param {int} length
 * @returns {string}
 */
function generateRandomString(length) {
    let randomString = "";

    for (let i = 0; i < length; i++) {
        randomString += getRandomAlphanum();
    }

    return randomString;
}
exports.generateRandomString = generateRandomString;

  return exports;
})());
const codec = ((function(){
  const exports = {};
  /**
 * Initialize the codec with the provided cryptoEngine - this return functions to encode and decode messages.
 *
 * @param cryptoEngine - the engine to use for encryption / decryption
 */
function init(cryptoEngine) {
    const exports = {};

    /**
     * Top-level function for encoding a message.
     * Includes password hashing, encryption, and signing.
     *
     * @param {string} msg
     * @param {string} password
     * @param {string} salt
     *
     * @returns {string} The encoded text
     */
    async function encode(msg, password, salt) {
        const hashedPassword = await cryptoEngine.hashPassword(password, salt);

        const encrypted = await cryptoEngine.encrypt(msg, hashedPassword);

        // we use the hashed password in the HMAC because this is effectively what will be used a password (so we can store
        // it in localStorage safely, we don't use the clear text password)
        const hmac = await cryptoEngine.signMessage(hashedPassword, encrypted);

        return hmac + encrypted;
    }
    exports.encode = encode;

    /**
     * Encode using a password that has already been hashed. This is useful to encode multiple messages in a row, that way
     * we don't need to hash the password multiple times.
     *
     * @param {string} msg
     * @param {string} hashedPassword
     *
     * @returns {string} The encoded text
     */
    async function encodeWithHashedPassword(msg, hashedPassword) {
        const encrypted = await cryptoEngine.encrypt(msg, hashedPassword);

        // we use the hashed password in the HMAC because this is effectively what will be used a password (so we can store
        // it in localStorage safely, we don't use the clear text password)
        const hmac = await cryptoEngine.signMessage(hashedPassword, encrypted);

        return hmac + encrypted;
    }
    exports.encodeWithHashedPassword = encodeWithHashedPassword;

    /**
     * Top-level function for decoding a message.
     * Includes signature check and decryption.
     *
     * @param {string} signedMsg
     * @param {string} hashedPassword
     * @param {string} salt
     * @param {int} backwardCompatibleAttempt
     * @param {string} originalPassword
     *
     * @returns {Object} {success: true, decoded: string} | {success: false, message: string}
     */
    async function decode(signedMsg, hashedPassword, salt, backwardCompatibleAttempt = 0, originalPassword = "") {
        const encryptedHMAC = signedMsg.substring(0, 64);
        const encryptedMsg = signedMsg.substring(64);
        const decryptedHMAC = await cryptoEngine.signMessage(hashedPassword, encryptedMsg);

        if (decryptedHMAC !== encryptedHMAC) {
            // we have been raising the number of iterations in the hashing algorithm multiple times, so to support the old
            // remember-me/autodecrypt links we need to try bringing the old hashes up to speed.
            originalPassword = originalPassword || hashedPassword;
            if (backwardCompatibleAttempt === 0) {
                const updatedHashedPassword = await cryptoEngine.hashThirdRound(originalPassword, salt);

                return decode(signedMsg, updatedHashedPassword, salt, backwardCompatibleAttempt + 1, originalPassword);
            }
            if (backwardCompatibleAttempt === 1) {
                let updatedHashedPassword = await cryptoEngine.hashSecondRound(originalPassword, salt);
                updatedHashedPassword = await cryptoEngine.hashThirdRound(updatedHashedPassword, salt);

                return decode(signedMsg, updatedHashedPassword, salt, backwardCompatibleAttempt + 1, originalPassword);
            }

            return { success: false, message: "Signature mismatch" };
        }

        return {
            success: true,
            decoded: await cryptoEngine.decrypt(encryptedMsg, hashedPassword),
        };
    }
    exports.decode = decode;

    return exports;
}
exports.init = init;

  return exports;
})());
const decode = codec.init(cryptoEngine).decode;

/**
 * Initialize the staticrypt module, that exposes functions callbable by the password_template.
 *
 * @param {{
 *  staticryptEncryptedMsgUniqueVariableName: string,
 *  isRememberEnabled: boolean,
 *  rememberDurationInDays: number,
 *  staticryptSaltUniqueVariableName: string,
 * }} staticryptConfig - object of data that is stored on the password_template at encryption time.
 *
 * @param {{
 *  rememberExpirationKey: string,
 *  rememberPassphraseKey: string,
 *  replaceHtmlCallback: function,
 *  clearLocalStorageCallback: function,
 * }} templateConfig - object of data that can be configured by a custom password_template.
 */
function init(staticryptConfig, templateConfig) {
    const exports = {};

    /**
     * Decrypt our encrypted page, replace the whole HTML.
     *
     * @param {string} hashedPassword
     * @returns {Promise<boolean>}
     */
    async function decryptAndReplaceHtml(hashedPassword) {
        const { staticryptEncryptedMsgUniqueVariableName, staticryptSaltUniqueVariableName } = staticryptConfig;
        const { replaceHtmlCallback } = templateConfig;

        const result = await decode(
            staticryptEncryptedMsgUniqueVariableName,
            hashedPassword,
            staticryptSaltUniqueVariableName
        );
        if (!result.success) {
            return false;
        }
        const plainHTML = result.decoded;

        // if the user configured a callback call it, otherwise just replace the whole HTML
        if (typeof replaceHtmlCallback === "function") {
            replaceHtmlCallback(plainHTML);
        } else {
            document.write(plainHTML);
            document.close();
        }

        return true;
    }

    /**
     * Attempt to decrypt the page and replace the whole HTML.
     *
     * @param {string} password
     * @param {boolean} isRememberChecked
     *
     * @returns {Promise<{isSuccessful: boolean, hashedPassword?: string}>} - we return an object, so that if we want to
     *   expose more information in the future we can do it without breaking the password_template
     */
    async function handleDecryptionOfPage(password, isRememberChecked) {
        const { isRememberEnabled, rememberDurationInDays, staticryptSaltUniqueVariableName } = staticryptConfig;
        const { rememberExpirationKey, rememberPassphraseKey } = templateConfig;

        // decrypt and replace the whole page
        const hashedPassword = await cryptoEngine.hashPassword(password, staticryptSaltUniqueVariableName);

        const isDecryptionSuccessful = await decryptAndReplaceHtml(hashedPassword);

        if (!isDecryptionSuccessful) {
            return {
                isSuccessful: false,
                hashedPassword,
            };
        }

        // remember the hashedPassword and set its expiration if necessary
        if (isRememberEnabled && isRememberChecked) {
            window.localStorage.setItem(rememberPassphraseKey, hashedPassword);

            // set the expiration if the duration isn't 0 (meaning no expiration)
            if (rememberDurationInDays > 0) {
                window.localStorage.setItem(
                    rememberExpirationKey,
                    (new Date().getTime() + rememberDurationInDays * 24 * 60 * 60 * 1000).toString()
                );
            }
        }

        return {
            isSuccessful: true,
            hashedPassword,
        };
    }
    exports.handleDecryptionOfPage = handleDecryptionOfPage;

    /**
     * Clear localstorage from staticrypt related values
     */
    function clearLocalStorage() {
        const { clearLocalStorageCallback, rememberExpirationKey, rememberPassphraseKey } = templateConfig;

        if (typeof clearLocalStorageCallback === "function") {
            clearLocalStorageCallback();
        } else {
            localStorage.removeItem(rememberPassphraseKey);
            localStorage.removeItem(rememberExpirationKey);
        }
    }

    async function handleDecryptOnLoad() {
        let isSuccessful = await decryptOnLoadFromUrl();

        if (!isSuccessful) {
            isSuccessful = await decryptOnLoadFromRememberMe();
        }

        return { isSuccessful };
    }
    exports.handleDecryptOnLoad = handleDecryptOnLoad;

    /**
     * Clear storage if we are logging out
     *
     * @returns {boolean} - whether we logged out
     */
    function logoutIfNeeded() {
        const logoutKey = "staticrypt_logout";

        // handle logout through query param
        const queryParams = new URLSearchParams(window.location.search);
        if (queryParams.has(logoutKey)) {
            clearLocalStorage();
            return true;
        }

        // handle logout through URL fragment
        const hash = window.location.hash.substring(1);
        if (hash.includes(logoutKey)) {
            clearLocalStorage();
            return true;
        }

        return false;
    }

    /**
     * To be called on load: check if we want to try to decrypt and replace the HTML with the decrypted content, and
     * try to do it if needed.
     *
     * @returns {Promise<boolean>} true if we derypted and replaced the whole page, false otherwise
     */
    async function decryptOnLoadFromRememberMe() {
        const { rememberDurationInDays } = staticryptConfig;
        const { rememberExpirationKey, rememberPassphraseKey } = templateConfig;

        // if we are login out, terminate
        if (logoutIfNeeded()) {
            return false;
        }

        // if there is expiration configured, check if we're not beyond the expiration
        if (rememberDurationInDays && rememberDurationInDays > 0) {
            const expiration = localStorage.getItem(rememberExpirationKey),
                isExpired = expiration && new Date().getTime() > parseInt(expiration);

            if (isExpired) {
                clearLocalStorage();
                return false;
            }
        }

        const hashedPassword = localStorage.getItem(rememberPassphraseKey);

        if (hashedPassword) {
            // try to decrypt
            const isDecryptionSuccessful = await decryptAndReplaceHtml(hashedPassword);

            // if the decryption is unsuccessful the password might be wrong - silently clear the saved data and let
            // the user fill the password form again
            if (!isDecryptionSuccessful) {
                clearLocalStorage();
                return false;
            }

            return true;
        }

        return false;
    }

    function decryptOnLoadFromUrl() {
        const passwordKey = "staticrypt_pwd";

        // get the password from the query param
        const queryParams = new URLSearchParams(window.location.search);
        const hashedPasswordQuery = queryParams.get(passwordKey);

        // get the password from the url fragment
        const hashRegexMatch = window.location.hash.substring(1).match(new RegExp(passwordKey + "=(.*)"));
        const hashedPasswordFragment = hashRegexMatch ? hashRegexMatch[1] : null;

        const hashedPassword = hashedPasswordFragment || hashedPasswordQuery;

        if (hashedPassword) {
            return decryptAndReplaceHtml(hashedPassword);
        }

        return false;
    }

    return exports;
}
exports.init = init;

  return exports;
})());
        ;
            const templateError = "template_error",
                isRememberEnabled = true,
                staticryptConfig = {"staticryptEncryptedMsgUniqueVariableName":"b9e95ee157249614d107b8ed0f020d90e4d4fc2ee8c5086787a340e9ed165ca8710a1a46f1152920c76f1cc1b71090b587ab746228188d0606c07d8196f4e4a64d9dfc2ac27e2f02855ee42dea865b71d46a08a9e94d099e6a354436f24c6464951fba63f685be672c0ea57d5249df69b02f441656cb1e1c0cc3e8cab7422dde68508f25b0961c842de8112f0afd0a4d513a940201735724a137e04ed3ff9d3972995d8eb9d9bc5ce7e21552eb6ba2a9544a761f0f1cdd0a35ec42aac115f1b7af93b791dbcc4262d92d4de38b64976813d7603d851f2f5907a3a6a0f394c34d9a71683a6ac37ff0dbbd050cf8c2d6fb3b5c23a8735c3e5891c14252cf1fbb42fbddf50e6f4db5e205737bed424cb54ceeae21349c6a882bd3a0244676949a2d361aeb9235a782c552f09121d72fba81f6824783a6cca8767173f4ecbf7f33c14b5bab5f840a2d3cf0364c5d16632756f5240361a59779d5df6af1ad8473eabec5953dd5b54f44b505b87f6b3fc3dace9e7cc1ad6768596ceaf7e427c44f1858ad590cc8c831ff3002d7043b735bea1211ebb56b9379c4db991794b452748cf345a09afbf03f0a40b05d4cf24f4cba1d51aa123bcb315ba76cce73388a2a1ee5eb7a91c73d1690b224a759744ea9706b8a8447914db24e937e26f2d72f5d7855c10d793dabb22f682660e3e6b1e911d8ab42a5a6bfecbff96abdd8fb619b52d593847ebb873f34b4254a18675fd5e11e9f98f2ffecb5fb0d87435c1e390d6443753a97a99962410fdc50c540b6dddeeeced505af73f9093498c4346f677dfb4797dc3671bc5cd846487a8cdbe5a84804c206629e5a3b11e65c3e30c31e3742d7dd2a12824c379130da2df3e302dfb7de05e0475fb002ac7d7e05d270b27870585da50d4e13c935fd0477fa548a56ef8c9bca6d5b41aded5781ea9e4100b9c3c63f55ce404bb03f9207681050fc57f029b08128c6edf5f5fa7f244a577bc99cafda5db2ef1817b40aaee21c9f390304b1093386f53fb29cd9f64cf456e23ec09e8624bc956f8fe72cdcf5e2a7105d5561eb20e148944e7b9a3c4669e6f413d74f26bf6ce5d5a644bffaa81aeffea335534a4e35c6ed21a9f67c50f01ffad3f53cffc89e1b672f1d32ad47d402a009fba42ee17918f6e39c2d0af7fdbbc3fc95c7c8de96d00c17306ddfaba5301e66682eaacef90b2513852611370ffa9527c0ab91f4680f589830beb7b029afded3df341a7335254bca771b1049e73e20907d27c3caf2f8bfbc196145025cf8fa2485500bc091e7c73ffe875f959ee9581029aba7b3ffd97e25c400a8d332b98173bbaa284856f3bdd2ff28fa83bdbabd9e929f9757961fb1e406732149fce2c13527ce5af1c68792fae399b03f97e48675c13884d9f427b1e11261ea636d4e013e3bde9cf474dce954c41b646a9df23b4fb67dcc9b03b6389b5f50b37be6c2cdc590cee95c9ae46d3e8fe4c485a2683d1725bac1ee80ab8c7752f92f3e881fc09ae0af86384d92bcb86cb72eb7bea22b3343343c9c6540a84ede7f880d0f10b1a7be10e52073f62f411663bab31d825a4b43a71d75ef72b58c61c972a09cb51ee412e4d5f45a3cbfb5bb7e82d4203e174dbfecb4dff5766b4d2b8e6e762607640fe78774f84b33a17ef41a0a5c87837c95e45f04551746897d118f35eabfbaaba75f092cd3bb1c839c488ca14ad6aeff405ff47eb36ce9475c1ba15a886fea26772d9ae2971981a1d0e30453cd87a040934df37279d6a7e73c3f750e1b104fecc263d217b304595dfdfdfafba894538e645147f25365b85f3a378d5481e753e7ff4b43238d9ca877d14c8e7bca9bba553fd6c02c87c9769dbfcbf8673367bde5e332b1f6f91904ea75030bdb2ee1d61cc7b582de2fe7085cfd875ccd5804ae8b656f628b91b6af56d936df7ba0e1ae7ba4afa3b598dc3a0d002b9792ee82062602ffc8d560db225dd36943cd2a7758386d08a3cd7fe1bf952ceb1c0cf797b5abf54ffe64496164d19281f55052b0293fafb9ce98f008f2450ff0114ceb5906f54395a7be1381db10e437508e81ba0d99a10f90b7edcdbb55da52c6c8d4b76c9b7e77e9f6446f9d31886462a47acb20f3b6b30eb84888f97b7198693a170073e15134f65ef987e8919aa6c2984c7d9e9114529cf9c844ce5721947f1b76b8bf7e148bc13935ef5d0d3c9cfcab68d6b8ae82195b5c9b593e3da86919e8f2bd1288bcdfe43ca4fd1332e02c807d0db48c3664a56a2ca0ae9807d3b07937f24c7cd9f3f21f8dbfbe36cd9bb17a83a3cdd88cd2b7ae297b654d180fdfa174074ad9ad6e425d32b1ac84ab11c852fe6d84838a1e630a6777949b1a01900ce48a892c1228109b2b2625ea9d460b49ed2ee0745a9a3456a6b90a4235e6483032908ad503cd2fe5d7a69b0a933e8f5d05a7b9ec737aed751dc357922b212931596727bde833a4ff4ffe9303b3c229b0cc686f3201eb3d95e20e2f1d9ce75fb4fc9ba32f3aad7b5d7590b578a5302e643aee8ea0b7a67569325136a4606ba6f177c4100156232ceb9ddf6c63c4f200842725f335d8b693c0adea010ad4b64eecb76ea5ad2e8c9fd5e66663a9c9ebaf51a96322024f9a1065c3b2f1423e91358f1956103ded745d3c0bfa1bccf79e337c5acbbe1fe7ce5dce7fc1cd66456ffef2461e3e8f02878ff6d9412ac1853c7c832a9791d9e1af485fb39909ab9a9b37d8e7bb7fc2be204696bb145918afa52eecfd75a33b78d3e6e50fc5f303c3aeb891a966ddbb1f1ea886884a6970ed5b3d364d3bc16c3379ef07ae87bdecbced7da768accc691b34d6751921e9bff2a6cca8bb848f59ea8aacfe4d5472916b16eec2928a2a9a22cacd56b36bd8f8a7fb5944e4f9387b4de4a119b4227216854452eb0816d2ebb51cacb8e25761660ea8c763cb675c6661a69529c11984d4a31c236af4216042b18617168b9a6482bc5257e013d99177b6074dd3fcdf173a853b3a0a21ebc6272b40df13f8cb47b2c29de3316b6d0e790df5d6f5194d186e31f19340e88569f997b44496dfca672e72f1ba493b964bbe514ffa084f9b33425c74f48bd45528324f8ccbed2bf8d9adccbf83406078f86af364002ee972966e697ba85e91043667209f2162dfc6d25ea5af28806518289f3f6eb14d75aa66a0807dd5c0511c2f8eed88c5f57ec6035957a58c34057a322e6d3c916ab497587703545c49bc37629a6f67f19fc4a0e905a719e9606279de1231e2944cca40c3608991828a32369ba53b2602ec79004411ccf7efdfed14c625f6db09c1bc21eb9089e91653dbd5a9e64172cad57026e24820801807867c3a02f010d665616ab7b03a58eee7dfa785ed07cfa46b9ef4988f714d422949f1633007020a73ca4746153341b68dc06697c86ee50c3fea3d6724c31a03980f7ec1fa7f7de706ea2dcc82054145618e1030d9ad222d3364dfdb8e77bbb0c530d7f2d7891f3fc77bf1c8f35fd4b062b92ded3a0b7b21db6c3a56107393562feb017d332fc564e19bc3b44366b067b06e5fff1a3ac9d31c3b37ae6204d47f2197a53522579313fcea5ac9624ca61d0041b87b121c2a325fcb39ae692ae02da49ae724f7702e38ebd4f3ea29ddbd068fae12879f0f74044ba06f9f4c4562f837f7df391f783c343c4e35f81613509eeef4d77196051e9ade59f34634c78a094f32d669810d3aeefb26bc63037373df7477ac3f7caec57c4b70ed7777112a0e5b5713fbe8d1f4ef1c668c480b97a507670dd387bec989e53b3353a506f4b30d55316ffbc0881d95a08051280dc0107f5c269f35c63cdb27fe12a9d8a141e2d99202878481bed204dee1aaec993f89898c4943e9df30ea171ab7b1da753c2ea7d2674e2b2e9aeac610cc8b15b3a1588fea102902ef332ef24e0e269961a8bbe9de9b9b8b3c5e3c30558446a5a67dfbc1fa13ddf9217c6130fa202541cd6bb8aeae1ec4d76439a5da324c8d09bb014d5fec7098216e6c7f2e4de9f634cde8827430739066c44f49f01fd6d335663b381c512403fc8b50cbfa8b5b002edadf3094dc8327edad09f58985c881d0cf3813c77bd1d0452b4a73cba5283370c8ab375c352bb40c1d1e5f17844b76c4a5f6aa6a5cdd4ef47c92be7b87986cabe792ca1fadb749b72ffd3926f3b39d291dcef827f06210915ad1a4b7964b2475a13e9f335fa43baec3be6635aa63e0cc9a9588699bb0bc380cac8f8b7f105985dc1408d2f5c4ea84e90660520a4d4f28f885a82ac5e7858d6b7e87302b07b34e4dbd984d31bebbc16c5865273bb1f6cdeef58dcf80b3e56f9128474ca9a40262d9e4803b6df6bbce4d67fe4a64011f4e45514705adecd10e3814b61b610c42d4bcfa7c351ca909a624bbbc326e9f9d3efd2efaa7dfd053b044132a6a3c119d542f6a7847731a71b5929874c4bd9896e564bfc4497e611c94ac0ef788c311b38568954e240e8ea60293accb57516bad3d65a7f7b6b25bb85880e83731128f3b86eb49bdb980d15ee35c0bc53ddbeaf2720228019817d056d1e68d76538f88b572e1c8e11fe9fdfabc55606ce9e9ea5e6c702a70df2df2517d2bcd21a10ff0762f0c24ae75c7c0ab9ffc1851d59f4a0665d17968623ac99291245276fd11b2418d8fa4e718b378cbf1dd12d0c0d8e4dff8e2a7fc15e8afd04dca08f87196a4685490ee8d856cfc6b7da0c6e19ba483f5e11d1c790a4c7ab697725f8b6c18c39aaac4610815e878e966d9dd2b97c478bca299ffdcbdbaf7932e5a17193def250de377bd583cf085423e518ddbd0eb5a7fbc56df531eaf6ba8ffc23406f36268c8eebe799b827bc16449198ee94cb9d33eafc7fe6cb0e6e645aaa3c959d1e965d1330dd8eceafcebb8d2484580d6d72cde87c3a96f3e330e88696f29e573422b088b835cff0ba7705a84305ee55e69f369e7386d2136e02bf86441beb79aab47fb0c4625e6055164069c123f756d351423bf2d36d43faddcffa4588c056ba3dbee42d81edcd53fe6c1a47b0d860829b46b5610d3cbd16f47239a2d9af847b0f67d27df203134fa8cdde491dc1d495d055741c4a6fcbba61e0432c28b3be20df05286fe52d496c625db706e112e2746cef8fd49d8b3801d65356b855b18a17cbcc8893dca065eac2e1d298cf4f933807fdb97f1d4828b68086cba07e4e8991440af9057b3fb7505978f36600311892a0e3cbb5786b276b276605af59d562a3b7e8f9f72a5bd7b9c8344883b25e5357915feaa928ae536668aaae0bd5bcd6981179eb237025bcfa4035fef96160950f0b2686cff73f4e403ccf8da0a9184fd36de0af41a50287b917240161d42ebed37baeda48b8eb24d879c194fbc09a0257a0dd362d3ff375028f821a81a8363ab8668a0014514398a7a61c0eeba9139df19ea1804d98d42507b85e46e84a7aae3b20b8e111a85eb7be7dd524f68c569e10b971e65dd5ff628aafd56b6154453989dd65ef8010513123461e245d14e3a16fcf3595f37f334fa58dfca38a46a009adbf06a36c70ecbc514db3aa59b98ae123eaf4c4bc0b859c2392f967b4d59599c995bfde79b4de5d7f290cd5a2e34d7f5609cf3f473daebbef5348cdd3bc30ee3b5f3f9e62cb62183aadabb8ece6761bc6f0453350ff3acfaeb1450b97d5d4a9d15f509158576ad36913acb80935e7d4a7c7944785ff9e03d63787c7d0657e88f16c6b69aa8a2a6fb53fc52d808c66c5300af676b4952e9ba9df40a2894a0720897236e26895d12a484f82c488347a9514edab9af673d488180ed5d7736f8bbc527539d1c0361d44f8f454d279334602e1aeabba90ec0837cf0503e4555d9531a2dfe27fdd0afa24db3f22aed82d3d655d10eb64c2e3420f8281c40a053f4782c9cbc001ef4c043482d8ab074cfd3d0384aa89942a70141cd52c3d4966ffb39302d820bf9aa5cd9546372f7e6ae407f7de8514b3dd7c6656e216ed5d6b2b79004209d26862d5dfa7b8e222a2997c8661f0d445ea4e7c34470a51a97959fd6d767d31e47d2f193b0e823ab3a59361971f1a74cdca5f383fb86105d9edf4f7dc87b8f6f7af6ec09efbb8d549f2df528843aba5a3bb14ad3f975fc0a17739fd9e58cd23088ffa7e68031ee8024f6ed1fb5e5a0e90b9f6764de31f6851b800c745de6def6b5c224924c24711e34ebd3a56554338937fff780a29b0d522fcf7d9a95c07708f438ae5bbabbceda221ab87f6092160b35b343c1a4a790ee355343289c3baa2d4e0d5689646d1ccba5c792c7e4f3d04e59dd33860008a10d93570252d0b815a51066ad09514ab89ebd26ef95242cceb268a5b3644a607a087e5156a50ec5560729caca1681789dfdece28b5425a6b57e3fb908be264f43157870791840694e37899ca0c54c599ce02f28037133806c9b50d95ea6cd875601e8bd46bc9110702b000c06f8d8b74703d812cb98a52f570ca728436f3bef3eea60f13cf44ba673484f48f0cf76011e68e1b0e6ca5f7c8e35bc2b3b1eb99fa44c6b8593348d02a0fc9f0776adf034f3c072463cfdd9369e0b362dd0facdec00e4b43ea35fad75c0d32cf684f84bbe71ee741ad5c462bd4c5df93f8e0f73e4afcfeb9208f6282f9b4ea2b6b995af2e120903a1eede9da6d70ab6a0b0b63553a447587a1e79247c0104413d0f3a38e914e026ce84895b31e853548de62fda7af847c4e5799ca0dab9bacfb5b26cf3d87c5885916cf3ce4f8f4b4de58fb19952d92d52444991eb027c35961dd7119a56476ec9cf6780a86d2fff69fa10a2912fdf90ce2c4dbf929772c3160d1a21114e42e1247c5b61f63e95","isRememberEnabled":true,"rememberDurationInDays":0,"staticryptSaltUniqueVariableName":"127b7192e87f3c386c56cb8099828631"};

            // you can edit these values to customize some of the behavior of StatiCrypt
            const templateConfig = {
                rememberExpirationKey: "staticrypt_expiration",
                rememberPassphraseKey: "staticrypt_passphrase",
                replaceHtmlCallback: null,
                clearLocalStorageCallback: null,
            };

            // init the staticrypt engine
            const staticrypt = staticryptInitiator.init(staticryptConfig, templateConfig);

            // try to automatically decrypt on load if there is a saved password
            window.onload = async function () {
                const { isSuccessful } = await staticrypt.handleDecryptOnLoad();

                // if we didn't decrypt anything on load, show the password prompt. Otherwise the content has already been
                // replaced, no need to do anything
                if (!isSuccessful) {
                    // hide loading screen
                    document.getElementById("staticrypt_loading").classList.add("hidden");
                    document.getElementById("staticrypt_content").classList.remove("hidden");
                    document.getElementById("staticrypt-password").focus();

                    // show the remember me checkbox
                    if (isRememberEnabled) {
                        document.getElementById("staticrypt-remember-label").classList.remove("hidden");
                    }
                }
            };

            // handle password form submission
            document.getElementById("staticrypt-form").addEventListener("submit", async function (e) {
                e.preventDefault();

                const password = document.getElementById("staticrypt-password").value,
                    isRememberChecked = document.getElementById("staticrypt-remember").checked;

                const { isSuccessful } = await staticrypt.handleDecryptionOfPage(password, isRememberChecked);

                if (!isSuccessful) {
                    alert(templateError);
                }
            });
        </script>
    </body>
</html>
