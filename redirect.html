<!DOCTYPE html>
<html class="staticrypt-html">
    <head>
        <meta charset="utf-8" />
        <title>SecureStudyApp</title>
        <meta name="viewport" content="width=device-width, initial-scale=1" />

        <!-- do not cache this page -->
        <meta http-equiv="cache-control" content="max-age=0" />
        <meta http-equiv="cache-control" content="no-cache" />
        <meta http-equiv="expires" content="0" />
        <meta http-equiv="expires" content="Tue, 01 Jan 1980 1:00:00 GMT" />
        <meta http-equiv="pragma" content="no-cache" />

        <style>
            .staticrypt-hr {
                margin-top: 20px;
                margin-bottom: 20px;
                border: 0;
                border-top: 1px solid #eee;
            }

            .staticrypt-page {
                width: 360px;
                padding: 8% 0 0;
                margin: auto;
                box-sizing: border-box;
            }

            .staticrypt-form {
                position: relative;
                z-index: 1;
                background: #ffffff;
                max-width: 360px;
                margin: 0 auto 100px;
                padding: 45px;
                text-align: center;
                box-shadow: 0 0 20px 0 rgba(0, 0, 0, 0.2), 0 5px 5px 0 rgba(0, 0, 0, 0.24);
            }

            .staticrypt-form input[type="password"] {
                outline: 0;
                background: #f2f2f2;
                width: 100%;
                border: 0;
                margin: 0 0 15px;
                padding: 15px;
                box-sizing: border-box;
                font-size: 14px;
            }

            .staticrypt-form .staticrypt-decrypt-button {
                text-transform: uppercase;
                outline: 0;
                background: #4CAF50;
                width: 100%;
                border: 0;
                padding: 15px;
                color: #ffffff;
                font-size: 14px;
                cursor: pointer;
            }

            .staticrypt-form .staticrypt-decrypt-button:hover,
            .staticrypt-form .staticrypt-decrypt-button:active,
            .staticrypt-form .staticrypt-decrypt-button:focus {
                background: #4CAF50;
                filter: brightness(92%);
            }

            .staticrypt-html {
                height: 100%;
            }

            .staticrypt-body {
                height: 100%;
                margin: 0;
            }

            .staticrypt-content {
                height: 100%;
                margin-bottom: 1em;
                background: #76B852;
                font-family: "Arial", sans-serif;
                -webkit-font-smoothing: antialiased;
                -moz-osx-font-smoothing: grayscale;
            }

            .staticrypt-instructions {
                margin-top: -1em;
                margin-bottom: 1em;
            }

            .staticrypt-title {
                font-size: 1.5em;
            }

            label.staticrypt-remember {
                display: flex;
                align-items: center;
                margin-bottom: 1em;
            }

            .staticrypt-remember input[type="checkbox"] {
                transform: scale(1.5);
                margin-right: 1em;
            }

            .hidden {
                display: none !important;
            }

            .staticrypt-spinner-container {
                height: 100%;
                display: flex;
                align-items: center;
                justify-content: center;
            }

            .staticrypt-spinner {
                display: inline-block;
                width: 2rem;
                height: 2rem;
                vertical-align: text-bottom;
                border: 0.25em solid gray;
                border-right-color: transparent;
                border-radius: 50%;
                -webkit-animation: spinner-border 0.75s linear infinite;
                animation: spinner-border 0.75s linear infinite;
                animation-duration: 0.75s;
                animation-timing-function: linear;
                animation-delay: 0s;
                animation-iteration-count: infinite;
                animation-direction: normal;
                animation-fill-mode: none;
                animation-play-state: running;
                animation-name: spinner-border;
            }

            @keyframes spinner-border {
                100% {
                    transform: rotate(360deg);
                }
            }
        </style>
    </head>

    <body class="staticrypt-body">
        <div id="staticrypt_loading" class="staticrypt-spinner-container">
            <div class="staticrypt-spinner"></div>
        </div>

        <div id="staticrypt_content" class="staticrypt-content hidden">
            <div class="staticrypt-page">
                <div class="staticrypt-form">
                    <div class="staticrypt-instructions">
                        <p class="staticrypt-title">SecureStudyApp</p>
                        <p><p>Enter the correct password!</p>
</p>
                    </div>

                    <hr class="staticrypt-hr" />

                    <form id="staticrypt-form" action="#" method="post">
                        <input
                            id="staticrypt-password"
                            type="password"
                            name="password"
                            placeholder="Don't guess!"
                            autofocus
                        />

                        <label id="staticrypt-remember-label" class="staticrypt-remember hidden">
                            <input id="staticrypt-remember" type="checkbox" name="remember" />
                            Stay logged in
                        </label>

                        <input type="submit" class="staticrypt-decrypt-button" value="Study" />
                    </form>
                </div>
            </div>
        </div>

        <script>
            // these variables will be filled when generating the file - the template format is 'variable_name'
            const staticryptInitiator = 
            ((function(){
  const exports = {};
  const cryptoEngine = ((function(){
  const exports = {};
  const { subtle } = crypto;

const IV_BITS = 16 * 8;
const HEX_BITS = 4;
const ENCRYPTION_ALGO = "AES-CBC";

/**
 * Translates between utf8 encoded hexadecimal strings
 * and Uint8Array bytes.
 */
const HexEncoder = {
    /**
     * hex string -> bytes
     * @param {string} hexString
     * @returns {Uint8Array}
     */
    parse: function (hexString) {
        if (hexString.length % 2 !== 0) throw "Invalid hexString";
        const arrayBuffer = new Uint8Array(hexString.length / 2);

        for (let i = 0; i < hexString.length; i += 2) {
            const byteValue = parseInt(hexString.substring(i, i + 2), 16);
            if (isNaN(byteValue)) {
                throw "Invalid hexString";
            }
            arrayBuffer[i / 2] = byteValue;
        }
        return arrayBuffer;
    },

    /**
     * bytes -> hex string
     * @param {Uint8Array} bytes
     * @returns {string}
     */
    stringify: function (bytes) {
        const hexBytes = [];

        for (let i = 0; i < bytes.length; ++i) {
            let byteString = bytes[i].toString(16);
            if (byteString.length < 2) {
                byteString = "0" + byteString;
            }
            hexBytes.push(byteString);
        }
        return hexBytes.join("");
    },
};

/**
 * Translates between utf8 strings and Uint8Array bytes.
 */
const UTF8Encoder = {
    parse: function (str) {
        return new TextEncoder().encode(str);
    },

    stringify: function (bytes) {
        return new TextDecoder().decode(bytes);
    },
};

/**
 * Salt and encrypt a msg with a password.
 */
async function encrypt(msg, hashedPassword) {
    // Must be 16 bytes, unpredictable, and preferably cryptographically random. However, it need not be secret.
    // https://developer.mozilla.org/en-US/docs/Web/API/SubtleCrypto/encrypt#parameters
    const iv = crypto.getRandomValues(new Uint8Array(IV_BITS / 8));

    const key = await subtle.importKey("raw", HexEncoder.parse(hashedPassword), ENCRYPTION_ALGO, false, ["encrypt"]);

    const encrypted = await subtle.encrypt(
        {
            name: ENCRYPTION_ALGO,
            iv: iv,
        },
        key,
        UTF8Encoder.parse(msg)
    );

    // iv will be 32 hex characters, we prepend it to the ciphertext for use in decryption
    return HexEncoder.stringify(iv) + HexEncoder.stringify(new Uint8Array(encrypted));
}
exports.encrypt = encrypt;

/**
 * Decrypt a salted msg using a password.
 *
 * @param {string} encryptedMsg
 * @param {string} hashedPassword
 * @returns {Promise<string>}
 */
async function decrypt(encryptedMsg, hashedPassword) {
    const ivLength = IV_BITS / HEX_BITS;
    const iv = HexEncoder.parse(encryptedMsg.substring(0, ivLength));
    const encrypted = encryptedMsg.substring(ivLength);

    const key = await subtle.importKey("raw", HexEncoder.parse(hashedPassword), ENCRYPTION_ALGO, false, ["decrypt"]);

    const outBuffer = await subtle.decrypt(
        {
            name: ENCRYPTION_ALGO,
            iv: iv,
        },
        key,
        HexEncoder.parse(encrypted)
    );

    return UTF8Encoder.stringify(new Uint8Array(outBuffer));
}
exports.decrypt = decrypt;

/**
 * Salt and hash the password so it can be stored in localStorage without opening a password reuse vulnerability.
 *
 * @param {string} password
 * @param {string} salt
 * @returns {Promise<string>}
 */
async function hashPassword(password, salt) {
    // we hash the password in multiple steps, each adding more iterations. This is because we used to allow less
    // iterations, so for backward compatibility reasons, we need to support going from that to more iterations.
    let hashedPassword = await hashLegacyRound(password, salt);

    hashedPassword = await hashSecondRound(hashedPassword, salt);

    return hashThirdRound(hashedPassword, salt);
}
exports.hashPassword = hashPassword;

/**
 * This hashes the password with 1k iterations. This is a low number, we need this function to support backwards
 * compatibility.
 *
 * @param {string} password
 * @param {string} salt
 * @returns {Promise<string>}
 */
function hashLegacyRound(password, salt) {
    return pbkdf2(password, salt, 1000, "SHA-1");
}
exports.hashLegacyRound = hashLegacyRound;

/**
 * Add a second round of iterations. This is because we used to use 1k, so for backwards compatibility with
 * remember-me/autodecrypt links, we need to support going from that to more iterations.
 *
 * @param hashedPassword
 * @param salt
 * @returns {Promise<string>}
 */
function hashSecondRound(hashedPassword, salt) {
    return pbkdf2(hashedPassword, salt, 14000, "SHA-256");
}
exports.hashSecondRound = hashSecondRound;

/**
 * Add a third round of iterations to bring total number to 600k. This is because we used to use 1k, then 15k, so for
 * backwards compatibility with remember-me/autodecrypt links, we need to support going from that to more iterations.
 *
 * @param hashedPassword
 * @param salt
 * @returns {Promise<string>}
 */
function hashThirdRound(hashedPassword, salt) {
    return pbkdf2(hashedPassword, salt, 585000, "SHA-256");
}
exports.hashThirdRound = hashThirdRound;

/**
 * Salt and hash the password so it can be stored in localStorage without opening a password reuse vulnerability.
 *
 * @param {string} password
 * @param {string} salt
 * @param {int} iterations
 * @param {string} hashAlgorithm
 * @returns {Promise<string>}
 */
async function pbkdf2(password, salt, iterations, hashAlgorithm) {
    const key = await subtle.importKey("raw", UTF8Encoder.parse(password), "PBKDF2", false, ["deriveBits"]);

    const keyBytes = await subtle.deriveBits(
        {
            name: "PBKDF2",
            hash: hashAlgorithm,
            iterations,
            salt: UTF8Encoder.parse(salt),
        },
        key,
        256
    );

    return HexEncoder.stringify(new Uint8Array(keyBytes));
}

function generateRandomSalt() {
    const bytes = crypto.getRandomValues(new Uint8Array(128 / 8));

    return HexEncoder.stringify(new Uint8Array(bytes));
}
exports.generateRandomSalt = generateRandomSalt;

async function signMessage(hashedPassword, message) {
    const key = await subtle.importKey(
        "raw",
        HexEncoder.parse(hashedPassword),
        {
            name: "HMAC",
            hash: "SHA-256",
        },
        false,
        ["sign"]
    );
    const signature = await subtle.sign("HMAC", key, UTF8Encoder.parse(message));

    return HexEncoder.stringify(new Uint8Array(signature));
}
exports.signMessage = signMessage;

function getRandomAlphanum() {
    const possibleCharacters = "abcdefghijklmnopqrstuvwxyzABCDEFGHIJKLMNOPQRSTUVWXYZ0123456789";

    let byteArray;
    let parsedInt;

    // Keep generating new random bytes until we get a value that falls
    // within a range that can be evenly divided by possibleCharacters.length
    do {
        byteArray = crypto.getRandomValues(new Uint8Array(1));
        // extract the lowest byte to get an int from 0 to 255 (probably unnecessary, since we're only generating 1 byte)
        parsedInt = byteArray[0] & 0xff;
    } while (parsedInt >= 256 - (256 % possibleCharacters.length));

    // Take the modulo of the parsed integer to get a random number between 0 and totalLength - 1
    const randomIndex = parsedInt % possibleCharacters.length;

    return possibleCharacters[randomIndex];
}

/**
 * Generate a random string of a given length.
 *
 * @param {int} length
 * @returns {string}
 */
function generateRandomString(length) {
    let randomString = "";

    for (let i = 0; i < length; i++) {
        randomString += getRandomAlphanum();
    }

    return randomString;
}
exports.generateRandomString = generateRandomString;

  return exports;
})());
const codec = ((function(){
  const exports = {};
  /**
 * Initialize the codec with the provided cryptoEngine - this return functions to encode and decode messages.
 *
 * @param cryptoEngine - the engine to use for encryption / decryption
 */
function init(cryptoEngine) {
    const exports = {};

    /**
     * Top-level function for encoding a message.
     * Includes password hashing, encryption, and signing.
     *
     * @param {string} msg
     * @param {string} password
     * @param {string} salt
     *
     * @returns {string} The encoded text
     */
    async function encode(msg, password, salt) {
        const hashedPassword = await cryptoEngine.hashPassword(password, salt);

        const encrypted = await cryptoEngine.encrypt(msg, hashedPassword);

        // we use the hashed password in the HMAC because this is effectively what will be used a password (so we can store
        // it in localStorage safely, we don't use the clear text password)
        const hmac = await cryptoEngine.signMessage(hashedPassword, encrypted);

        return hmac + encrypted;
    }
    exports.encode = encode;

    /**
     * Encode using a password that has already been hashed. This is useful to encode multiple messages in a row, that way
     * we don't need to hash the password multiple times.
     *
     * @param {string} msg
     * @param {string} hashedPassword
     *
     * @returns {string} The encoded text
     */
    async function encodeWithHashedPassword(msg, hashedPassword) {
        const encrypted = await cryptoEngine.encrypt(msg, hashedPassword);

        // we use the hashed password in the HMAC because this is effectively what will be used a password (so we can store
        // it in localStorage safely, we don't use the clear text password)
        const hmac = await cryptoEngine.signMessage(hashedPassword, encrypted);

        return hmac + encrypted;
    }
    exports.encodeWithHashedPassword = encodeWithHashedPassword;

    /**
     * Top-level function for decoding a message.
     * Includes signature check and decryption.
     *
     * @param {string} signedMsg
     * @param {string} hashedPassword
     * @param {string} salt
     * @param {int} backwardCompatibleAttempt
     * @param {string} originalPassword
     *
     * @returns {Object} {success: true, decoded: string} | {success: false, message: string}
     */
    async function decode(signedMsg, hashedPassword, salt, backwardCompatibleAttempt = 0, originalPassword = "") {
        const encryptedHMAC = signedMsg.substring(0, 64);
        const encryptedMsg = signedMsg.substring(64);
        const decryptedHMAC = await cryptoEngine.signMessage(hashedPassword, encryptedMsg);

        if (decryptedHMAC !== encryptedHMAC) {
            // we have been raising the number of iterations in the hashing algorithm multiple times, so to support the old
            // remember-me/autodecrypt links we need to try bringing the old hashes up to speed.
            originalPassword = originalPassword || hashedPassword;
            if (backwardCompatibleAttempt === 0) {
                const updatedHashedPassword = await cryptoEngine.hashThirdRound(originalPassword, salt);

                return decode(signedMsg, updatedHashedPassword, salt, backwardCompatibleAttempt + 1, originalPassword);
            }
            if (backwardCompatibleAttempt === 1) {
                let updatedHashedPassword = await cryptoEngine.hashSecondRound(originalPassword, salt);
                updatedHashedPassword = await cryptoEngine.hashThirdRound(updatedHashedPassword, salt);

                return decode(signedMsg, updatedHashedPassword, salt, backwardCompatibleAttempt + 1, originalPassword);
            }

            return { success: false, message: "Signature mismatch" };
        }

        return {
            success: true,
            decoded: await cryptoEngine.decrypt(encryptedMsg, hashedPassword),
        };
    }
    exports.decode = decode;

    return exports;
}
exports.init = init;

  return exports;
})());
const decode = codec.init(cryptoEngine).decode;

/**
 * Initialize the staticrypt module, that exposes functions callbable by the password_template.
 *
 * @param {{
 *  staticryptEncryptedMsgUniqueVariableName: string,
 *  isRememberEnabled: boolean,
 *  rememberDurationInDays: number,
 *  staticryptSaltUniqueVariableName: string,
 * }} staticryptConfig - object of data that is stored on the password_template at encryption time.
 *
 * @param {{
 *  rememberExpirationKey: string,
 *  rememberPassphraseKey: string,
 *  replaceHtmlCallback: function,
 *  clearLocalStorageCallback: function,
 * }} templateConfig - object of data that can be configured by a custom password_template.
 */
function init(staticryptConfig, templateConfig) {
    const exports = {};

    /**
     * Decrypt our encrypted page, replace the whole HTML.
     *
     * @param {string} hashedPassword
     * @returns {Promise<boolean>}
     */
    async function decryptAndReplaceHtml(hashedPassword) {
        const { staticryptEncryptedMsgUniqueVariableName, staticryptSaltUniqueVariableName } = staticryptConfig;
        const { replaceHtmlCallback } = templateConfig;

        const result = await decode(
            staticryptEncryptedMsgUniqueVariableName,
            hashedPassword,
            staticryptSaltUniqueVariableName
        );
        if (!result.success) {
            return false;
        }
        const plainHTML = result.decoded;

        // if the user configured a callback call it, otherwise just replace the whole HTML
        if (typeof replaceHtmlCallback === "function") {
            replaceHtmlCallback(plainHTML);
        } else {
            document.write(plainHTML);
            document.close();
        }

        return true;
    }

    /**
     * Attempt to decrypt the page and replace the whole HTML.
     *
     * @param {string} password
     * @param {boolean} isRememberChecked
     *
     * @returns {Promise<{isSuccessful: boolean, hashedPassword?: string}>} - we return an object, so that if we want to
     *   expose more information in the future we can do it without breaking the password_template
     */
    async function handleDecryptionOfPage(password, isRememberChecked) {
        const { isRememberEnabled, rememberDurationInDays, staticryptSaltUniqueVariableName } = staticryptConfig;
        const { rememberExpirationKey, rememberPassphraseKey } = templateConfig;

        // decrypt and replace the whole page
        const hashedPassword = await cryptoEngine.hashPassword(password, staticryptSaltUniqueVariableName);

        const isDecryptionSuccessful = await decryptAndReplaceHtml(hashedPassword);

        if (!isDecryptionSuccessful) {
            return {
                isSuccessful: false,
                hashedPassword,
            };
        }

        // remember the hashedPassword and set its expiration if necessary
        if (isRememberEnabled && isRememberChecked) {
            window.localStorage.setItem(rememberPassphraseKey, hashedPassword);

            // set the expiration if the duration isn't 0 (meaning no expiration)
            if (rememberDurationInDays > 0) {
                window.localStorage.setItem(
                    rememberExpirationKey,
                    (new Date().getTime() + rememberDurationInDays * 24 * 60 * 60 * 1000).toString()
                );
            }
        }

        return {
            isSuccessful: true,
            hashedPassword,
        };
    }
    exports.handleDecryptionOfPage = handleDecryptionOfPage;

    /**
     * Clear localstorage from staticrypt related values
     */
    function clearLocalStorage() {
        const { clearLocalStorageCallback, rememberExpirationKey, rememberPassphraseKey } = templateConfig;

        if (typeof clearLocalStorageCallback === "function") {
            clearLocalStorageCallback();
        } else {
            localStorage.removeItem(rememberPassphraseKey);
            localStorage.removeItem(rememberExpirationKey);
        }
    }

    async function handleDecryptOnLoad() {
        let isSuccessful = await decryptOnLoadFromUrl();

        if (!isSuccessful) {
            isSuccessful = await decryptOnLoadFromRememberMe();
        }

        return { isSuccessful };
    }
    exports.handleDecryptOnLoad = handleDecryptOnLoad;

    /**
     * Clear storage if we are logging out
     *
     * @returns {boolean} - whether we logged out
     */
    function logoutIfNeeded() {
        const logoutKey = "staticrypt_logout";

        // handle logout through query param
        const queryParams = new URLSearchParams(window.location.search);
        if (queryParams.has(logoutKey)) {
            clearLocalStorage();
            return true;
        }

        // handle logout through URL fragment
        const hash = window.location.hash.substring(1);
        if (hash.includes(logoutKey)) {
            clearLocalStorage();
            return true;
        }

        return false;
    }

    /**
     * To be called on load: check if we want to try to decrypt and replace the HTML with the decrypted content, and
     * try to do it if needed.
     *
     * @returns {Promise<boolean>} true if we derypted and replaced the whole page, false otherwise
     */
    async function decryptOnLoadFromRememberMe() {
        const { rememberDurationInDays } = staticryptConfig;
        const { rememberExpirationKey, rememberPassphraseKey } = templateConfig;

        // if we are login out, terminate
        if (logoutIfNeeded()) {
            return false;
        }

        // if there is expiration configured, check if we're not beyond the expiration
        if (rememberDurationInDays && rememberDurationInDays > 0) {
            const expiration = localStorage.getItem(rememberExpirationKey),
                isExpired = expiration && new Date().getTime() > parseInt(expiration);

            if (isExpired) {
                clearLocalStorage();
                return false;
            }
        }

        const hashedPassword = localStorage.getItem(rememberPassphraseKey);

        if (hashedPassword) {
            // try to decrypt
            const isDecryptionSuccessful = await decryptAndReplaceHtml(hashedPassword);

            // if the decryption is unsuccessful the password might be wrong - silently clear the saved data and let
            // the user fill the password form again
            if (!isDecryptionSuccessful) {
                clearLocalStorage();
                return false;
            }

            return true;
        }

        return false;
    }

    function decryptOnLoadFromUrl() {
        const passwordKey = "staticrypt_pwd";

        // get the password from the query param
        const queryParams = new URLSearchParams(window.location.search);
        const hashedPasswordQuery = queryParams.get(passwordKey);

        // get the password from the url fragment
        const hashRegexMatch = window.location.hash.substring(1).match(new RegExp(passwordKey + "=(.*)"));
        const hashedPasswordFragment = hashRegexMatch ? hashRegexMatch[1] : null;

        const hashedPassword = hashedPasswordFragment || hashedPasswordQuery;

        if (hashedPassword) {
            return decryptAndReplaceHtml(hashedPassword);
        }

        return false;
    }

    return exports;
}
exports.init = init;

  return exports;
})());
        ;
            const templateError = "Invalid Password",
                isRememberEnabled = true,
                staticryptConfig = {"staticryptEncryptedMsgUniqueVariableName":"bc489837461314fd95331f6ad8edb359bd782206fcd7deaa974e891d7c6b924d2587720b18bfbff611afee2044d18c484dbfa713e58cdb008a5b21417a32766821a302011aa1a1223d972ea59bec68289a44baef15c6c9f0eb10e59f36040a2c72a12c58ea9a8ad4741e9bde902dd70c3ac6887061b6599a7768bb0801a494ab43c62d711704a70bb23c58e2d443fe028e9ed79a5212eac8f9bf11fa54dda104296f42c873aa4bb1bfddd9e4a1d4c30bdefe2b59a23a290a087df3a306aacb7e8432b4cec8ddfc69ba4b498ed23ad92a208d8b96159cf0be203cd0c53de0f3f48a152076efe54c1492117bc90d5d36d7594dbda1ab4f71888c50c00af6126b8a01601659afc8ce8fafdddeadef2e64c21a9f3e804200246ebe4f364a7f39c8e0405312c239df450e4c0fe6762da3350187bd44c24ec5be905cb81611c1bc56f7a67e5a811d0f1b16b1ef5c3162164b8a8368f505f7a17ff3cb99d46eb961180d18b9f48d2ebc9e6d083e6882b9e8f49f567c4a737499528ce8a7f4f507c209822ba9565dd1444648fa74637a136aa5229b30a5f3f41de834abfcc81ac9403da62952b1d643f6fff9b9605a374eb2e171a77d023d5c90e2b4e9525598a87d862b8e8618656e267d0f41d168ec1a378fac83838ae6eceabf99b4aa73efd54ba8e90101ada26349b20a91ecff4a944fb4bec570212868fb06c15cb2ccf80cee4cfe6e9d882a2a212a9a3bb926fbdeb86bf75a7ae45969be7ea5d4693c660e0876a299e042ff08cf42e817833adb3753349d342f49ef6a52a6792a464b7f6330f78e259a9dd20a22e8141729ac8ef84cf7ad8a456b4758db94d0f9a032834d2141438528a36763e230010244531e335edd37f8392fbba93dafc0c1a04ae8279a34d4d2b9c9c4c90367f35f4e12ea832f3185a5c6638968fadd0050b6c1426989f70036a344bcf8592e84b68a6292827df5dcb04f1edf39be9cb437f36e1c440f185d66fbf561f019a8dd2da87530540722eb2957905f4a3f2cf0aadf7dfd79d4e08fea7782931ed8b03e9a02e9e8600dfee3e49a3533cfb76e1e411d3b00262292920dfdd60e940a6c4644045ea28b330e17197ad42b9bc9224bfef4844e341ec882c632ab28012e0947c5e61042f9b93a468b4dbfe9e1d5da20ff03a7a71fc8e4d05a2b019a3690e7e8f8c51cd2f3fb233ec054591699e0f4de6dcc4bcaf374a55f14f3c8d61143b7ec09d47126491faf3f858a105a92b707263bbddcfbaf8f50116a4acdecfb525c511bc79d90374f198b22c63d7b12657cc4639de99787378ddc3e816047c3e2e27a8096c3fc28174ed00dcfd526a5917fc093193393526afc2298bbc8fad91ecf6ecbcc41df64203581b267cdad846d4b3dcc59b03656069d5cdb343b57eaccf9cfdcf120546dbaa626f92e345aa235d3b7db208cbda888ebae422cf9e269ac4a9bbea4130ca113dcb6f2135a375e17cca260b057f383243e6a40e8a51600670535d6f59efb5f2e06235d2250fdda6f8ad761f90df7efa168975096655b8b8c42ac922163dfe17b458a15a5fd33f2702914db121e60d7b3ba82450410303d17c789f3f4e385d12d422b6b2a65462841b835536f27a15c36455da6ebc6890b58e5d788e3e8e35bcc8e888d942b9803707113c3d0bf4903a6bf63605ada36cc214344a43205970e71ed6ef9cb2c2376339a356ed39c6dedc2833facb6f225a5a4336f2d11d5a706e0d5ca323a4187d854ce40b4660abbdb327e7078b17b4ca4eb5466459d2ee92b564990946beb83ac04fa6c3f4ccbf06e633f205d1b8894e09db84ae888ecd8fe6a74805a98106c3de820624432ab28eef5512a92211ad14b384c841049c146ca6b62a2305870ad3955f658404af82e798e3e7239c6dfd9894c66a1add9a992fc932a78cbbe977e499b080c72aaad70d5eedaa0269ca4605c7107d6eee3cbb2d26ae989fce4ddcf8c8ef8776a53cc81f350fe8f39c8f58488040d3acd46a0703a33bcecaf827192af983b2ea4a45b69a47334640dd08be89ffa8a671496282620717838dd7b761235c19169d8336b1f48637b2950f1a277dca647023493c5df55e1a5725e0385ef53f1a0fa7b47af989f252c7874574766c2d765e74783c983798474d35cb7365024e3ef470ef713e046f00ca3c41c4ae75c609a4c44437cc3c2af32e5a414c38b44ba12307eb26199fe1c04c30d59322caf9dc9074035c40db95a627936f58f151b3bf10c6a758c97bb0f336997426ff208751aa145e581abdcba482c1b7e179ccd15762a50c1d779d420de5172015e4704306d64eacc037bb1c90b40bfac48d1237f28c737c22ec6c1b80a5c1e0c8dc6f598aee3312728721fee9427f3dbb77471d6f64eb01edc7f472d850fd6b6c36b9a47e71de0e4132c034e72689fc52518d42d67c40cd86e41d2d5c6fb0a75afe0c362a4250162b51d846c5fd3c43fb5822fae2e71b2d509b66603bb1bc99a73f0a1db58904c060715da2693a8ed47920762ced3f62ce23905d24621086f74315f17c490cb825d2960f15ff70b008029d0910535afb4587b5ed14de7f5cc890aaa0342fc10965ebdca2a02435ff4a281a61b99db052b21b904b0f6ce0b46b3a087a5ae383527e355dd98a47ebf3a378a74a0e4c55ec41a5905298fddff505393dd581925d75a50710f71c7f39d06f588719aa699c1b04a212228f1e14b7a4834b82083aca52de951d7c0438d4a047766f44c6794552701d66a433ffbf7eeaf7958353ed633719fec62acbeebb84544879c9e38a5aed2233bf9607ceb19466459c7dd0003c0d34daa748dd13207961e1d253c124245af5c5c123b2d294b53d89e19cf0f5c8d28b088a95bd00df266e0e307fb4afb36442327e237f5bcfb70371e8c5b04a2e87a8b50176961cd104dc043ba29fce6812e8a758880746e55adf783dfb2d4236c92e1f674d7d47ebe7efdcea779a0833d5ae06989fc9af73aecd7a06f165e43e049b5ac0ac28437f46761fa850d8d1833fb4c6facb5f0a01bc9bf4e74a985da66891d349c576880d9325fa0430929ac05b845bf5331838607f4f5b397027c1c74ad07db6995799cc31b906eea40c0405d7a6fa0438672c9a9dd95a1b78bf6abac92095dd222dc7bc86bfc6fa01f4bd2618fdab6378258ff17ecd0dbb69ce8f600b84edc5973ea8eb652f0211a1320947fd7074030532d6bc2c59c23654d84b4ae14489f6c93f44d6bf55d045dc173e2c42fa1d5c2e05e97bdc6f30b3d0b03d2682dad54754a4ea1071d6aa995906674ef229eeec016d867667c1f60bf401ece0ae8ddf1b17a4beebace5c11c9749955872d48ebecf6b993083929b86ddfe49c72b1e79cca31d58fb6cac5bc3924d84f62215ab19e26cb23a466b7c3d1d127f1f9bc60792790bcbc4f7394386a5af7973d4bf008397aba96c44741735555aa141086300ae917e9dce3b3f0d25a795710eb7c872cb2518d26b38f85363fe18c5d6f678c2b400f9c490e273dff69b3ff2506f05ac447817763ecdc1ff7a7f6147680f2f0dda7755e4a3dacc57d7b58fd93a2ff42f5a1c9162b586a912e3136cca0c5fd9dbdc14673ac1060a475ecf0b7ae702e96d016ea696f51a979feba3515193fcd9e7ac9f5f5e23c4061bc2cdbb85fee6b224dfa373bee311020dfe0f1fc09c4c5fdf4fe82e1681199b05086f5777039b051e432d9d37b50141d7140247623a33176923dbe763df149a345336c262b59987d4b75d449d5802362aebe33d7e447fe1882d7ff7cfd1fc1fb533000863b42116b86b25433e0f1c4a1ccbe19ddc493619599fd4a74ef649071f24016a21ea420476f3aa24c58f905db851b0bdc26580baedf3ce4e878ea69d0503b4eef65f8f0dc9c509963cff645a706100442ff32a1ab66674d58e5c3e5095d28271200e51508cd26fc006adbe98f919fdb9d0da63ee3691dd0a6f2b140741fccca0421784c3e3888a6262cae88ed30f732997f2fcef66d767f476aaa8a683edd13f7bf7ea1451bb4ffd4dcdf40eb25c62fd9dd00960351d7e4fe4d4a2a105a1c14f7dfda14e6c2628425986f022bae608a7cd5556422746ec6db724c29fe222d4b30692dde524c3d309739613e1cc87deaf33737af18a8d66db6bb003a51bdb444333a050ec4f77e2b7b8cdcf705414fcc1648351b4c6dae32595fe9b8deddb244670c8da3019dad94bb90541f841cb986daf25f2807b13c4140a2ed9e76ff2edecfd270da69e2a919769360ea31e865032f22913b45f9de4d7a114a46614b14e45073865b3479177061daa719fd304971c717f44f10a5542fec5d763b646ee88b2b98e26b57ea9da823fe7f16cc2f0052c94e4dee93b086ab5e0408e073b3f49bcf1db0088b6b1835dc891de78f5be0f0aaaeb41addd6b49371536fec979e76f1730dd97271a6a8fea8a3cf93b59698d9e3e52a747b1769c88e67dea6be9a4751b56e5d07709f7480f1c30a7cb921c278c9d594327e2514189974ffebefbfdf23eaefe41dcac79ae5a191ab20bdfbc7b05d8fe53c379dc56dcbdf3368623b56582cd917a083ef3c9f17c2eab67a31184d5f4f72980daebedec31910fafb52dd28acba7e244084f27abe401e3c0912eb9d4dbf30f3faedb36392355cebf4325b6646aafeef34fa68e124de13fa0447075cb74d167f5be016bf77c60a0fa149cf2ab328502003a800929d4ab17303c5104f610106b99ba3825f258802bcda4a9fbb50d2d0fb9d1e3ea3bb3b959c226d643dd579cdd30708e2dd6afa230c3d3ef311e94d85dc78fe6be442aea29ce4f50a7ffc0da4c84970e7fe052b51fa3f13c99134d22979629a0d3623501c88d5fd301e515822a85cf3c979f0eaef6f431a0cfb90411f6ff5acfe4630ef449def543052061d705304672fd63887ec64fc26c6be5b2e167f3449d4ca478fe4c59be779a228cadf73b623e0f8364eef28e60f0a7d8e7a057153627edd34e18593c1e85842d2a17c64cfdfc22f48f1b44bd19ed1dfa32356f35d68ae795f1b7668ccd76d95ae83273fa0647dac2e02bf4ea5e34d478ce091aa8343df0ad94bb5eb192ca4755251b2adbdbb6042d87dac3973508a2eed0f75680be6287a75ca11ae7cbca232ff0697e0a13b688b6565b6ed14ae90233b0c942f1ae1733e5aaf633655b83c4564da10bd54387627b0a3e8f42bd216247c704ab2fdb85f16d1f6a90f31b35400906cfc6864da69975613c0c28e4cd0ceaf158d6a5d68be530720f74303d07cc9f4265f8004e22ae5df7a499983fa967faa6f83d7d03672bc0d07cc5d83aa816940ade3f8ff449fa6f0c219edd40523ef66f7faebe5c020da994e8f60b6858a7a2ba3d3c759ddba6590551a1a7b3536cf344fb7e99e5fd6e1aa58f9d2efcf2d8c672240fc2000b5287dd624920358b44241b5e4433927093ec4a2c6ca4f4819987fb29de6bfd4993742f086a86d3768d7409288ca6069117e9ad423a505b463ec36e601b8547c3dc6760835a522ba4206d286590632ea156fcf906f1a0be5bdee5fd7ed4016b2b1b277c024609fc3f5b02756492793c3cd6d79de22596deabc065269cde39203f0625464712c26378a22b76bf7bd71a3495dd082781af39c7642245aa086da103c754eca641d15efc16b17050d142f1c9a0d06c45460d8278de3792759133304a724ec964a8da003bbc6e42763c0fe7150ab1911583719d1b687e256b5385b36e6a43b886420e9cd5d6d93d520bc7ee80dd43a3c1df71f187c52406a87b07b2f6fae6922462102900d7becdbf66060e4b69dd2ba8357f3d3a920e3c0e7cf89bcf512ad5713fbba83f0325498451c8122c1adce436352dceac57dd7fd4cc19a21641ee44b7fd55f85a9c85a5d93760184ea434ed19103cfbc0a24e124e006ae95f27905ade8e1ca886941d297d27967f0cd00ed2264d4091c4200b4da67d86b852a1044caa81cb9f18075744e5fb3b4137192b82f006fca6061003034f4bc04955b263a3ee83c3d72c6290646a8779e3a72b0bb1cd83df53845e44c696e088b61507e0e65c4ac6d10dabea01a22bd29a2d2b6ccde0e6e9fdcd714f659543f7a2200a66f56182a8e378952dc7d05519466f21f0f9e83e87f33f3c20859367f2979dcb3db5215cbc89706133d1a8a18173ad3894c7d50e3e0036529090637cf11a134ca597158f20125e844985dcbe29fd91e0d57ff735afc43d2f5308d7ab5fa6f8d3217774ddc24ad1a5d9437540b94efef40f04ea1e1cfc444be0324603e04588db8ec620b08a7c5460b05189ca003c5bfe835af594db872447229a65e7c7f68d44156e2a6e3ed5e682dbcc58d30f09d1cebf1f19752b65ae4b21e5540ed54111fa254399c84567e05f55102442b725523eb09026bf1059268e927acc56401c6e55b058f1d20ccf6f360b1f3598cacf6b6b6d4343ef1e9deb17c8e3bbda8280fcfd90b2ac736b2fc14d3d254963e2dbac553b02214ace29aacb9b9810a77ef65bddb0b4668d600e9b9711cca44cbc919b555644218779c3e0f78f41f9b60dab90eb0181c73a2d936dc40324dac349c1c46904ed3ae771c5c505daf765a7aa38665d84cea2590365158b5c18040b8548a378e65eaf65964da393f062b6a0977cd70861d6524d7ec3196cddf9ed1496b7b9ff3e4256aaf0cb503d82649acda18c319f7f59690915991689a0f8c5bf651a03db81f3cd5d1b8226a383779029564fa632b167cc606fe5c17f13c771d4471d77b9598b6a1877a7b2690f9edf2d78f6aaa42654ebf4335b123db45622558bb50c690a08781435e51d9967439ffc0f93b20a89513fd797f048a68d85932e11a448ed3a7034ee596e7958acb0cabe00f190ffdb73c1393f37ef72d210f82dd48f1b97c19816f6f226de42020da034628c1b220e00548b2420c6d476aa63b6efae048e8b732bba6e94afd12ea9e4f07d62f27e70c6c6f0d50642a6e6039a3a9f1f3cdc9195bbec7f5996afadd456c80e2807c1d7fb65a13b75776f3728182a7dee8f434eaa827b12dff20e7f2689d25d06411e62864179de53d6847f8f99e0f1222fc61d1599e3a0c891b473d10f5c1c9b0c039af34c68c5c0cb7e3bb1494912a951603efa24cd53c557a5af3ba7385fc99cd47233e049abc8a07b2320ca728bb5f98e03a83b0188a4a6b192a17a99f357f49b07f6400941a8e87b700d70e7ead59efce60d27b687d7e513cb3afa932b15cca325dc375f49b61b850360c886d631d333cdf926fc8fd6c0a9921e1fd1b005d9e9a67f50f8807754017702a03fa5248a4986b80f18b66a85aafacf25520e8d022091a6c271490a67119d4b86e377c99685f27ea504bbed2e81895cf71518e9d9b0a83287759be146ec181de6df8ccb1b056b944cae1ef051d8405002e5f9c9cf60a0e018223a0d496b5fdbc3667e126ff71d9c7724488046c9007950071586956cfd64323dc09454ebdd3c1a1847c3c3767ca86160c7acb1fbecec0235673c010222485e5942ef08660827334e343077914c459e87e5f7537a0aef5709c4f744bd91b64ff040e2413b4ed07acdec79e6fccb472ad2a58c7ec35e9b64394700d9714989b735196439ff4c4bc592f074652a6bbdcb6ad10eecaf5cc3bdab613f56e3a4ea1d42bc953b38404232eafd800c782780d6ebc96437473e5422ea604689ecf89945bde1bd247cbd2cb1cf0a802a883f7093bcd02e36f8903149f29458b7beefe2a838e85d75e2bc25b4869ade9cd3def69c00dd931c6bd894f617b939fe11fcaab7baed3338ba967a78d70e8d5c0748b75716dbd0e8fa01e878e4470b96e89f4a9031b32c78ae6125ba1b10c5630eb8426b507d3760430e0eafedebc115b0baf65ccd07403c445c10722d9dd7742d93786dc840b434d5ef0c4c039fb06baa6db148ae5f2b982ac13326f153805e571fbfb71e47bd46e6fd5028df3912be8f7153be205891e18e05307481b1c6f220c8d43b2907bb08881f06c9dfaa7df4fe74f1cd545e307170f95fa590b167f006300ac47c7cd98e2a4547e3e0d844d0e30c2d131bcb4bc8594253c6e03b7d6464da990fa88732d50876a2121fd08f3294076f35492702c78080b4f66124f03a3e1f845965b07fd30cab3a018feb7dfcee8bf31312add764ffea6093b8bae19b3e49c5875b9894ae649be5574d7781734bbaddcbdf0aac87de348da85f6355ac18c679484d91044450b7c3b89d0339711a76c70d76ff451678bc408a0aae1f33975fc97ff69ddf2ec48279b4aa06c81e0269ba6123bad223d14f7f82e5f9e2b56576252ff5ea9391a3d767e30e59db84908087b3951f73c1208ba2d0d010126a7803002ede634d2b6834b7e46cc7899f7e3427ce2d27f9d34cf9c6055e9a7c712a245d7a72dda82ef96134550fbf9e560587e4b9908557c0495f3bd1dde0ce4c5ca0ad22678e4c314b1d1e0234b054f5939061f4c2494c458f5e535e0887aa111dae9c961b6b03c9bf5fe279c107cc00c34ab5dfdc99252d5a122b6cce6d7c2f7f307756d5a82ce5324d94b3c12ca2ebd18abddadc553641c52de69d31beeb7aa68309be3ecaa13610ee5a94ad388571db951372523a8a5ef38cdb5dd41066fd727915863c65f34031da21c1e6508d553ac301f611fa33410a6841f700d39d475e882d8e7be09061d2614d4cf24aac4f31d0f1cc0711b13ce136ad3129ba900381271217895dceb50d23960c3510c4746e04c4f83b19f479faa26bb9ced3f8e6a98ee1606e1b29f07717cbae12c7e1e983dadc7827d5edc016e9dfad520e8cc18d21bae766f8c7ce7bc906a00dc9113b0a63eccde77e2afb1367bb98670d23525b4a81d6d88502129b95da45cd73bfa7d3e1dbf03ef93dc0492026541e4d130a642d4cdb6637a2093878e97cefa64de67ebc0c9387b5bbcc29d874506e2e45bd40197c592f5e49f30b29efa0ccb02e1d820f6d06438b0545fbc5bf9ea6444eb4d009b6e8bce1b2b9fc05c816535b5873c3131156060dc19c1b7ae34bc82ff6ae7d9a3d23ba1e65c19d7610c83a0591ca0db311acccadc89b51694048c758bb085fcccb1a88a8b584b498e95d15ecf4f0617406df5d3a401237f45b8e12584b327af7ba026fbf33d2c50e43754b9377f0ef7b367dbfcd8b9ea7beeb0be4252ceb5c9c6641a341dbf259962eba61089792fddbce329b2afa1f0ed6fd25a67ca4bc7ac5ab2f7b3a49de0ffd1e9c4cf04f7d51ec606811253ec5fc38c03cc5e390800cf9f49f0839cff229e4fb00b39716cc4f069c56444ca3513cbd4ee606dda571f679e34b6cca451e9d87e00fe20c3cb20a0b35aac18e81cb91b386550c58d85eba46574b38425895906dc9b2c69194686fd6dd8b41b67edddc5b9cacc947838182b1d6b9f424678f03efb54c4cb7d4ee5d04a008d265ddf7ecfc2a9fdcb7c24b438f73ddd38fcff40d97fd649230734ff2835ae63d29708e75f65d847ab6e712355c5671e1a9555c1e97cbc27d088bc5dd4b5b92ab44e39ebb0ba1e3650011dbfdb44f29848a7be69796be583357b871b4977b40a2f4e16c97a8aa584e6b17b78a3d9a6bcc2e7b3a94c796b384b044b50ad4acde8a144bb38bb08537992554a705b3038e10d5ddba3a87a4fdd900621adbff261d771016ffd1c84f8dacf4e66463a7b773ef191488f6388f00a06000ee30750cd0a40d6abe5fe4f19ade45cf2fbbb63c81aac7bafabe9dc201bd6d352ba7df1c083","isRememberEnabled":true,"rememberDurationInDays":0,"staticryptSaltUniqueVariableName":"1ac6c72322922e263870cbacf6d40e4b"};

            // you can edit these values to customize some of the behavior of StatiCrypt
            const templateConfig = {
                rememberExpirationKey: "staticrypt_expiration",
                rememberPassphraseKey: "staticrypt_passphrase",
                replaceHtmlCallback: null,
                clearLocalStorageCallback: null,
            };

            // init the staticrypt engine
            const staticrypt = staticryptInitiator.init(staticryptConfig, templateConfig);

            // try to automatically decrypt on load if there is a saved password
            window.onload = async function () {
                const { isSuccessful } = await staticrypt.handleDecryptOnLoad();

                // if we didn't decrypt anything on load, show the password prompt. Otherwise the content has already been
                // replaced, no need to do anything
                if (!isSuccessful) {
                    // hide loading screen
                    document.getElementById("staticrypt_loading").classList.add("hidden");
                    document.getElementById("staticrypt_content").classList.remove("hidden");
                    document.getElementById("staticrypt-password").focus();

                    // show the remember me checkbox
                    if (isRememberEnabled) {
                        document.getElementById("staticrypt-remember-label").classList.remove("hidden");
                    }
                }
            };

            // handle password form submission
            document.getElementById("staticrypt-form").addEventListener("submit", async function (e) {
                e.preventDefault();

                const password = document.getElementById("staticrypt-password").value,
                    isRememberChecked = document.getElementById("staticrypt-remember").checked;

                const { isSuccessful } = await staticrypt.handleDecryptionOfPage(password, isRememberChecked);

                if (!isSuccessful) {
                    alert(templateError);
                }
            });
        </script>
    </body>
</html>
