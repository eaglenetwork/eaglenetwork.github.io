<!DOCTYPE html>
<html class="staticrypt-html">
    <head>
        <meta charset="utf-8" />
        <title>EduLock</title>
        <meta name="viewport" content="width=device-width, initial-scale=1" />

        <!-- do not cache this page -->
        <meta http-equiv="cache-control" content="max-age=0" />
        <meta http-equiv="cache-control" content="no-cache" />
        <meta http-equiv="expires" content="0" />
        <meta http-equiv="expires" content="Tue, 01 Jan 1980 1:00:00 GMT" />
        <meta http-equiv="pragma" content="no-cache" />

        <style>
            .staticrypt-hr {
                margin-top: 20px;
                margin-bottom: 20px;
                border: 0;
                border-top: 1px solid #eee;
            }

            .staticrypt-page {
                width: 360px;
                padding: 8% 0 0;
                margin: auto;
                box-sizing: border-box;
            }

            .staticrypt-form {
                position: relative;
                z-index: 1;
                background: #ffffff;
                max-width: 360px;
                margin: 0 auto 100px;
                padding: 45px;
                text-align: center;
                box-shadow: 0 0 20px 0 rgba(0, 0, 0, 0.2), 0 5px 5px 0 rgba(0, 0, 0, 0.24);
            }

            .staticrypt-form input[type="password"],
            input[type="text"] {
                background: inherit;
                border: 0;
                box-sizing: border-box; /* This ensures padding is included in the total width */
                font-size: 14px;
                outline: 0;
                padding: 15px 30px 15px 15px; /* Adjust the padding to ensure there is space for the icon */
                width: 100%;
            }

            .staticrypt-password-container {
                position: relative;
                outline: 0;
                background: #f2f2f2;
                width: 100%;
                border: 0;
                margin: 0 0 15px;
                box-sizing: border-box;
            }

            .staticrypt-toggle-password-visibility {
                cursor: pointer;
                height: 20px;
                opacity: 60%;
                padding: 13px;
                position: absolute;
                right: 0;
                top: 50%;
                transform: translateY(-50%);
                width: 20px;
            }

            .staticrypt-form .staticrypt-decrypt-button {
                text-transform: uppercase;
                outline: 0;
                background: #4CAF50;
                width: 100%;
                border: 0;
                padding: 15px;
                color: #ffffff;
                font-size: 14px;
                cursor: pointer;
            }

            .staticrypt-form .staticrypt-decrypt-button:hover,
            .staticrypt-form .staticrypt-decrypt-button:active,
            .staticrypt-form .staticrypt-decrypt-button:focus {
                background: #4CAF50;
                filter: brightness(92%);
            }

            .staticrypt-html {
                height: 100%;
            }

            .staticrypt-body {
                height: 100%;
                margin: 0;
            }

            .staticrypt-content {
                height: 100%;
                margin-bottom: 1em;
                background: #76B852;
                font-family: "Arial", sans-serif;
                -webkit-font-smoothing: antialiased;
                -moz-osx-font-smoothing: grayscale;
            }

            .staticrypt-instructions {
                margin-top: -1em;
                margin-bottom: 1em;
            }

            .staticrypt-title {
                font-size: 1.5em;
            }

            label.staticrypt-remember {
                display: flex;
                align-items: center;
                margin-bottom: 1em;
            }

            .staticrypt-remember input[type="checkbox"] {
                transform: scale(1.5);
                margin-right: 1em;
            }

            .hidden {
                display: none !important;
            }

            .staticrypt-spinner-container {
                height: 100%;
                display: flex;
                align-items: center;
                justify-content: center;
            }

            .staticrypt-spinner {
                display: inline-block;
                width: 2rem;
                height: 2rem;
                vertical-align: text-bottom;
                border: 0.25em solid gray;
                border-right-color: transparent;
                border-radius: 50%;
                -webkit-animation: spinner-border 0.75s linear infinite;
                animation: spinner-border 0.75s linear infinite;
                animation-duration: 0.75s;
                animation-timing-function: linear;
                animation-delay: 0s;
                animation-iteration-count: infinite;
                animation-direction: normal;
                animation-fill-mode: none;
                animation-play-state: running;
                animation-name: spinner-border;
            }

            @keyframes spinner-border {
                100% {
                    transform: rotate(360deg);
                }
            }
        </style>
    </head>

    <body class="staticrypt-body">
        <div id="staticrypt_loading" class="staticrypt-spinner-container">
            <div class="staticrypt-spinner"></div>
        </div>

        <div id="staticrypt_content" class="staticrypt-content hidden">
            <div class="staticrypt-page">
                <div class="staticrypt-form">
                    <div class="staticrypt-instructions">
                        <p class="staticrypt-title">EduLock</p>
                        <p><p>Please ask Clark for the password to this marvelous website!</p>
</p>
                    </div>

                    <hr class="staticrypt-hr" />

                    <form id="staticrypt-form" action="#" method="post">
                        <div class="staticrypt-password-container">
                            <input
                                id="staticrypt-password"
                                type="password"
                                name="password"
                                placeholder="Password"
                                autofocus
                            />

                            <img
                                class="staticrypt-toggle-password-visibility"
                                alt="template_toggle_show"
                                title="template_toggle_show"
                                src="data:image/svg+xml;base64,PHN2ZyB4bWxucz0iaHR0cDovL3d3dy53My5vcmcvMjAwMC9zdmciIHZpZXdCb3g9IjAgMCA2NDAgNTEyIj48IS0tIUZvbnQgQXdlc29tZSBGcmVlIDYuNS4yIGJ5IEBmb250YXdlc29tZSAtIGh0dHBzOi8vZm9udGF3ZXNvbWUuY29tIExpY2Vuc2UgLSBodHRwczovL2ZvbnRhd2Vzb21lLmNvbS9saWNlbnNlL2ZyZWUgQ29weXJpZ2h0IDIwMjQgRm9udGljb25zLCBJbmMuLS0+PHBhdGggZD0iTTM4LjggNS4xQzI4LjQtMy4xIDEzLjMtMS4yIDUuMSA5LjJTLTEuMiAzNC43IDkuMiA0Mi45bDU5MiA0NjRjMTAuNCA4LjIgMjUuNSA2LjMgMzMuNy00LjFzNi4zLTI1LjUtNC4xLTMzLjdMNTI1LjYgMzg2LjdjMzkuNi00MC42IDY2LjQtODYuMSA3OS45LTExOC40YzMuMy03LjkgMy4zLTE2LjcgMC0yNC42Yy0xNC45LTM1LjctNDYuMi04Ny43LTkzLTEzMS4xQzQ2NS41IDY4LjggNDAwLjggMzIgMzIwIDMyYy02OC4yIDAtMTI1IDI2LjMtMTY5LjMgNjAuOEwzOC44IDUuMXpNMjIzLjEgMTQ5LjVDMjQ4LjYgMTI2LjIgMjgyLjcgMTEyIDMyMCAxMTJjNzkuNSAwIDE0NCA2NC41IDE0NCAxNDRjMCAyNC45LTYuMyA0OC4zLTE3LjQgNjguN0w0MDggMjk0LjVjOC40LTE5LjMgMTAuNi00MS40IDQuOC02My4zYy0xMS4xLTQxLjUtNDcuOC02OS40LTg4LjYtNzEuMWMtNS44LS4yLTkuMiA2LjEtNy40IDExLjdjMi4xIDYuNCAzLjMgMTMuMiAzLjMgMjAuM2MwIDEwLjItMi40IDE5LjgtNi42IDI4LjNsLTkwLjMtNzAuOHpNMzczIDM4OS45Yy0xNi40IDYuNS0zNC4zIDEwLjEtNTMgMTAuMWMtNzkuNSAwLTE0NC02NC41LTE0NC0xNDRjMC02LjkgLjUtMTMuNiAxLjQtMjAuMkw4My4xIDE2MS41QzYwLjMgMTkxLjIgNDQgMjIwLjggMzQuNSAyNDMuN2MtMy4zIDcuOS0zLjMgMTYuNyAwIDI0LjZjMTQuOSAzNS43IDQ2LjIgODcuNyA5MyAxMzEuMUMxNzQuNSA0NDMuMiAyMzkuMiA0ODAgMzIwIDQ4MGM0Ny44IDAgODkuOS0xMi45IDEyNi4yLTMyLjVMMzczIDM4OS45eiIvPjwvc3ZnPg=="
                            />
                        </div>

                        <label id="staticrypt-remember-label" class="staticrypt-remember hidden">
                            <input id="staticrypt-remember" type="checkbox" name="remember" />
                            Remember me
                        </label>

                        <input type="submit" class="staticrypt-decrypt-button" value="Enter" />
                    </form>
                </div>
            </div>
        </div>

        <script>
            // these variables will be filled when generating the file - the template format is 'variable_name'
            const staticryptInitiator = 
            ((function(){
  const exports = {};
  const cryptoEngine = ((function(){
  const exports = {};
  const { subtle } = crypto;

const IV_BITS = 16 * 8;
const HEX_BITS = 4;
const ENCRYPTION_ALGO = "AES-CBC";

/**
 * Translates between utf8 encoded hexadecimal strings
 * and Uint8Array bytes.
 */
const HexEncoder = {
    /**
     * hex string -> bytes
     * @param {string} hexString
     * @returns {Uint8Array}
     */
    parse: function (hexString) {
        if (hexString.length % 2 !== 0) throw "Invalid hexString";
        const arrayBuffer = new Uint8Array(hexString.length / 2);

        for (let i = 0; i < hexString.length; i += 2) {
            const byteValue = parseInt(hexString.substring(i, i + 2), 16);
            if (isNaN(byteValue)) {
                throw "Invalid hexString";
            }
            arrayBuffer[i / 2] = byteValue;
        }
        return arrayBuffer;
    },

    /**
     * bytes -> hex string
     * @param {Uint8Array} bytes
     * @returns {string}
     */
    stringify: function (bytes) {
        const hexBytes = [];

        for (let i = 0; i < bytes.length; ++i) {
            let byteString = bytes[i].toString(16);
            if (byteString.length < 2) {
                byteString = "0" + byteString;
            }
            hexBytes.push(byteString);
        }
        return hexBytes.join("");
    },
};

/**
 * Translates between utf8 strings and Uint8Array bytes.
 */
const UTF8Encoder = {
    parse: function (str) {
        return new TextEncoder().encode(str);
    },

    stringify: function (bytes) {
        return new TextDecoder().decode(bytes);
    },
};

/**
 * Salt and encrypt a msg with a password.
 */
async function encrypt(msg, hashedPassword) {
    // Must be 16 bytes, unpredictable, and preferably cryptographically random. However, it need not be secret.
    // https://developer.mozilla.org/en-US/docs/Web/API/SubtleCrypto/encrypt#parameters
    const iv = crypto.getRandomValues(new Uint8Array(IV_BITS / 8));

    const key = await subtle.importKey("raw", HexEncoder.parse(hashedPassword), ENCRYPTION_ALGO, false, ["encrypt"]);

    const encrypted = await subtle.encrypt(
        {
            name: ENCRYPTION_ALGO,
            iv: iv,
        },
        key,
        UTF8Encoder.parse(msg)
    );

    // iv will be 32 hex characters, we prepend it to the ciphertext for use in decryption
    return HexEncoder.stringify(iv) + HexEncoder.stringify(new Uint8Array(encrypted));
}
exports.encrypt = encrypt;

/**
 * Decrypt a salted msg using a password.
 *
 * @param {string} encryptedMsg
 * @param {string} hashedPassword
 * @returns {Promise<string>}
 */
async function decrypt(encryptedMsg, hashedPassword) {
    const ivLength = IV_BITS / HEX_BITS;
    const iv = HexEncoder.parse(encryptedMsg.substring(0, ivLength));
    const encrypted = encryptedMsg.substring(ivLength);

    const key = await subtle.importKey("raw", HexEncoder.parse(hashedPassword), ENCRYPTION_ALGO, false, ["decrypt"]);

    const outBuffer = await subtle.decrypt(
        {
            name: ENCRYPTION_ALGO,
            iv: iv,
        },
        key,
        HexEncoder.parse(encrypted)
    );

    return UTF8Encoder.stringify(new Uint8Array(outBuffer));
}
exports.decrypt = decrypt;

/**
 * Salt and hash the password so it can be stored in localStorage without opening a password reuse vulnerability.
 *
 * @param {string} password
 * @param {string} salt
 * @returns {Promise<string>}
 */
async function hashPassword(password, salt) {
    // we hash the password in multiple steps, each adding more iterations. This is because we used to allow less
    // iterations, so for backward compatibility reasons, we need to support going from that to more iterations.
    let hashedPassword = await hashLegacyRound(password, salt);

    hashedPassword = await hashSecondRound(hashedPassword, salt);

    return hashThirdRound(hashedPassword, salt);
}
exports.hashPassword = hashPassword;

/**
 * This hashes the password with 1k iterations. This is a low number, we need this function to support backwards
 * compatibility.
 *
 * @param {string} password
 * @param {string} salt
 * @returns {Promise<string>}
 */
function hashLegacyRound(password, salt) {
    return pbkdf2(password, salt, 1000, "SHA-1");
}
exports.hashLegacyRound = hashLegacyRound;

/**
 * Add a second round of iterations. This is because we used to use 1k, so for backwards compatibility with
 * remember-me/autodecrypt links, we need to support going from that to more iterations.
 *
 * @param hashedPassword
 * @param salt
 * @returns {Promise<string>}
 */
function hashSecondRound(hashedPassword, salt) {
    return pbkdf2(hashedPassword, salt, 14000, "SHA-256");
}
exports.hashSecondRound = hashSecondRound;

/**
 * Add a third round of iterations to bring total number to 600k. This is because we used to use 1k, then 15k, so for
 * backwards compatibility with remember-me/autodecrypt links, we need to support going from that to more iterations.
 *
 * @param hashedPassword
 * @param salt
 * @returns {Promise<string>}
 */
function hashThirdRound(hashedPassword, salt) {
    return pbkdf2(hashedPassword, salt, 585000, "SHA-256");
}
exports.hashThirdRound = hashThirdRound;

/**
 * Salt and hash the password so it can be stored in localStorage without opening a password reuse vulnerability.
 *
 * @param {string} password
 * @param {string} salt
 * @param {int} iterations
 * @param {string} hashAlgorithm
 * @returns {Promise<string>}
 */
async function pbkdf2(password, salt, iterations, hashAlgorithm) {
    const key = await subtle.importKey("raw", UTF8Encoder.parse(password), "PBKDF2", false, ["deriveBits"]);

    const keyBytes = await subtle.deriveBits(
        {
            name: "PBKDF2",
            hash: hashAlgorithm,
            iterations,
            salt: UTF8Encoder.parse(salt),
        },
        key,
        256
    );

    return HexEncoder.stringify(new Uint8Array(keyBytes));
}

function generateRandomSalt() {
    const bytes = crypto.getRandomValues(new Uint8Array(128 / 8));

    return HexEncoder.stringify(new Uint8Array(bytes));
}
exports.generateRandomSalt = generateRandomSalt;

async function signMessage(hashedPassword, message) {
    const key = await subtle.importKey(
        "raw",
        HexEncoder.parse(hashedPassword),
        {
            name: "HMAC",
            hash: "SHA-256",
        },
        false,
        ["sign"]
    );
    const signature = await subtle.sign("HMAC", key, UTF8Encoder.parse(message));

    return HexEncoder.stringify(new Uint8Array(signature));
}
exports.signMessage = signMessage;

function getRandomAlphanum() {
    const possibleCharacters = "abcdefghijklmnopqrstuvwxyzABCDEFGHIJKLMNOPQRSTUVWXYZ0123456789";

    let byteArray;
    let parsedInt;

    // Keep generating new random bytes until we get a value that falls
    // within a range that can be evenly divided by possibleCharacters.length
    do {
        byteArray = crypto.getRandomValues(new Uint8Array(1));
        // extract the lowest byte to get an int from 0 to 255 (probably unnecessary, since we're only generating 1 byte)
        parsedInt = byteArray[0] & 0xff;
    } while (parsedInt >= 256 - (256 % possibleCharacters.length));

    // Take the modulo of the parsed integer to get a random number between 0 and totalLength - 1
    const randomIndex = parsedInt % possibleCharacters.length;

    return possibleCharacters[randomIndex];
}

/**
 * Generate a random string of a given length.
 *
 * @param {int} length
 * @returns {string}
 */
function generateRandomString(length) {
    let randomString = "";

    for (let i = 0; i < length; i++) {
        randomString += getRandomAlphanum();
    }

    return randomString;
}
exports.generateRandomString = generateRandomString;

  return exports;
})());
const codec = ((function(){
  const exports = {};
  /**
 * Initialize the codec with the provided cryptoEngine - this return functions to encode and decode messages.
 *
 * @param cryptoEngine - the engine to use for encryption / decryption
 */
function init(cryptoEngine) {
    const exports = {};

    /**
     * Top-level function for encoding a message.
     * Includes password hashing, encryption, and signing.
     *
     * @param {string} msg
     * @param {string} password
     * @param {string} salt
     *
     * @returns {string} The encoded text
     */
    async function encode(msg, password, salt) {
        const hashedPassword = await cryptoEngine.hashPassword(password, salt);

        const encrypted = await cryptoEngine.encrypt(msg, hashedPassword);

        // we use the hashed password in the HMAC because this is effectively what will be used a password (so we can store
        // it in localStorage safely, we don't use the clear text password)
        const hmac = await cryptoEngine.signMessage(hashedPassword, encrypted);

        return hmac + encrypted;
    }
    exports.encode = encode;

    /**
     * Encode using a password that has already been hashed. This is useful to encode multiple messages in a row, that way
     * we don't need to hash the password multiple times.
     *
     * @param {string} msg
     * @param {string} hashedPassword
     *
     * @returns {string} The encoded text
     */
    async function encodeWithHashedPassword(msg, hashedPassword) {
        const encrypted = await cryptoEngine.encrypt(msg, hashedPassword);

        // we use the hashed password in the HMAC because this is effectively what will be used a password (so we can store
        // it in localStorage safely, we don't use the clear text password)
        const hmac = await cryptoEngine.signMessage(hashedPassword, encrypted);

        return hmac + encrypted;
    }
    exports.encodeWithHashedPassword = encodeWithHashedPassword;

    /**
     * Top-level function for decoding a message.
     * Includes signature check and decryption.
     *
     * @param {string} signedMsg
     * @param {string} hashedPassword
     * @param {string} salt
     * @param {int} backwardCompatibleAttempt
     * @param {string} originalPassword
     *
     * @returns {Object} {success: true, decoded: string} | {success: false, message: string}
     */
    async function decode(signedMsg, hashedPassword, salt, backwardCompatibleAttempt = 0, originalPassword = "") {
        const encryptedHMAC = signedMsg.substring(0, 64);
        const encryptedMsg = signedMsg.substring(64);
        const decryptedHMAC = await cryptoEngine.signMessage(hashedPassword, encryptedMsg);

        if (decryptedHMAC !== encryptedHMAC) {
            // we have been raising the number of iterations in the hashing algorithm multiple times, so to support the old
            // remember-me/autodecrypt links we need to try bringing the old hashes up to speed.
            originalPassword = originalPassword || hashedPassword;
            if (backwardCompatibleAttempt === 0) {
                const updatedHashedPassword = await cryptoEngine.hashThirdRound(originalPassword, salt);

                return decode(signedMsg, updatedHashedPassword, salt, backwardCompatibleAttempt + 1, originalPassword);
            }
            if (backwardCompatibleAttempt === 1) {
                let updatedHashedPassword = await cryptoEngine.hashSecondRound(originalPassword, salt);
                updatedHashedPassword = await cryptoEngine.hashThirdRound(updatedHashedPassword, salt);

                return decode(signedMsg, updatedHashedPassword, salt, backwardCompatibleAttempt + 1, originalPassword);
            }

            return { success: false, message: "Signature mismatch" };
        }

        return {
            success: true,
            decoded: await cryptoEngine.decrypt(encryptedMsg, hashedPassword),
        };
    }
    exports.decode = decode;

    return exports;
}
exports.init = init;

  return exports;
})());
const decode = codec.init(cryptoEngine).decode;

/**
 * Initialize the staticrypt module, that exposes functions callbable by the password_template.
 *
 * @param {{
 *  staticryptEncryptedMsgUniqueVariableName: string,
 *  isRememberEnabled: boolean,
 *  rememberDurationInDays: number,
 *  staticryptSaltUniqueVariableName: string,
 * }} staticryptConfig - object of data that is stored on the password_template at encryption time.
 *
 * @param {{
 *  rememberExpirationKey: string,
 *  rememberPassphraseKey: string,
 *  replaceHtmlCallback: function,
 *  clearLocalStorageCallback: function,
 * }} templateConfig - object of data that can be configured by a custom password_template.
 */
function init(staticryptConfig, templateConfig) {
    const exports = {};

    /**
     * Decrypt our encrypted page, replace the whole HTML.
     *
     * @param {string} hashedPassword
     * @returns {Promise<boolean>}
     */
    async function decryptAndReplaceHtml(hashedPassword) {
        const { staticryptEncryptedMsgUniqueVariableName, staticryptSaltUniqueVariableName } = staticryptConfig;
        const { replaceHtmlCallback } = templateConfig;

        const result = await decode(
            staticryptEncryptedMsgUniqueVariableName,
            hashedPassword,
            staticryptSaltUniqueVariableName
        );
        if (!result.success) {
            return false;
        }
        const plainHTML = result.decoded;

        // if the user configured a callback call it, otherwise just replace the whole HTML
        if (typeof replaceHtmlCallback === "function") {
            replaceHtmlCallback(plainHTML);
        } else {
            document.write(plainHTML);
            document.close();
        }

        return true;
    }

    /**
     * Attempt to decrypt the page and replace the whole HTML.
     *
     * @param {string} password
     * @param {boolean} isRememberChecked
     *
     * @returns {Promise<{isSuccessful: boolean, hashedPassword?: string}>} - we return an object, so that if we want to
     *   expose more information in the future we can do it without breaking the password_template
     */
    async function handleDecryptionOfPage(password, isRememberChecked) {
        const { staticryptSaltUniqueVariableName } = staticryptConfig;

        // decrypt and replace the whole page
        const hashedPassword = await cryptoEngine.hashPassword(password, staticryptSaltUniqueVariableName);
        return handleDecryptionOfPageFromHash(hashedPassword, isRememberChecked);
    }
    exports.handleDecryptionOfPage = handleDecryptionOfPage;

    async function handleDecryptionOfPageFromHash(hashedPassword, isRememberChecked) {
        const { isRememberEnabled, rememberDurationInDays } = staticryptConfig;
        const { rememberExpirationKey, rememberPassphraseKey } = templateConfig;

        const isDecryptionSuccessful = await decryptAndReplaceHtml(hashedPassword);

        if (!isDecryptionSuccessful) {
            return {
                isSuccessful: false,
                hashedPassword,
            };
        }

        // remember the hashedPassword and set its expiration if necessary
        if (isRememberEnabled && isRememberChecked) {
            window.localStorage.setItem(rememberPassphraseKey, hashedPassword);

            // set the expiration if the duration isn't 0 (meaning no expiration)
            if (rememberDurationInDays > 0) {
                window.localStorage.setItem(
                    rememberExpirationKey,
                    (new Date().getTime() + rememberDurationInDays * 24 * 60 * 60 * 1000).toString()
                );
            }
        }

        return {
            isSuccessful: true,
            hashedPassword,
        };
    }
    exports.handleDecryptionOfPageFromHash = handleDecryptionOfPageFromHash;

    /**
     * Clear localstorage from staticrypt related values
     */
    function clearLocalStorage() {
        const { clearLocalStorageCallback, rememberExpirationKey, rememberPassphraseKey } = templateConfig;

        if (typeof clearLocalStorageCallback === "function") {
            clearLocalStorageCallback();
        } else {
            localStorage.removeItem(rememberPassphraseKey);
            localStorage.removeItem(rememberExpirationKey);
        }
    }

    async function handleDecryptOnLoad() {
        let isSuccessful = await decryptOnLoadFromUrl();

        if (!isSuccessful) {
            isSuccessful = await decryptOnLoadFromRememberMe();
        }

        return { isSuccessful };
    }
    exports.handleDecryptOnLoad = handleDecryptOnLoad;

    /**
     * Clear storage if we are logging out
     *
     * @returns {boolean} - whether we logged out
     */
    function logoutIfNeeded() {
        const logoutKey = "staticrypt_logout";

        // handle logout through query param
        const queryParams = new URLSearchParams(window.location.search);
        if (queryParams.has(logoutKey)) {
            clearLocalStorage();
            return true;
        }

        // handle logout through URL fragment
        const hash = window.location.hash.substring(1);
        if (hash.includes(logoutKey)) {
            clearLocalStorage();
            return true;
        }

        return false;
    }

    /**
     * To be called on load: check if we want to try to decrypt and replace the HTML with the decrypted content, and
     * try to do it if needed.
     *
     * @returns {Promise<boolean>} true if we derypted and replaced the whole page, false otherwise
     */
    async function decryptOnLoadFromRememberMe() {
        const { rememberDurationInDays } = staticryptConfig;
        const { rememberExpirationKey, rememberPassphraseKey } = templateConfig;

        // if we are login out, terminate
        if (logoutIfNeeded()) {
            return false;
        }

        // if there is expiration configured, check if we're not beyond the expiration
        if (rememberDurationInDays && rememberDurationInDays > 0) {
            const expiration = localStorage.getItem(rememberExpirationKey),
                isExpired = expiration && new Date().getTime() > parseInt(expiration);

            if (isExpired) {
                clearLocalStorage();
                return false;
            }
        }

        const hashedPassword = localStorage.getItem(rememberPassphraseKey);

        if (hashedPassword) {
            // try to decrypt
            const isDecryptionSuccessful = await decryptAndReplaceHtml(hashedPassword);

            // if the decryption is unsuccessful the password might be wrong - silently clear the saved data and let
            // the user fill the password form again
            if (!isDecryptionSuccessful) {
                clearLocalStorage();
                return false;
            }

            return true;
        }

        return false;
    }

    async function decryptOnLoadFromUrl() {
        const passwordKey = "staticrypt_pwd";
        const rememberMeKey = "remember_me";

        // try to get the password from the query param (for backward compatibility - we now want to avoid this method,
        // since it sends the hashed password to the server which isn't needed)
        const queryParams = new URLSearchParams(window.location.search);
        const hashedPasswordQuery = queryParams.get(passwordKey);
        const rememberMeQuery = queryParams.get(rememberMeKey);

        const urlFragment = window.location.hash.substring(1);
        // get the password from the url fragment
        const hashedPasswordRegexMatch = urlFragment.match(new RegExp(passwordKey + "=([^&]*)"));
        const hashedPasswordFragment = hashedPasswordRegexMatch ? hashedPasswordRegexMatch[1] : null;
        const rememberMeFragment = urlFragment.includes(rememberMeKey);

        const hashedPassword = hashedPasswordFragment || hashedPasswordQuery;
        const rememberMe = rememberMeFragment || rememberMeQuery;

        if (hashedPassword) {
            return handleDecryptionOfPageFromHash(hashedPassword, rememberMe);
        }

        return false;
    }

    return exports;
}
exports.init = init;

  return exports;
})());
        ;
            const templateError = "template_error",
                templateToggleAltShow = "template_toggle_show",
                templateToggleAltHide = "template_toggle_hide",
                isRememberEnabled = true,
                staticryptConfig = {"staticryptEncryptedMsgUniqueVariableName":"af8ecd35534d3936ad9f39e4506ece2b50485666fa29a45a73805b215128f68b4a6bdc51059faf7a82eb546c726e029e91026145af2f30ca82cc715af17a0640d32bf2f160ac4e6a5f253fcf75b2e00060c37180d48759449affb55710ce06815a362e0719a11adbf7bcabd257e521d1842218f1911816b198f164d59af2628221ab3b2c67efb6646f78262cfc05aadc1b992e8dd6d66628b8521e3bf2922d6e8e7f9b53d49b176fec676358f18a35902e4ba8f381acf3c5581d3e00d286ee8e2fa1586d3eb942fa02e0af8df6873d96e44756d19357921ecc13456f3d5b65ee2cc56f973ad8a69ddc14fbb7921945b15fef8d2551d7bafd2f0dbacf7cc15ee13804ed1de5f930412b43e7e3e2b42303114558ff847518e59e77f4668369a77e44223d9682d819562acdd2459b99e96ff1307e12d2d98ae4c361e7c2f38d8522238099f96af586f0f7dd3228c6291bbd58623ec03dff5cf02b234ca797f108699b8bb755efac14eb907a3d5bf20e4c3f17e804cd7245a60164fe2f2530a96bdeab4b0fc47966a96f35f3237bf00390be9dbce22f1a28ef1f8f43f7817e38f5155724f66251f60c7b9a909f65c23371c9823f42901e6234008c931f9c0be0eb7fef6db832d98c38903cfefe731da0699c4d419f8fd020b672d5358cc95869a4e16fb804e5263358b7cad1eb9bc752f3103bb905693a733d4e06db1d11f979a2450de5c0f850750497d76de21905bf8f6d9a995383fced2db567d1ce5164365b9d38c50212ee4808bc4451fd6098d3d2bd0674e67a65ef5b1433142b744a9dbf23352e4cc85ea34ff491323b8a4abc80d176555666ac3949ed3abfae01267346bc93640c3cc030071346f348251378c9834e0b6901b1f78e320513d0284a0ad5449b76d00210cada513111ba1cc3d16c38021c93a195ca8fca0c046e1bf32124bd32d9521cef2d73d4c315754cefb56d8d91e501d37e35132127ff6f5b6de88dee8761b67f100993bac7af0bc28edd0eb16b3e81470436673205c52fb5fde06116d8c88f7ec97849b3bbaa9caca64f0a8703563ce362fb8fe87af697cd55ec9b6e48f5f323b217edb360da36171a480e9148d4b454f9f2b95ee74c0b59eea0783627983931fd6bdf22762b9d99c8017ea3ce1a0717f28ad01dd54013055b821c0616a438f3aacf3921133a262e483a6ce2472853ccaecc6a732b3ae1488667e343da36eba0c8af265568ea3e4e0ff1bf51e5fedacc20fbe67f7a53f119204fb5d8e72b4a324caf46e4b6fab15b22ef196bd3fad10268bc13a07fd971c9e9db82ae47b755fdd26b8d4803a25731cc993a4f3f326bb181d4ad82e1c7e2deaf06591840ebea3d2c924b428deda2ffede7615115beeb4ab41eef7e6e18dc0318ba9815e383c8e98ce4dd25278baa856452b51f8eebe180fd5645663a5452b667470d7cda42858c89967356ecaec4365eb44dd50c7fbb0df533fd79ea5269ae643e2da0aced0c9fe9a9c59a9be5fd78d76bc94c5d06c63262b0de0497271388749693945bb9df3c74e8bd3c1bf84164120ffb157a746188c156f6e1762c9faae63a0168d0e5e2ee6ff289bcc0c0280cb8e836e1fbf7d0463c1dd9c0dc912be4b64a30e98745a579a76681e8b50397740716f2dc91d933652529769dc33aeca4f38676d2e06c689d5f424b1759ae34af06547c088b059ead19cf4ce4e036c190a5194b310b3359f27d952710bb368c7c391d6114b5a026a99cf824f0f048e374f42f02eb94325c932212cdda182a45ba9fb6c8d03e3f2cf024f310cdb12bb7d7d745e5cac20125d5d4ce5765b996df8f2327beefa86a66074c38d3ad8f42edf4efe74b294836ceb4977dfdeeff7d97df31372ba56f084b77e7bba8bcc25292265eb9022c832509350e27ec20eb954d785068187c62a9d7371de4b84182b5366b47dff193c75c95d13db15cb7cdf9e42e6148b67fffcb2adc6f86eb79ba26d923454816578f44b778e05932d3171d0782622963ba447d3e51e7c32c39a9754a223aabe62405cd8e269022b5cff74ec296c5482b0ef76dacb080fecee06e69c5d329e8504f4f0f4e7754942d0d34889116a9652cb4007268f0c0a4afc328a290843aa106cfc8413ec1ac89fc3d830299c254042bdbc2b399b29c4044555d9c53dd67de9acf230de00fddf868be770cca122c25b64d444906f52b812bc5fa09edb743b2c2537b0b5082d64e300387ea9159a35c8fc3599d000f1b35df464eb5fe6441d7be00973a580ddb8e0e700fa154ec0680f829bd9292e4464a56a1b584392c1629faab0ec92958ad83d984b1c316e03e8ce055da1a74bdd33ef1c18a4ad6f5268c7d9a3755d0aa19005afa26473c14b382e84244c96b7e810c11894ff51cd4869bdea2aa5d2af97fb1f57f24bcbe5b21c6cf3018a4cb440b18c556bf63dc4f677bfecedea9f2b0a08f216f54ae47e14ddf3ad0ee6029e85eb58170dea2b2f2020bbaa72734398eaefd394e2cee4f8da70cbebeb029b4f408aef58b71146bcc310bbfe796219987ac141ac3ef724c43e55e475b5796429869958ad9f2c625fd6fb041c1ee83e9bb26bcde7dbee3e360e914997357474c07e301623b393ea8c7ac04d052f4c4ad22fb1ee7cb43aed20370bdfbc5d4b1b821c9c989de6bf26fa892690eb6b0f820baa3e970cc7881fa576fe53155c1f00a163aab2ba22cf062604bc2f6252e14da442d69a4d5f3f3c50eaf814f1e7ec412398cc17f8070ce071b28a322987226ae39a5040f898430ec362e45435531e68930697566aafe49945857a3676122acbc446b343740da0760c86388ed356acf2c0d525ba36d8b4ec77c15d2e704e98a8e3e750304f8eec3076972a1bdeb2af02981972aff99bc5829e3ac5cebce2f4fc7794e55543f05b71912db31d392b855f4fb2a9ca025706724d782cb34f3471d73c3121b869306381bed30d1d2bc31c8c5b966571b5cb92356b1f3eaf1c52e983ef194d5eeb30101d141792f795a1b3b57faab9f64d2c05a43ac110cb99a2ae75ad26d998608b71d1afad68710df5d8f5c1f697fa7cff6f651a9646b510ff4fef60de0fd476f3bf79ea156e26b8621131cd2ccd8d402d69008613dae30c00f25011205739003a0debb0ea849fe5259bac6a6fbf82d3d1eab53978309d8224a4eca09050b2ce90d493a3b8fd3ce9458c9964fd3eac99a3780c94edc02a272670dda0ff58e70d269e23677e778896d9d90902e44d6be3297c644819d4941300f2a5b424118c11056047b5ba5e1b33b34534e48b8cbdc136dcca1a6467a7781743712e915bb6d9613b3afcd8438754e140c06aa753144464bd366f8f102653f7612cbbbe8d8acf92b1a9480b72acc307f942013c682e57664033f439157bdc9d606c80fd71645274b65117ac5122dbcc7582762417234ea4c178583dc51ddda0c016a50b350e70c2fb5371c3e07a633bd2ac91d9b5ee6fcde157c31493ed05acc854671fb0b7d77e7dedfc2751bd30a19b0189505c0791ba25b110bf72684587d95a42fc69a77f7596de4728cd41a34272fb223a918c17045604f4a282067a96c0b7a365ea20a643d39e16a1963ab11a86b69ebc45d92f3927d6702def091db3ed6b262e1bf3e8f503d737aa8b5bdc832097e8a5461a4bdc3a6784ed2cb184f1e6766f94afacf7a2fa81a27e0369309e25e21cd563fceb8e434baef1ef18f68fa334c2b36e84624f8cac72d1d6a3d35a8fafd5e941b222e25a63dbf82a714dd65b21cb4f7d107807e332df7c4dea9d5f917b77df1a1248af2cbdcc642e7547821f3fb878babbf5a00da0862887baa40037171f2d1090cbd599f96b00ec27f08dc2c0e56f4dc969ec267bc137c5c9be11cd5305c1998627480bf9b7234eeed1b0c44aefd9f73fbb1970f92efc3754dc5d6e13e034251c7ac16d429eea2a213e63a83a33d5edf12c7b1113a2e56fe3bfcbd2e65309d0219e70c6b2eb909c9fbd12083b89634395087b41a8e227e173f4149db77cc112f37ca2990a6607ed6f295f119a2024c454853369e95375beb0918a6a1dd15751c5c0a09054406003627da3ffb4bed0a36302a5ffa721339bc1af6db7789ee5ba24f03b7240b1980315486687c42d5ee2ca358781554e2ebfe9e0e5572a57f0656fa271d9e452677d2b468973121641f2b5805dc0ef3132a162f905747854d6b89c457710b9024f6fef4160225329b32408c203901a7dd0ab5c29cc137cb7c75ab3384d82e608c36ed2a182a4b94c673e31754f7f67c2c73ee9c449c809230a6ceec3d9364c647135fbfbd920d1ea03d675f5ff8dbca52e7da5da93bb8f9807b70fc8c4987abfb3ee9836ef6319163e3b190963d71fe9d45eb410759ec508f904f87afb49c20208ba0d85f4b71d531fc1a028b5d90fb81fd3b15e7ff5f28772a36566df29361d49438841a22164502ab3e71ad8af01f2b211e7db0d9bd4b060adfbde4e61691a520038880946dd6b03e96d6a5a176c156e6a234db428f509a9bc4ca22307a0d8a6bda12e708aec6bbb02a6563db3a2bd2086c16bc7a61116284585ed9e2684bed5b615ae8f819e7e71ae738d2b4b339f0895af23677c1b1931e67e110ab7a678a0d5e0c6eef3d07b5f6b1ffc5664b1bd938cd2ab2006f69022cac9b8d13e8572e6d1a6a9bf8010126efe1cdbb444ff23f49db9601ed4cb5fd72a822c8bae6177471061a97fde80d7c198abf46a402e5efbd1c9d2e7a92743d7987019aca5bb1307298a3234278eb9768d42ce82ecea5cd327ee6d26bd04ac5807acbfa1877e452463f3953882ec2e09b64d86be55ff226194d4105074dc273c2de2d36786905213f129591ab837ba25174e8991187cf2aee4c1c9931a8496a58f36194e2b6476b38d5b4f181f5d64c0192166a774b66902a8a5911c1c7754907c5cbe01731e38b6bd4b34511904357a7b4a5c6d692f4332e3b548a95d29cab730081285b6eb8feff4d798b05c4f82c3abf768d1a3dcc881a8e668f487e5e0dddbd21b20a52e290e01ac9b1f1f0f65648de494d2cf7cffd51eabfb29ddeb018ae8e8a6b301e3e3ce5f5792383db4009f65f60afd5315f1a2aa8803a36ab22b2b359b0db2039f71f7e7c471ca4c23b9be47a51db5e259e87575f4c0dcc59ab659fcbd7ddb0b4b587980511e1018f914780d0a6ce6848f19723b8f06d4ad1431df0a71dcf037eab085a3d17407224e0b91dc2395cbc2abe3eaa97114b78aa85ce9c6cb143f4805b411bb104e9cae2a03ac83a7301166a9e5e60f710b63b008668d1e67c35edeccb666031892e0b0353a11fa14e636e7f58b2b6a9ba257d15757e3eb17be68374c3b127b7ff43d6df745ed9a5314ddcc912f83a49f81e3f521b4282479ac49f112087ffa14ae918337d977ff39c1a815bb005886bc8753b158c1a82fe5e6796248a8c451c4631dbd73920cdbdac634cc069538185c0157bc339e7b275977bf907e6c826d9993fc29066992158796cd16f100d0c5b083bee96d1c89eae1fcfd10c55d23a19c2999908165527df5afbe8556464aec15c716828e6aa80a0cbcf99fc8183afec5e6dabdaf909e2719245962c0193b7b08c8d82c27cb87bc89d1f63f04918c211bec64037ba3ed0feab3e7c0d3a4a25273b5bed100b2340d547124b1ec4599166d137d4e6170297d810cec340832ec46d47b4dd295e00b9848a435ccf2d8ad55a1d646ed6c8bd4019e32b760d15f31878324f1c584c2f576107833f40c26e3b8e41cdbd427452deb4f93e7026b5913dcd5160074bbad493a2998dbef37350e590882f9020650075dd31faf2ee2e57e30ae978b8af7f904e639441e6fe8fd46533cb80aeb88eccabbe9da5a5862dfdf0ec0fd0538b49c949fc3ae5bd8bc848a30194732ee1da15e78c05052fb4307e2703514e160e659fce2522618da4c1c90fda64483e91071475a2831309ee05d7187d753461787004a33a10bc2c00935762b0e30b6d9a2f87bdfc00fb34d39af2cc7d8b66a166a23b04c67e884fab29064d45d95bf570a744618b7c6c88089b293ab6eee1cebd89cca5b12d854cf6ddb2fb64efb1eb78322e765489d2cbfb96ca3e11c3c9783a5404afa3529cb84832363ccf0f3c0eb3596d36f454eaed9768e05a6debd31feba8652be868adf24bf36240cb11af96b084a4a7ff756df9fcc8598370a9ae8a6c69ba958da9c84e89fc72b55e5459b7154400a167459a169507c8187df3ee479a5c9c7c0401e737d9b775be8955df8cc3403b97fa7db9642e54d012bccbe0f5f87aa4d9414d9471bea5b8d61baad2aca61350e46591c6ed552d3ff268add42e0f94686a5c37f6ed05a13fe864c2b43ffa48b309a27421e78c921130715aa88e788491d6ad856af4b901686b09bed940d9d61c21b5f811c3a2aa12a4aab02e56babf4cd67131959b1cf20974d7a7971580ac44a220a5e6260e2a283961f3fbfe1125e5baed453d803ca07ff241f8dee82ac191b88d0f6b7af9bed8b47a7cb713cd321243ef2013e7d24caf652216cbafdae71bb1c97c54163c2d2dd4275899d65710974c27004a4e3eb20bd6eb7d0892786d3395358741546febb6201489853d0e10cd80ebfde40a315c3f4d8a6edc2b784227d2b1966c3cfb0781f954b8ece4c07edce3839ca4a41531c2bd75f2fac58f23a19bcc8c7e2986e7e91aff009c20925c27b694102d5d3076392b52adaefc137dc2613d9adbff2b9c054a28379fc205e2d7daba2fc318a56ce98c8a46ad5ec68c06dfa67f29af3f4abfd0948fe6abc4897b903aae6584a65426c4e2203a808c6827a8db217025dde22b6f0059357f16c9be98c070d6e5916d333026238235209d7d919b56217c4ef691d58202dd55c7038006d12d51a43e73ae1953bca40b60d2bc89ea56d5f42d5f7e8bbf7b2a5ae079f2ff523442ad0aabd8cb98813a04062bd5db3f1060250d3a8377698e3ab4fea4d1ff7e8cdfde97ba35f9befc9026466ce72740b60e3f46cc6288e9d3c43e75f291da065fb66da7cc35d2b0a87127a4970d168ab10e930a07252c9ca3a43113ce0410dfd6af82c7640c2b1a808608e2239f90a649bd09da9a2fd363fa1222a222b486272f9fae41a20f038709aa39a826c94f43947d0d1c622fd8423cf40c97099d88cfa45b982758857b855d48ea0b1a77c82c1bef91b20a68477a8bb666da2d97232222145183463bf153bc493d0d8643e1df952e72c76e77d2b58f33e4aede1fe4d6f99e3e9d3c226b4f5456500becd278328849bc3743f119d7484fd9a29974d1e86f99cd28e5fb897eed3deaf8b5ba11653342315054e318a56b3dedd67143ad795e5524bfb94e20094d57f2f2a90d767d57268ec98e3263a31ab41ddd9be1c9f1eb03fb256663775238c1f318759c08335c208545b6c9f9cec91a55bf91cd000f463ee17feca7d467387353d4bb1acee450ba505270ff93fe3e06165c5d50babd9e211acf452a02d711a3761ae2be6d53abfe0e24ffbe978ac4fab9d97cfadd3c93162c522b759e0c3a9a177bbc78fd5b685b3c80903f6c024e129a57fe9fe500c4e919645d708cd24e3b76b5c3aa6ec12b847ed8c884d0fdbdb366a67d78af029366031563f90d162f80f98a8f1ab2ccc2dc66d10f054ee63ce5dca9345d914928be6ffee364206c7225197c4ee8b1060950d45a7cd0d11fabe6d0899df2e410f27db8d04b915a2be7f808455f3e534f887bdbe2c700d955b11c430b81b6150b2cf2dc21d4378f8ddea218f390274fc45b1c7de66a791ef4189eeaa12aa039c7b6e65120f946af8d1b7a81dace302a05d32deed62d3066d3e59f85d98e1551301538fcf0ccd9625139a3b82ea339511ee70f4d0766e3d2becb80514e0490b0b499e7b2efc64da1241a55b79f5f79b08f6971081650f0237c0cd8ac9d3e30f3dc751a8b92577be5c8883993a8096adbe5a729ea398c9680e3411dffa5e2e80de1b9d0bbe413e3680c14595873277c79c5fa599ce04bf56f677d74022a624500ad544adb005015471b2fc0f139a059b13cab5fc9f63303899ce6ac6f43d4039978a4e604e73b97c916df3fea38e0c9e8ffa1b449fa57553d657eb03dd7ee2e571d11cadc338e98bacdc3ffe4a59a6e5c50a427ed2f0b6303a87df6c6ca78f471b249d9ed85a06e7d52673520b4c62f7c3ff3d3e33b172a082f8fd8848886aed9f5a6e05952fafff8a3e757c579b8007a793432a5a549815846e88fd094daebc2df69f99d2fa054e058b24b2ab005039d35bfa6a1e57239d687d7f738d3ec97f9ec704c52a46fad2ce4b7d11c9b8c5e0305665e2c66e2f942498c3a66263e17ba0953e8d5e4f4403a9e2c48cf715620a6b4dad7069fd6dc5f8f6233e6a879f5a17fae828bf19b59810ccb347d492da8888282a3631a1289e0f9c2c2dca6e67232e73be4baf62d8a0a854340c8969cbfe05d26d9b7a9a17d92d8cb27d6928d495a0414bb58d75424487bdafbfd033bebefaa7001404380f7b8b9393ae159c96d74472df5237a8fd319427b6d75a2253967f4d44105a632a94e3e96bf810cd4b4cb8cba89bc859949caf2fefb76ea16ce67202ea19ee9d9e934583119c9d3aeea54acd508857a5c5bd37c35f39e12fa164516af3477f404618da701ec92707fe3ea0d5782363b99825d22e67c8c7bff73f6287daed45551751f4576fea94e5069a859a790e776bc948d40fb39e3225ec6e9b8861fb85d33eb986e74c59f013365acfed0e3f2c98836a748b54fba98e6f9da951d4c0341b8eba766d5193fe3d9ea94b025a76e0925dc695c5dc3cedf08c8aee68a8de85f9cb62ff94868375e6bb2186b26d0f989e8b0cbf037b05b38085aa2f85a33e49ad9787d4e116cf5fc7736385850d12a6f29ae304843c8d709db009ec6e42d19b5c775c125ccdd89d72cedbf7087de891235ec574b034f6580e1d1169f23b14052c5a42430e3a352cce1547bc7ed16aec62fed207a47a6ffe278744f87328f62e5e50b75d34ffce3e2cb319acfcdd0259d041afc603e819a512d769d68559db10107772c316a5ceb5d927e8c6ca8068bcda1defe9c8120b15448e95b50eebda58ffcb8350c41c6a7cc1454f3ac7f6c26fbea394fb4207399f7ecad222645c81cae8dda5adccde6aca2a61d9b7cd96fbd0b3f99140d40e84cfe8ebf9d3ecbe856b399327ce87396182a2ab60629ed0540a034e7a61521ae7ec1616ff2be6bfafa40478d8a53442a96d23d7ac279eefcabffd4fa2e990f717bb332e4451e99533cfee1f546a2aee780509ab9613d9e106939d3f02906421185e1f2ae1be9121b6cb3e62214fabfe0cacbca4a606441e6e0bd44990b3803860f130cba11c06d3ac8827d072d05191c82570d77ba8d650446670d1baca1cf633391e19f4bb35295f4171bc6ceaf95b303cdc9a25527c1476ad8837fc9e875a011d3b56705e71a5b9cf24dbfd7f0d6efead813924e4a0bfee1966e39ba7a823101ee308618019df40250d29e96ae0c504ef7f172e42eda9dbebee0d60fc5f9ae90e37e30c3402c75756f2124b0d5af6a7600c54a185a4e3eb190387e37e4d899c93bb52fb67b7ad1254cc35bc431ebf90dcc40b588449f597b0494a60a82d37835330cd870ad393339ef9d33cae5e61cd34894b6dc1e93a0e9006df32983c665d8eb991c1ca4920a6583be82dbe1c68e9238ce050a2d975c7c7c2e85882c1fd845bafdc5c29e1ce407b686dbeb730387c93f39cb603bcf8d70ec32ae024a2aadea47b8c53f34b77ec65f2dfc290dbbe82ad6ea9c1f19a9aa82666a42f13c7a515a1fdc16efc0e82a68f309ab4b174b08bac17019949c98c4217cbdf237ee20b98d35342e40de65d4d45037ed4e64dd2de2afe5cae9096ed1785915a268c77422fa175542731172a1e83183101b59a5cb4719b8f6f2fcbbad722616f5085806fefd9277d9ef6f0738ec316c6af039c14168c7934eb237aeb8fd66b8136870cb4b0d0bf4d354eba0b806b43f8623fbf9722fe35cf9b1d317d1203660d35d555e1bea2c5470ea17504ea484787d7b138588c53e55c35808145ff345fceff8fdb193ed18c652ba4e22c1ea859678562acb94d91ea0b7f358f3f09a45f75340a56a70a4221e91a406be7709c24dd4239bfca25f2d290bda9fbe9a50042e7367bd3366069d1b087bf9d734d03ba7a07fd54b4103a6da3927ee468471339e225d754a9d52f5b63c2dc4f994de5aa5c4b7db02708b6aead57178491305e2c68a3f993ffe0bf5ec2ffa5030369389ecfd263f160df923bd4ee35769d68618068e925a311341ecf69d8181da7ff6fd66c04159879a838032097b98d31d7dc4f8c9d77a361d1318d975a672890ffb0517ef91880388e53b9bc77d108b885de0c687cfb61929f315856cfe7aaffa66515d2f63cf23a1341acc897173518667f054638be9b504ed4957cc92a6f4b5fb9b3a084b7f892649749e6161882ad5dc363712860ba5c9542db8e41d870519ccd0cc7e74b0d6425a08082d6b4627c5c5c23e10aac32e6c204e1aaf075b8553f9d60d9dcb71010bf4b408d11e5af1f88edfc202680a69ca5975af60d8dad47ac9b36d39cb7919db8d42c8395986f06416ba7227f8eda586502726f3bd98fc1e7e326b7722e14b7049abafdb9d1df7bcee8e91683df0984f6015908c886b9440e5a0379c444d959aad274fce15c5ffcb971626a2c1dd581ca7265d90534ba259dcf38cbb4536cb7f559a96a505dab17a759a1bd42766f370a6b69ff55b417c2418f658eb4da50599caea4701e972c9ecc72b5a9676151ca946ed0fa6fd1387b408619e7755b5704ac9a6de229541da40ab8e9797052183fdba63f728719b5a47bea9b07a88b57306abadb48f0d2969102f6e61f0e8fb83bdcb530148bda9ef0ace586976ee5223452cc691e3d60ca35875f0c65c464d609ee777083469def5e00861ad2fc371c2b32bf5b6fbedf5f52a9976904f1ecd7e73dcaa5f5ae3b358c63ceaceefe2dc02f9c69732117edee5a1ff0e28d31d74008897321b353b2a68ea44c08c4fdc5dee3cdd9b577a2299b4c39043231281ed00aa0fd0b7afec93272e0d88e724c6544c74e3c916de8a883f8208d7e3c00080d093","isRememberEnabled":true,"rememberDurationInDays":0,"staticryptSaltUniqueVariableName":"5a840fed47e5a8e4831e77adfda32208"};

            // you can edit these values to customize some of the behavior of StatiCrypt
            const templateConfig = {
                rememberExpirationKey: "staticrypt_expiration",
                rememberPassphraseKey: "staticrypt_passphrase",
                replaceHtmlCallback: null,
                clearLocalStorageCallback: null,
            };

            // init the staticrypt engine
            const staticrypt = staticryptInitiator.init(staticryptConfig, templateConfig);

            // try to automatically decrypt on load if there is a saved password
            window.onload = async function () {
                const { isSuccessful } = await staticrypt.handleDecryptOnLoad();

                // if we didn't decrypt anything on load, show the password prompt. Otherwise the content has already been
                // replaced, no need to do anything
                if (!isSuccessful) {
                    // hide loading screen
                    document.getElementById("staticrypt_loading").classList.add("hidden");
                    document.getElementById("staticrypt_content").classList.remove("hidden");
                    document.getElementById("staticrypt-password").focus();

                    // show the remember me checkbox
                    if (isRememberEnabled) {
                        document.getElementById("staticrypt-remember-label").classList.remove("hidden");
                    }
                }
            };

            // toggle password visibility
            const toggleIcon = document.querySelector(".staticrypt-toggle-password-visibility");
            // these two icons are coming from FontAwesome
            const imgSrcEyeClosed =
                "data:image/svg+xml;base64,PHN2ZyB4bWxucz0iaHR0cDovL3d3dy53My5vcmcvMjAwMC9zdmciIHZpZXdCb3g9IjAgMCA2NDAgNTEyIj48IS0tIUZvbnQgQXdlc29tZSBGcmVlIDYuNS4yIGJ5IEBmb250YXdlc29tZSAtIGh0dHBzOi8vZm9udGF3ZXNvbWUuY29tIExpY2Vuc2UgLSBodHRwczovL2ZvbnRhd2Vzb21lLmNvbS9saWNlbnNlL2ZyZWUgQ29weXJpZ2h0IDIwMjQgRm9udGljb25zLCBJbmMuLS0+PHBhdGggZD0iTTM4LjggNS4xQzI4LjQtMy4xIDEzLjMtMS4yIDUuMSA5LjJTLTEuMiAzNC43IDkuMiA0Mi45bDU5MiA0NjRjMTAuNCA4LjIgMjUuNSA2LjMgMzMuNy00LjFzNi4zLTI1LjUtNC4xLTMzLjdMNTI1LjYgMzg2LjdjMzkuNi00MC42IDY2LjQtODYuMSA3OS45LTExOC40YzMuMy03LjkgMy4zLTE2LjcgMC0yNC42Yy0xNC45LTM1LjctNDYuMi04Ny43LTkzLTEzMS4xQzQ2NS41IDY4LjggNDAwLjggMzIgMzIwIDMyYy02OC4yIDAtMTI1IDI2LjMtMTY5LjMgNjAuOEwzOC44IDUuMXpNMjIzLjEgMTQ5LjVDMjQ4LjYgMTI2LjIgMjgyLjcgMTEyIDMyMCAxMTJjNzkuNSAwIDE0NCA2NC41IDE0NCAxNDRjMCAyNC45LTYuMyA0OC4zLTE3LjQgNjguN0w0MDggMjk0LjVjOC40LTE5LjMgMTAuNi00MS40IDQuOC02My4zYy0xMS4xLTQxLjUtNDcuOC02OS40LTg4LjYtNzEuMWMtNS44LS4yLTkuMiA2LjEtNy40IDExLjdjMi4xIDYuNCAzLjMgMTMuMiAzLjMgMjAuM2MwIDEwLjItMi40IDE5LjgtNi42IDI4LjNsLTkwLjMtNzAuOHpNMzczIDM4OS45Yy0xNi40IDYuNS0zNC4zIDEwLjEtNTMgMTAuMWMtNzkuNSAwLTE0NC02NC41LTE0NC0xNDRjMC02LjkgLjUtMTMuNiAxLjQtMjAuMkw4My4xIDE2MS41QzYwLjMgMTkxLjIgNDQgMjIwLjggMzQuNSAyNDMuN2MtMy4zIDcuOS0zLjMgMTYuNyAwIDI0LjZjMTQuOSAzNS43IDQ2LjIgODcuNyA5MyAxMzEuMUMxNzQuNSA0NDMuMiAyMzkuMiA0ODAgMzIwIDQ4MGM0Ny44IDAgODkuOS0xMi45IDEyNi4yLTMyLjVMMzczIDM4OS45eiIvPjwvc3ZnPg==";
            const imgSrcEyeOpened =
                "data:image/svg+xml;base64,PHN2ZyB4bWxucz0iaHR0cDovL3d3dy53My5vcmcvMjAwMC9zdmciIHZpZXdCb3g9IjAgMCA1NzYgNTEyIj48IS0tIUZvbnQgQXdlc29tZSBGcmVlIDYuNS4yIGJ5IEBmb250YXdlc29tZSAtIGh0dHBzOi8vZm9udGF3ZXNvbWUuY29tIExpY2Vuc2UgLSBodHRwczovL2ZvbnRhd2Vzb21lLmNvbS9saWNlbnNlL2ZyZWUgQ29weXJpZ2h0IDIwMjQgRm9udGljb25zLCBJbmMuLS0+PHBhdGggZD0iTTI4OCAzMmMtODAuOCAwLTE0NS41IDM2LjgtMTkyLjYgODAuNkM0OC42IDE1NiAxNy4zIDIwOCAyLjUgMjQzLjdjLTMuMyA3LjktMy4zIDE2LjcgMCAyNC42QzE3LjMgMzA0IDQ4LjYgMzU2IDk1LjQgMzk5LjRDMTQyLjUgNDQzLjIgMjA3LjIgNDgwIDI4OCA0ODBzMTQ1LjUtMzYuOCAxOTIuNi04MC42YzQ2LjgtNDMuNSA3OC4xLTk1LjQgOTMtMTMxLjFjMy4zLTcuOSAzLjMtMTYuNyAwLTI0LjZjLTE0LjktMzUuNy00Ni4yLTg3LjctOTMtMTMxLjFDNDMzLjUgNjguOCAzNjguOCAzMiAyODggMzJ6TTE0NCAyNTZhMTQ0IDE0NCAwIDEgMSAyODggMCAxNDQgMTQ0IDAgMSAxIC0yODggMHptMTQ0LTY0YzAgMzUuMy0yOC43IDY0LTY0IDY0Yy03LjEgMC0xMy45LTEuMi0yMC4zLTMuM2MtNS41LTEuOC0xMS45IDEuNi0xMS43IDcuNGMuMyA2LjkgMS4zIDEzLjggMy4yIDIwLjdjMTMuNyA1MS4yIDY2LjQgODEuNiAxMTcuNiA2Ny45czgxLjYtNjYuNCA2Ny45LTExNy42Yy0xMS4xLTQxLjUtNDcuOC02OS40LTg4LjYtNzEuMWMtNS44LS4yLTkuMiA2LjEtNy40IDExLjdjMi4xIDYuNCAzLjMgMTMuMiAzLjMgMjAuM3oiLz48L3N2Zz4=";
            toggleIcon.addEventListener("click", function () {
                const passwordInput = document.getElementById("staticrypt-password");
                if (passwordInput.type === "password") {
                    passwordInput.type = "text";
                    toggleIcon.src = imgSrcEyeOpened;
                    toggleIcon.alt = templateToggleAltHide;
                    toggleIcon.title = templateToggleAltHide;
                } else {
                    passwordInput.type = "password";
                    toggleIcon.src = imgSrcEyeClosed;
                    toggleIcon.alt = templateToggleAltShow;
                    toggleIcon.title = templateToggleAltShow;
                }
            });

            // handle password form submission
            document.getElementById("staticrypt-form").addEventListener("submit", async function (e) {
                e.preventDefault();

                const password = document.getElementById("staticrypt-password").value,
                    isRememberChecked = document.getElementById("staticrypt-remember").checked;

                const { isSuccessful } = await staticrypt.handleDecryptionOfPage(password, isRememberChecked);

                if (!isSuccessful) {
                    alert(templateError);
                }
            });
        </script>
    </body>
</html>
