<!DOCTYPE html>
<html class="staticrypt-html">
    <head>
        <meta charset="utf-8" />
        <title>Protected Page</title>
        <meta name="viewport" content="width=device-width, initial-scale=1" />

        <!-- do not cache this page -->
        <meta http-equiv="cache-control" content="max-age=0" />
        <meta http-equiv="cache-control" content="no-cache" />
        <meta http-equiv="expires" content="0" />
        <meta http-equiv="expires" content="Tue, 01 Jan 1980 1:00:00 GMT" />
        <meta http-equiv="pragma" content="no-cache" />

        <style>
            .staticrypt-hr {
                margin-top: 20px;
                margin-bottom: 20px;
                border: 0;
                border-top: 1px solid #eee;
            }

            .staticrypt-page {
                width: 360px;
                padding: 8% 0 0;
                margin: auto;
                box-sizing: border-box;
            }

            .staticrypt-form {
                position: relative;
                z-index: 1;
                background: #ffffff;
                max-width: 360px;
                margin: 0 auto 100px;
                padding: 45px;
                text-align: center;
                box-shadow: 0 0 20px 0 rgba(0, 0, 0, 0.2), 0 5px 5px 0 rgba(0, 0, 0, 0.24);
            }

            .staticrypt-form input[type="password"] {
                outline: 0;
                background: #f2f2f2;
                width: 100%;
                border: 0;
                margin: 0 0 15px;
                padding: 15px;
                box-sizing: border-box;
                font-size: 14px;
            }

            .staticrypt-form .staticrypt-decrypt-button {
                text-transform: uppercase;
                outline: 0;
                background: #4CAF50;
                width: 100%;
                border: 0;
                padding: 15px;
                color: #ffffff;
                font-size: 14px;
                cursor: pointer;
            }

            .staticrypt-form .staticrypt-decrypt-button:hover,
            .staticrypt-form .staticrypt-decrypt-button:active,
            .staticrypt-form .staticrypt-decrypt-button:focus {
                background: #4CAF50;
                filter: brightness(92%);
            }

            .staticrypt-html {
                height: 100%;
            }

            .staticrypt-body {
                height: 100%;
                margin: 0;
            }

            .staticrypt-content {
                height: 100%;
                margin-bottom: 1em;
                background: #76B852;
                font-family: "Arial", sans-serif;
                -webkit-font-smoothing: antialiased;
                -moz-osx-font-smoothing: grayscale;
            }

            .staticrypt-instructions {
                margin-top: -1em;
                margin-bottom: 1em;
            }

            .staticrypt-title {
                font-size: 1.5em;
            }

            label.staticrypt-remember {
                display: flex;
                align-items: center;
                margin-bottom: 1em;
            }

            .staticrypt-remember input[type="checkbox"] {
                transform: scale(1.5);
                margin-right: 1em;
            }

            .hidden {
                display: none !important;
            }

            .staticrypt-spinner-container {
                height: 100%;
                display: flex;
                align-items: center;
                justify-content: center;
            }

            .staticrypt-spinner {
                display: inline-block;
                width: 2rem;
                height: 2rem;
                vertical-align: text-bottom;
                border: 0.25em solid gray;
                border-right-color: transparent;
                border-radius: 50%;
                -webkit-animation: spinner-border 0.75s linear infinite;
                animation: spinner-border 0.75s linear infinite;
                animation-duration: 0.75s;
                animation-timing-function: linear;
                animation-delay: 0s;
                animation-iteration-count: infinite;
                animation-direction: normal;
                animation-fill-mode: none;
                animation-play-state: running;
                animation-name: spinner-border;
            }

            @keyframes spinner-border {
                100% {
                    transform: rotate(360deg);
                }
            }
        </style>
    </head>

    <body class="staticrypt-body">
        <div id="staticrypt_loading" class="staticrypt-spinner-container">
            <div class="staticrypt-spinner"></div>
        </div>

        <div id="staticrypt_content" class="staticrypt-content hidden">
            <div class="staticrypt-page">
                <div class="staticrypt-form">
                    <div class="staticrypt-instructions">
                        <p class="staticrypt-title">Protected Page</p>
                        <p></p>
                    </div>

                    <hr class="staticrypt-hr" />

                    <form id="staticrypt-form" action="#" method="post">
                        <input
                            id="staticrypt-password"
                            type="password"
                            name="password"
                            placeholder="Password"
                            autofocus
                        />

                        <label id="staticrypt-remember-label" class="staticrypt-remember hidden">
                            <input id="staticrypt-remember" type="checkbox" name="remember" />
                            Remember me
                        </label>

                        <input type="submit" class="staticrypt-decrypt-button" value="DECRYPT" />
                    </form>
                </div>
            </div>
        </div>

        <script>
            // these variables will be filled when generating the file - the template format is 'variable_name'
            const staticryptInitiator = 
            ((function(){
  const exports = {};
  const cryptoEngine = ((function(){
  const exports = {};
  const { subtle } = crypto;

const IV_BITS = 16 * 8;
const HEX_BITS = 4;
const ENCRYPTION_ALGO = "AES-CBC";

/**
 * Translates between utf8 encoded hexadecimal strings
 * and Uint8Array bytes.
 */
const HexEncoder = {
    /**
     * hex string -> bytes
     * @param {string} hexString
     * @returns {Uint8Array}
     */
    parse: function (hexString) {
        if (hexString.length % 2 !== 0) throw "Invalid hexString";
        const arrayBuffer = new Uint8Array(hexString.length / 2);

        for (let i = 0; i < hexString.length; i += 2) {
            const byteValue = parseInt(hexString.substring(i, i + 2), 16);
            if (isNaN(byteValue)) {
                throw "Invalid hexString";
            }
            arrayBuffer[i / 2] = byteValue;
        }
        return arrayBuffer;
    },

    /**
     * bytes -> hex string
     * @param {Uint8Array} bytes
     * @returns {string}
     */
    stringify: function (bytes) {
        const hexBytes = [];

        for (let i = 0; i < bytes.length; ++i) {
            let byteString = bytes[i].toString(16);
            if (byteString.length < 2) {
                byteString = "0" + byteString;
            }
            hexBytes.push(byteString);
        }
        return hexBytes.join("");
    },
};

/**
 * Translates between utf8 strings and Uint8Array bytes.
 */
const UTF8Encoder = {
    parse: function (str) {
        return new TextEncoder().encode(str);
    },

    stringify: function (bytes) {
        return new TextDecoder().decode(bytes);
    },
};

/**
 * Salt and encrypt a msg with a password.
 */
async function encrypt(msg, hashedPassword) {
    // Must be 16 bytes, unpredictable, and preferably cryptographically random. However, it need not be secret.
    // https://developer.mozilla.org/en-US/docs/Web/API/SubtleCrypto/encrypt#parameters
    const iv = crypto.getRandomValues(new Uint8Array(IV_BITS / 8));

    const key = await subtle.importKey("raw", HexEncoder.parse(hashedPassword), ENCRYPTION_ALGO, false, ["encrypt"]);

    const encrypted = await subtle.encrypt(
        {
            name: ENCRYPTION_ALGO,
            iv: iv,
        },
        key,
        UTF8Encoder.parse(msg)
    );

    // iv will be 32 hex characters, we prepend it to the ciphertext for use in decryption
    return HexEncoder.stringify(iv) + HexEncoder.stringify(new Uint8Array(encrypted));
}
exports.encrypt = encrypt;

/**
 * Decrypt a salted msg using a password.
 *
 * @param {string} encryptedMsg
 * @param {string} hashedPassword
 * @returns {Promise<string>}
 */
async function decrypt(encryptedMsg, hashedPassword) {
    const ivLength = IV_BITS / HEX_BITS;
    const iv = HexEncoder.parse(encryptedMsg.substring(0, ivLength));
    const encrypted = encryptedMsg.substring(ivLength);

    const key = await subtle.importKey("raw", HexEncoder.parse(hashedPassword), ENCRYPTION_ALGO, false, ["decrypt"]);

    const outBuffer = await subtle.decrypt(
        {
            name: ENCRYPTION_ALGO,
            iv: iv,
        },
        key,
        HexEncoder.parse(encrypted)
    );

    return UTF8Encoder.stringify(new Uint8Array(outBuffer));
}
exports.decrypt = decrypt;

/**
 * Salt and hash the password so it can be stored in localStorage without opening a password reuse vulnerability.
 *
 * @param {string} password
 * @param {string} salt
 * @returns {Promise<string>}
 */
async function hashPassword(password, salt) {
    // we hash the password in multiple steps, each adding more iterations. This is because we used to allow less
    // iterations, so for backward compatibility reasons, we need to support going from that to more iterations.
    let hashedPassword = await hashLegacyRound(password, salt);

    hashedPassword = await hashSecondRound(hashedPassword, salt);

    return hashThirdRound(hashedPassword, salt);
}
exports.hashPassword = hashPassword;

/**
 * This hashes the password with 1k iterations. This is a low number, we need this function to support backwards
 * compatibility.
 *
 * @param {string} password
 * @param {string} salt
 * @returns {Promise<string>}
 */
function hashLegacyRound(password, salt) {
    return pbkdf2(password, salt, 1000, "SHA-1");
}
exports.hashLegacyRound = hashLegacyRound;

/**
 * Add a second round of iterations. This is because we used to use 1k, so for backwards compatibility with
 * remember-me/autodecrypt links, we need to support going from that to more iterations.
 *
 * @param hashedPassword
 * @param salt
 * @returns {Promise<string>}
 */
function hashSecondRound(hashedPassword, salt) {
    return pbkdf2(hashedPassword, salt, 14000, "SHA-256");
}
exports.hashSecondRound = hashSecondRound;

/**
 * Add a third round of iterations to bring total number to 600k. This is because we used to use 1k, then 15k, so for
 * backwards compatibility with remember-me/autodecrypt links, we need to support going from that to more iterations.
 *
 * @param hashedPassword
 * @param salt
 * @returns {Promise<string>}
 */
function hashThirdRound(hashedPassword, salt) {
    return pbkdf2(hashedPassword, salt, 585000, "SHA-256");
}
exports.hashThirdRound = hashThirdRound;

/**
 * Salt and hash the password so it can be stored in localStorage without opening a password reuse vulnerability.
 *
 * @param {string} password
 * @param {string} salt
 * @param {int} iterations
 * @param {string} hashAlgorithm
 * @returns {Promise<string>}
 */
async function pbkdf2(password, salt, iterations, hashAlgorithm) {
    const key = await subtle.importKey("raw", UTF8Encoder.parse(password), "PBKDF2", false, ["deriveBits"]);

    const keyBytes = await subtle.deriveBits(
        {
            name: "PBKDF2",
            hash: hashAlgorithm,
            iterations,
            salt: UTF8Encoder.parse(salt),
        },
        key,
        256
    );

    return HexEncoder.stringify(new Uint8Array(keyBytes));
}

function generateRandomSalt() {
    const bytes = crypto.getRandomValues(new Uint8Array(128 / 8));

    return HexEncoder.stringify(new Uint8Array(bytes));
}
exports.generateRandomSalt = generateRandomSalt;

async function signMessage(hashedPassword, message) {
    const key = await subtle.importKey(
        "raw",
        HexEncoder.parse(hashedPassword),
        {
            name: "HMAC",
            hash: "SHA-256",
        },
        false,
        ["sign"]
    );
    const signature = await subtle.sign("HMAC", key, UTF8Encoder.parse(message));

    return HexEncoder.stringify(new Uint8Array(signature));
}
exports.signMessage = signMessage;

function getRandomAlphanum() {
    const possibleCharacters = "abcdefghijklmnopqrstuvwxyzABCDEFGHIJKLMNOPQRSTUVWXYZ0123456789";

    let byteArray;
    let parsedInt;

    // Keep generating new random bytes until we get a value that falls
    // within a range that can be evenly divided by possibleCharacters.length
    do {
        byteArray = crypto.getRandomValues(new Uint8Array(1));
        // extract the lowest byte to get an int from 0 to 255 (probably unnecessary, since we're only generating 1 byte)
        parsedInt = byteArray[0] & 0xff;
    } while (parsedInt >= 256 - (256 % possibleCharacters.length));

    // Take the modulo of the parsed integer to get a random number between 0 and totalLength - 1
    const randomIndex = parsedInt % possibleCharacters.length;

    return possibleCharacters[randomIndex];
}

/**
 * Generate a random string of a given length.
 *
 * @param {int} length
 * @returns {string}
 */
function generateRandomString(length) {
    let randomString = "";

    for (let i = 0; i < length; i++) {
        randomString += getRandomAlphanum();
    }

    return randomString;
}
exports.generateRandomString = generateRandomString;

  return exports;
})());
const codec = ((function(){
  const exports = {};
  /**
 * Initialize the codec with the provided cryptoEngine - this return functions to encode and decode messages.
 *
 * @param cryptoEngine - the engine to use for encryption / decryption
 */
function init(cryptoEngine) {
    const exports = {};

    /**
     * Top-level function for encoding a message.
     * Includes password hashing, encryption, and signing.
     *
     * @param {string} msg
     * @param {string} password
     * @param {string} salt
     *
     * @returns {string} The encoded text
     */
    async function encode(msg, password, salt) {
        const hashedPassword = await cryptoEngine.hashPassword(password, salt);

        const encrypted = await cryptoEngine.encrypt(msg, hashedPassword);

        // we use the hashed password in the HMAC because this is effectively what will be used a password (so we can store
        // it in localStorage safely, we don't use the clear text password)
        const hmac = await cryptoEngine.signMessage(hashedPassword, encrypted);

        return hmac + encrypted;
    }
    exports.encode = encode;

    /**
     * Encode using a password that has already been hashed. This is useful to encode multiple messages in a row, that way
     * we don't need to hash the password multiple times.
     *
     * @param {string} msg
     * @param {string} hashedPassword
     *
     * @returns {string} The encoded text
     */
    async function encodeWithHashedPassword(msg, hashedPassword) {
        const encrypted = await cryptoEngine.encrypt(msg, hashedPassword);

        // we use the hashed password in the HMAC because this is effectively what will be used a password (so we can store
        // it in localStorage safely, we don't use the clear text password)
        const hmac = await cryptoEngine.signMessage(hashedPassword, encrypted);

        return hmac + encrypted;
    }
    exports.encodeWithHashedPassword = encodeWithHashedPassword;

    /**
     * Top-level function for decoding a message.
     * Includes signature check and decryption.
     *
     * @param {string} signedMsg
     * @param {string} hashedPassword
     * @param {string} salt
     * @param {int} backwardCompatibleAttempt
     * @param {string} originalPassword
     *
     * @returns {Object} {success: true, decoded: string} | {success: false, message: string}
     */
    async function decode(signedMsg, hashedPassword, salt, backwardCompatibleAttempt = 0, originalPassword = "") {
        const encryptedHMAC = signedMsg.substring(0, 64);
        const encryptedMsg = signedMsg.substring(64);
        const decryptedHMAC = await cryptoEngine.signMessage(hashedPassword, encryptedMsg);

        if (decryptedHMAC !== encryptedHMAC) {
            // we have been raising the number of iterations in the hashing algorithm multiple times, so to support the old
            // remember-me/autodecrypt links we need to try bringing the old hashes up to speed.
            originalPassword = originalPassword || hashedPassword;
            if (backwardCompatibleAttempt === 0) {
                const updatedHashedPassword = await cryptoEngine.hashThirdRound(originalPassword, salt);

                return decode(signedMsg, updatedHashedPassword, salt, backwardCompatibleAttempt + 1, originalPassword);
            }
            if (backwardCompatibleAttempt === 1) {
                let updatedHashedPassword = await cryptoEngine.hashSecondRound(originalPassword, salt);
                updatedHashedPassword = await cryptoEngine.hashThirdRound(updatedHashedPassword, salt);

                return decode(signedMsg, updatedHashedPassword, salt, backwardCompatibleAttempt + 1, originalPassword);
            }

            return { success: false, message: "Signature mismatch" };
        }

        return {
            success: true,
            decoded: await cryptoEngine.decrypt(encryptedMsg, hashedPassword),
        };
    }
    exports.decode = decode;

    return exports;
}
exports.init = init;

  return exports;
})());
const decode = codec.init(cryptoEngine).decode;

/**
 * Initialize the staticrypt module, that exposes functions callbable by the password_template.
 *
 * @param {{
 *  staticryptEncryptedMsgUniqueVariableName: string,
 *  isRememberEnabled: boolean,
 *  rememberDurationInDays: number,
 *  staticryptSaltUniqueVariableName: string,
 * }} staticryptConfig - object of data that is stored on the password_template at encryption time.
 *
 * @param {{
 *  rememberExpirationKey: string,
 *  rememberPassphraseKey: string,
 *  replaceHtmlCallback: function,
 *  clearLocalStorageCallback: function,
 * }} templateConfig - object of data that can be configured by a custom password_template.
 */
function init(staticryptConfig, templateConfig) {
    const exports = {};

    /**
     * Decrypt our encrypted page, replace the whole HTML.
     *
     * @param {string} hashedPassword
     * @returns {Promise<boolean>}
     */
    async function decryptAndReplaceHtml(hashedPassword) {
        const { staticryptEncryptedMsgUniqueVariableName, staticryptSaltUniqueVariableName } = staticryptConfig;
        const { replaceHtmlCallback } = templateConfig;

        const result = await decode(
            staticryptEncryptedMsgUniqueVariableName,
            hashedPassword,
            staticryptSaltUniqueVariableName
        );
        if (!result.success) {
            return false;
        }
        const plainHTML = result.decoded;

        // if the user configured a callback call it, otherwise just replace the whole HTML
        if (typeof replaceHtmlCallback === "function") {
            replaceHtmlCallback(plainHTML);
        } else {
            document.write(plainHTML);
            document.close();
        }

        return true;
    }

    /**
     * Attempt to decrypt the page and replace the whole HTML.
     *
     * @param {string} password
     * @param {boolean} isRememberChecked
     *
     * @returns {Promise<{isSuccessful: boolean, hashedPassword?: string}>} - we return an object, so that if we want to
     *   expose more information in the future we can do it without breaking the password_template
     */
    async function handleDecryptionOfPage(password, isRememberChecked) {
        const { isRememberEnabled, rememberDurationInDays, staticryptSaltUniqueVariableName } = staticryptConfig;
        const { rememberExpirationKey, rememberPassphraseKey } = templateConfig;

        // decrypt and replace the whole page
        const hashedPassword = await cryptoEngine.hashPassword(password, staticryptSaltUniqueVariableName);

        const isDecryptionSuccessful = await decryptAndReplaceHtml(hashedPassword);

        if (!isDecryptionSuccessful) {
            return {
                isSuccessful: false,
                hashedPassword,
            };
        }

        // remember the hashedPassword and set its expiration if necessary
        if (isRememberEnabled && isRememberChecked) {
            window.localStorage.setItem(rememberPassphraseKey, hashedPassword);

            // set the expiration if the duration isn't 0 (meaning no expiration)
            if (rememberDurationInDays > 0) {
                window.localStorage.setItem(
                    rememberExpirationKey,
                    (new Date().getTime() + rememberDurationInDays * 24 * 60 * 60 * 1000).toString()
                );
            }
        }

        return {
            isSuccessful: true,
            hashedPassword,
        };
    }
    exports.handleDecryptionOfPage = handleDecryptionOfPage;

    /**
     * Clear localstorage from staticrypt related values
     */
    function clearLocalStorage() {
        const { clearLocalStorageCallback, rememberExpirationKey, rememberPassphraseKey } = templateConfig;

        if (typeof clearLocalStorageCallback === "function") {
            clearLocalStorageCallback();
        } else {
            localStorage.removeItem(rememberPassphraseKey);
            localStorage.removeItem(rememberExpirationKey);
        }
    }

    async function handleDecryptOnLoad() {
        let isSuccessful = await decryptOnLoadFromUrl();

        if (!isSuccessful) {
            isSuccessful = await decryptOnLoadFromRememberMe();
        }

        return { isSuccessful };
    }
    exports.handleDecryptOnLoad = handleDecryptOnLoad;

    /**
     * Clear storage if we are logging out
     *
     * @returns {boolean} - whether we logged out
     */
    function logoutIfNeeded() {
        const logoutKey = "staticrypt_logout";

        // handle logout through query param
        const queryParams = new URLSearchParams(window.location.search);
        if (queryParams.has(logoutKey)) {
            clearLocalStorage();
            return true;
        }

        // handle logout through URL fragment
        const hash = window.location.hash.substring(1);
        if (hash.includes(logoutKey)) {
            clearLocalStorage();
            return true;
        }

        return false;
    }

    /**
     * To be called on load: check if we want to try to decrypt and replace the HTML with the decrypted content, and
     * try to do it if needed.
     *
     * @returns {Promise<boolean>} true if we derypted and replaced the whole page, false otherwise
     */
    async function decryptOnLoadFromRememberMe() {
        const { rememberDurationInDays } = staticryptConfig;
        const { rememberExpirationKey, rememberPassphraseKey } = templateConfig;

        // if we are login out, terminate
        if (logoutIfNeeded()) {
            return false;
        }

        // if there is expiration configured, check if we're not beyond the expiration
        if (rememberDurationInDays && rememberDurationInDays > 0) {
            const expiration = localStorage.getItem(rememberExpirationKey),
                isExpired = expiration && new Date().getTime() > parseInt(expiration);

            if (isExpired) {
                clearLocalStorage();
                return false;
            }
        }

        const hashedPassword = localStorage.getItem(rememberPassphraseKey);

        if (hashedPassword) {
            // try to decrypt
            const isDecryptionSuccessful = await decryptAndReplaceHtml(hashedPassword);

            // if the decryption is unsuccessful the password might be wrong - silently clear the saved data and let
            // the user fill the password form again
            if (!isDecryptionSuccessful) {
                clearLocalStorage();
                return false;
            }

            return true;
        }

        return false;
    }

    function decryptOnLoadFromUrl() {
        const passwordKey = "staticrypt_pwd";

        // get the password from the query param
        const queryParams = new URLSearchParams(window.location.search);
        const hashedPasswordQuery = queryParams.get(passwordKey);

        // get the password from the url fragment
        const hashRegexMatch = window.location.hash.substring(1).match(new RegExp(passwordKey + "=(.*)"));
        const hashedPasswordFragment = hashRegexMatch ? hashRegexMatch[1] : null;

        const hashedPassword = hashedPasswordFragment || hashedPasswordQuery;

        if (hashedPassword) {
            return decryptAndReplaceHtml(hashedPassword);
        }

        return false;
    }

    return exports;
}
exports.init = init;

  return exports;
})());
        ;
            const templateError = "template_error",
                isRememberEnabled = true,
                staticryptConfig = {"staticryptEncryptedMsgUniqueVariableName":"ef86d2c98ae6b80bfef04bf38e7fb64aaae72b60c9c8b38a072dc80d52a25d7139ffe27d1d3debb8c7261319b491a782dfed41afc015d3b39a15be69778309d64721b4de2476fddebb86b69b7e8e7598abebf9b44d1b74d07eedef447ee48cd26f757a39f48dcb5870803da24db556ff49f311a0ffcaddabee97513582227df93b5f3cc62987da868cc3ae1f17c15b0f72168751abb9a12718b57d0e52aed37f0659cc075d246902d52d368262c07356840314c950736fd466a408385977ba37ce1306694dd880f125ec2ad15ed9ea7382cb05b32533ee59f5d270d7cec67972b5579a4395fce9313d15903d34d147e1b79e823f94b531c1038f9e0d94cbd6dc3595d394c9153e253a02ab1b1e5b4b88eac2e9c0be276c9889a365b3da48fa27402d56d53864eeaf4b30f0dae5b4bea77eaf6c4b8e1f0211ed530f5e49441e2e5ca9f1ee52488eaa60fb2ecffc46e458c0082121e52933e94b238c7ebd2b76210df06f020b57929c11a88dbec58d28ba07dcad7dfae148781031e129aadd26fe9c52a46a9ee4acb05f4c947804273aaab657e0a78e05361aec0e83ea4c0ee67c37c5c853be20d7f766b157c837db9de48d8c7ca290c5b5fba139de6688fefe24710dac4610c8efb38f942164a8608c0870ff62ef608d8b59bff364994eebaf0daf2a9f6db610badd361e32b48731c82fe9a015f5fac185bcd78237d8b27222220c69f923c231ce9a3e8a7285136a9b3e5afa244b782eb8570f45886e3dfd2c3ec23d924b33eab5ff2f2ac2322c028bf94151f2ebbcb73f8b20795baea1e715c1d6fff400e0431e014e87b372a17b755ec3a5051653d7fa88193161c7a890b0ca51a2778b1e68281b35dff4458b92b29b0e8779934c475b1c95c1f18d803a2285dd529fdbed40b3485e93881b220336c44573d5e4bc665454d322f0990c1c8d2c8e646708337f0b4fd7d72947b0de5db92788adc1da0c02120c3b3ce0105fb9a90365292f84e493dc27ed933a0302160fcf43b6db52db7cbcecef75894053836c4a4115591474bca824ea7283fa2826266c3f4f877620e75ba4bcc0f4be8084bb5cb1d45d144ce029d06f3424cf51526067d9bdd3b4af5d54c1f837984302d9b1cefcfba467da3ffaecffd8331295e7c71f8454c8d5f281c993ee715a5886149007cad0761fa29b9b76fc091e74504d594caeaa443e06df0f347e6a432aad9b82b33b94fb853c0ab1cc2d9c74e0f7f51697896b20c463f4c8231d6909a535643e893e5294fe10852617844d917fed309627f45a7300cdab212421df607dab65c6fe9d8d80802d05a37d15b184c35d865966e44d7c70919e0e8648af237cd76aa61424ac9f3e319d1b2ff6a4bf8014a41c5c378e60cd5fa44b3bb00d36d7215213da12c53147bf18ac20fa3a8775715c684f870af065d500c728ebc19be6ce66247677fee331837a874a859694c34b5dcb5694fcc8cc4dbff0734c713ff3f61953793bbbe50b937f278d39c6864a000fc1bb143e2e36c35cec4f7dc409c2e30ac34e45aac0ca620368504c9f24b7f5d189230d399340b452445b89ae74ec3188463dae5fc2c5d43acdd923c5d40128796c374cfcc0eb4bdff96f4f15dfaf9e82f6bcc727ce4bae89666feb442edb983573237f16a97f2660f1f467577dd42de629bc5c2eeab3b18f33a4e422f0b525da0d02b3cf39916afcd6968c0f67e4b6e11db34550abf04906f2161ceeb7122d34d946fec6c66a7908e1b7a97f2c22f2aca5f5a7de4403b5acda801aceb0754218e4ad2250ba65e80bf82c01db20a9f2aeb75d2231287bc3bc729741948492e95b3071042b535cb1bc764ec6b8bc5b842fbd1a92db8349f344f9a15ae72f04778223af2750f9a3ced5dc7e82aa19e2890b42fd5140f161824fc9d5bf6cb4f8c0bfa0a8d3dd496bd887b41108b39eb1c063376b022867c5bc43c715fb74072270988a8c899bd4072aac9e457b7154fdfc5c7788921733a79acb96c0a57e3132d692db0d1a0434b6cfe19f9f31457e82d1e9878db86e0ec9a411c60e7bb6c7b59931d64bc181a75adccd8a3b7bc7924861ec103511b1fceff94ad6d6d0d62072c2d318e7660fce03c9a1f99d0d82a0d88f5fdca087c1f709a1421d8d89697fa5439ecd2d418a56bab3ca61690bf48e8520d5fe67e65c827e40237594d9efb30c0f58c8c7ff73be2dceddb8d67a3871727b2baf31659ec525ca3b1469178b6acdefbbddc5ccee6724fe020e027f6a608826455fcb5bb3313722a1fc85677d06aeffdc476c7ea29834a45d55332ba3e5ce53bcaf592a6d5c9148a9529d6c8e29bf7377fea5ab02f1ac3c47d7ae50a5f81b982a88d6785f5b1c612495a235c25839ccc1dfca03292b49c563672422d9e4a63e486d67a4952971fa1d3763325acbab9aaf1fc0508baaf161c5f1a2c16e6eee6b6ffa27855fae6490c67de2c42f937c94bd36fab3eeaba7331fa2980ffbbf9ad9098a1d314dd00b484d0dc244bc6840638d1860fad6c3cc81b5d41d5df415e244b08a3f112e65e4a26441651062e651f180fdc3456cbd05ab6b14e5dfaaa7d04713362d115679092d22ebfc30956b09255124153ee0786066838c04c1a0e1f6e51c7d23ba329c20ddfaac9a61e27ead9677d733b4560a89301fdee4a8168f908888c3d729a0a0c172e35abfdd14b4d606430c1f8bbaec08c4800b20cc59bb4ec86b5e7656e83f3176379509685d15b66116d270591c1f46d5efbebc59108e8c8b3a7f84c0776b400e9b17d6b5cfdb9258e81f440e0a7418502af333b74295dd3a8e75226aeef6fd3af8e43e62e64ac4d5e906cd8f6befb1dd663846e8f72dc608e44476d76952f7c1820bf15414e053f1452e880eb445df8eb27a3e0a77d642a02055ecd16d2daba1fde8cce25dbc37ee50b8b805af247a35c0bb41a9e688aad780a4b8fea811b537ea4cca1c7f91b66bd07792c4971aee926166c638b706a0958b9b5846850562d7915df52dd97b1e9d102ef2e1d49bbe6384fe48eba86702e11e5262b5bd6e19aded1fc297bd25e138a7eda5d9434d8868ed8ea054797a46e73a167e51e7f2528cfc70e9d0228e6db3c89de2832a4e5134390a06f81d3a6f15fa706ee9cb2e476621a34a93e863228244f509276e6941b45adc87523c82543c0b5c1461a2d5b979d9b0fb1bb5742263c04d55bc7836351743853853d6be29d6b4d64882633b74d706762d36bcc7ce8da84975c17e1e94443913a81a8ee980d2d2d77de51a44664f55daebdaa3530f24f3028ed3e462dc606a86b2bcb047b5f7a269abadba0621a5450bad96680366526876868e63d0f34c3f7e9fc11b2695b7040900d0599150d9fb7defb230584a9b6e951f785cc130b36fa807e07e8d6e7322aafa03a6dc90a4f1b99828b22cfc8a47d4b89dde9d9a47311e93187d47ff70441a32ddd174129a74f5d16c9d20d08d9e32f6c5f9497aa928876d29359c36d5fa7b31ab6bf3531acb337a2d91ed6c3b17f957d7f73d47cdb9f53024005cd034a37187585f374e299663dcc721e4934820e1dc134a9644921a6afc0f4c81d21220c8fce8be0c811ac87715b98b8106358e0ed876bbb34d315e04ea52b87dd19ab46e2e8ffb798ed590e3cd38ff05cbe6e26ca4ab546f7836d6e257e5626911f3fb31db3f65b272541e74572a3718573ad2a1b075411fcbb6a8d79b90fb1515210d52bf57db4dc94bdbc190deba53e28b285612bf7672073fa5c275f2d989d546139d5912371c4ff513b62ef979ea4aaad86267351890ddf8000a7eb023b8b198339756fb98b8bcf3737bf227eebc67e1da7ba08f14075bae1aba125b321b729e516b0a30d433c83b65f4d8ac34d0362de3a87cb9d71c64175add06997168691fea1b411fceb2b33c90ea468bce4ca9f8e14f0efcbab911cadc168c7a07f5e0c2046614ec0ea2d58e440ad702fab28353dfbd6486f287473aebcdd55336aa0fe23d5d0625771f6ea69da2125c6d540e85ea0eeee5a4ee8f35250039432dbe7f630076f08c15e8a904356b8e06f4bbd207f4c51eac66157403dbb88efb6eeded60490ad31004496a72900e671dcd7205adf2b48ace319dc8dd8243a11408ab2cf95cd31b02a116b07bd78ac575b02eb09d08f8df7d99f9af126b5ee1fc761e0056b5a4c2a2036299287c4cfb7e7a1f34b30f53ce2e91b72321da0604d82a8dc60b2f93e2a6121ee02f6df913bd38bb9ef6948f3230631e9e38f4bbb171f20aa245bd06c4f60aa3b8464d8dc7963a6462c6365869594347e555a847dc88acb5e8d7c1a3f58b352b8476c1cf9bd31bb4b3a5b4881c69b26e3a7ac04c02356ea2237f054026b98f16e2d1bf8c3dd1061f1a9eb1273561d1c7f86b0e481ed13d67f059c4a69c20254caea1f504a8bd1687cfab2ca489dd9a4432178df7b2fcf3525f26205a82a966c46dc142889bf80dc8017b332fc90322b100f20d00ed0def64b0edccfb4e928dcc1f773671af419d09ad8ce32edc2ffc062d1f091a2d2d76b01f02735911f3de718295b62a93c8983a306ad73a4d06477748cd40c2aa4cc2a118eb91eaf519cb97d0f82449a3ee8d092f1496fa5ad26247cacaa4d47a1acea5cec6484257e1a9f338c3814133c67413fd14f11ff6f0c5f8c2af9220028072c82b23a52fa8178575566d6d354afb7bea8b624e5e1fead621531e72ded405a29282ed3f5fd7a67d0af91e99bd8ebcd9d179d25dd033df62d3db2975eea9bf18fadd1d0821530f0ab6d140f5239889948df547634cb4183d2cfc134ec1a03b756b700881d259b5eed0bee96db3cc4696148eff1295f883ae9a99575dd28a370cd12dcc0e0dff340bea636908f2d187d3c2400ef43d7b6ff3f4d5a7e17fd6ec61e7eed1350f75f23c360283bee2c02ba60c64ca8165a57f7239cd24b59eb8ba06e55bc965e13f75d6b6393bc6579da8d84506d5e871e15173c8a5c6afb08d0d6f8dfa050422f569daf6a0cf88e7b2b525bc48e97588fb2a67380bf08888af04254243a5fddf30aa7fde1915df9dc5badbc9edb48a5c307d5fc72ecbc2c6d055d3cf1f0bcafbd8b809ebb38639b4d2d13906e6c858e0bc61af2a55dba908ef09cbe8941d80ac5e35b2620049a4926b1e909d550f515e3fdf573ed4b379250bb6bd73e970e399e4248afe222a0506eaca8fd1b3e7de34234c3c1910457e0205536c23bf742e39d7973bd34a1798d30f39ca6c7a948eb5ee4462b7ec23dafc520783ad1b68a853f3e01b6a97e54e212cc7dea8f52840e2488304240df4dccdfd2e5fe5e29b5d2d3afdad9c1a66eb5285e333ea4e8e24e6a820a64cef06d050d0df6c4786ca3574212f9a5bbe63f23a497d6ec97e512a83fe6f97d666dec5d4852d9faebd8bdd5bc40af297066af7fcff8c4c781af84c2a3a264e80850afa7c9035f1e6a7cdd934ef7742a8cbbf646b344adab14820f58fdf2ed7b313512bfe22cf5c6146bc2af97cd79d8ee924fec7aa840d8f9e56a026ed0e32e59a650a502b32960eee534acbf99d3bf388d0aef2da731d58487fb00ace8da50f8f73ba4493cf1a287bdd19f3285aaf266a3c0c2e8ad441f2ad913ed6fa960530aaf46e908dfa6003eac31a971b2538fe2e05e71b26dfd3d26ea34d4e38aad8b7f3b0ed6382bfead5e2d0e11563f4e35968b44d78b646fb9e29c5c0bb357a64a343c397a5023f288adb518d5011ee6c54c473b86c7e77512ba9f4411d0b601ce008002702ed2b60ef4d77d49ae3e469213538960181c878bf3e43a3e8af03605c0032a7abb76e8a6c0c3092ee207a9975f9ba11e026fcb571c805253c1c4b516a1cc3eeb48edf5913832a0e54b92dab12b3bc083c14825715ebdc0f1b55b03dd934cb4133e7b3954be3d9f3388afa0f9921b6ff38055695b24cad5ef2860d43fbe369a26db766d7ebb38f88cddd5b4fff32d6c8d6d2cbba4590beab8a544189d29d07d3cba31afd01003235be2582772d9d13df39d916687d9c61c422294efecb7ded10b5d93474c259cca8cc884f014ac3bf45dc5025bae049d51d044d28eb74e713d62ec97422010cda1f7763850aa37d1b4cdd9a74d1890c991c4f6032d488909bf77d9058e5aaf8d67416182da2e4108d0be381f79781f367d56e04acef7b2df7e00aa44f44c1f698eebeb263b71889446e0e1ed693ea817d0df225219f4acc77d3c17db1eb1d4904c26661fb77bb4a1fa2bdb12954b611b88522f07ffa8a220fa81165443028791ee3ad517836c510354e479e045f198bcb16cf7c86ea3da8701b903e7fc5b007275c88e2da6d93a82aa83988787b1c7bc067625f575ab0d317a9996089d9ccaf413559fe550ed6896a22ace3f208b5fc520807094390780432b0a3d0b153b78218584ad0022ab53ddb70c8e9e666ffb2d50bc3b134b0d2c1e16fc7f8b2a97d23a81d8deacf7f5307b32bcde0849b9ebeb9f5ab3063474976a1da221500128bb0e7bda94eead25367f5536a6358d82c2719641765cf5fbcfa96aaf620721f645750f6baaa6ca9e2f4016b29e02574ea67b0af5512ccb17f95d85989e7b64a93fc04022fd62972d1cdf22b4876c65ba02479f4be6e3f56807b4af22d3dde6756a69d8da0be9a435724bf3a67dfc2cc6c44ebfb504470d1f4374a1b679a22aa4f158c0e671db05c41640e3b3af3e1c6213b257fab8c1608705b9c606bc02936238c771280e847bb35a31bdf313afc28ba4a39f9a09d6fd0123595c49c3b04d1fb055d41d3561a61990d89006e24eaae66076c9c0735930d5ad010bf7830b904df5e83d81a0f714c0619cba1357f8d66e7da622dd51305372b603b8139a0270abc3680440349d59401d6f8b555291561de0505d291f66a256514e8ccb53c4e3f763d59fb68187c153a88ee6eef05cc912fab12b9561c736e5f95d3d25acabfe1c5b96d32e0c9eb87cc88b6da4ce76cf4b2bcd216d5e077264d6aaee2838330e907176658546064e0c4cf3c63f294469d00371986cb5437a465b167e61dcc5b75ad3a220502dd16d4e7b1a33878c7902d60235545362059ecbce71b7103633eb47cf8b806e371a4603cd4149d40b32af9a3ab3c01380c3fea35b21eab71f255feee2d74f6a7bfe0cd6c8491ba055a1b46d7456f2ff447a45f029ed9a0c4072714177351eaefeaede6509371402901cb446f7b2df229977ccb4779f370c019126cf17bc0e7395fc24098d1f61808dac02fe9d4fae277fdbf0877c18ab13120265d33af7dd48c30003fd1392e068816344310fc976f4e833c81ea3ff0576b98226f1980ecd87874e333cc6da7fece2426a06130d034f3da5c22fbb36111a9075ee21e4544a1812c25c392b92e7204b645bae7618ab4d008b63ce878ebdba76f5df3ede05d0fa9a1604d81ced88dee18d50efb4fb1501a387a03b79c96defa898ad0ae47b62bc0ba7d1b0a2aa064e756a53a527b16d721c75672d6a6a040945417dd567daa41ce16650ee00ccda7445c0ec4abeedd104cc8d633025cbef62faf11e658cfb43afab61db7cb712c418f9aac46532a86d054f0e630a9348f9dfbff060be45e86fb5fe9baa379f32da9426df87deacfe4ad4b92d32915996578bc35c8759e8db20e5234132dd994317e20b88f7364afd95ff0cf9b58cff800368feb9a2be10a5322cc4ce8b2ef94fb109323a2b47c770729c5dba489171039d88ae2f4b7bcdfe6dd614dfd719195d3da67471fb8525eeccd6fb1844072917cbb778f2fd6a7c2517560f4a9aa355eafa2e6fa25e7b2e07a6c8caf80e846113842e3435e876c7fbb0023bc3add6a0fdb9da8d5acd30a7786e318a35cd9d0c55ec2fdeed39df03d03753618c2e875780abaa8767f748a1ec0ddd9a506ee768c470c7abd68a05deb680ede2335f6b3d8a4566985d40e13e5460164a431dc146af09f9d678a914c5417d8708ccb4fb81b5260118b195b850fac2f0bc55c92606e8dcb32b2b797422e990d3478b311130fd791c402225f48380390d52c4cdf38ef4058b5bd96ed2569c3a6694d28434ae9f146bc3ed3d7f9e80e2fed4e17efeadcc5d159198222bd8b7e8f3a049fec13097a5cff96cd79112325a6636c099886c382afa0a882e6a6912aa1bf453724c1c66a648bb2bb0dc7033d5dcf3e99e2d9f654229fab6e9a5f50293c1203886781270e376115b85ace9b38d1a1fb8e1676119f8501bd1f588bd34a1369ad6f1a7c8e8fb4d3522c80407bb6a728d3396e8dce833d6c9f27e3b752894598a719881097959e0420c86d0f25f9b5fdd121859a589ecce7f2e2e414d6c2ae350a068be93bf14b8df6bbcde659880f56bba7600cabe167294311f6096615e563292ef0cbc1e0dca32d5504febf2dab28274aefa51580efd7d01036ce2910270a6af7548476af489b09711d3c996872a8545f8d2b20bfee66a9e87c2dd884c0e321ecfe7df254a6ad1df6f77c42caec2238b1cf758205959347d108cb902454aa208b54dd75cc7e14516fab86cbc7f1c0f565e717510f14ed7d3244c3c16cfae7b5e20a8efd399cec779219f99231af4043d7ce5edd0842faa86b469bd5101e0770d7432f60507658516f7472011215616501ed40960a4713b017ab699a699c16b8eb83db6042a0b0bc80af04ad9832646d2afb6647f9c4a889d64036945788f0f5a4b1238bec94232d24c73a34e34756952921ab07be9c2602afe855fb527c19da171a3f56db6b648d3f838fe3ebbeaaca4e302fe0a4deb3d88ab4a8a356c3e54e51cac0bd3bb7240667581d2b59c1183d06d9b7d6c862e7b5a7eab996a6067b42e420d4a90ec4683d42ad6b5cf0bde4f058cb8e98e58ad44d0da91707dd39cd72b8a0caa7e8fcfd8996c287be4ff6fb7b125add2983870797246ad1b753ad2e60c6bc71cc694e0ccf1c1afbac883196319746fd9c3ee7ea796b13dc46a19f2ab7b2b5c0e64847f0765e6eaacaf7df0cf8d917ad52a996b1c2acbd046d2776d98a0df23b97f9c3764b19f67b8809ef259a91ec903829dbe3e5a2642e88a448c24714f248fc31225280cb6721604e6832","isRememberEnabled":true,"rememberDurationInDays":0,"staticryptSaltUniqueVariableName":"9dd76e7d687b9366bde9812637ad29b1"};

            // you can edit these values to customize some of the behavior of StatiCrypt
            const templateConfig = {
                rememberExpirationKey: "staticrypt_expiration",
                rememberPassphraseKey: "staticrypt_passphrase",
                replaceHtmlCallback: null,
                clearLocalStorageCallback: null,
            };

            // init the staticrypt engine
            const staticrypt = staticryptInitiator.init(staticryptConfig, templateConfig);

            // try to automatically decrypt on load if there is a saved password
            window.onload = async function () {
                const { isSuccessful } = await staticrypt.handleDecryptOnLoad();

                // if we didn't decrypt anything on load, show the password prompt. Otherwise the content has already been
                // replaced, no need to do anything
                if (!isSuccessful) {
                    // hide loading screen
                    document.getElementById("staticrypt_loading").classList.add("hidden");
                    document.getElementById("staticrypt_content").classList.remove("hidden");
                    document.getElementById("staticrypt-password").focus();

                    // show the remember me checkbox
                    if (isRememberEnabled) {
                        document.getElementById("staticrypt-remember-label").classList.remove("hidden");
                    }
                }
            };

            // handle password form submission
            document.getElementById("staticrypt-form").addEventListener("submit", async function (e) {
                e.preventDefault();

                const password = document.getElementById("staticrypt-password").value,
                    isRememberChecked = document.getElementById("staticrypt-remember").checked;

                const { isSuccessful } = await staticrypt.handleDecryptionOfPage(password, isRememberChecked);

                if (!isSuccessful) {
                    alert(templateError);
                }
            });
        </script>
    </body>
</html>
