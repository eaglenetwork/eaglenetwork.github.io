<!DOCTYPE html>
<html class="staticrypt-html">
    <head>
        <meta charset="utf-8" />
        <title>eaglenetwork</title>
        <meta name="viewport" content="width=device-width, initial-scale=1" />

        <!-- do not cache this page -->
        <meta http-equiv="cache-control" content="max-age=0" />
        <meta http-equiv="cache-control" content="no-cache" />
        <meta http-equiv="expires" content="0" />
        <meta http-equiv="expires" content="Tue, 01 Jan 1980 1:00:00 GMT" />
        <meta http-equiv="pragma" content="no-cache" />

        <style>
            .staticrypt-hr {
                margin-top: 20px;
                margin-bottom: 20px;
                border: 0;
                border-top: 1px solid #eee;
            }

            .staticrypt-page {
                width: 360px;
                padding: 8% 0 0;
                margin: auto;
                box-sizing: border-box;
            }

            .staticrypt-form {
                position: relative;
                z-index: 1;
                background: #ffffff;
                max-width: 360px;
                margin: 0 auto 100px;
                padding: 45px;
                text-align: center;
                box-shadow: 0 0 20px 0 rgba(0, 0, 0, 0.2), 0 5px 5px 0 rgba(0, 0, 0, 0.24);
            }

            .staticrypt-form input[type="password"] {
                outline: 0;
                background: #f2f2f2;
                width: 100%;
                border: 0;
                margin: 0 0 15px;
                padding: 15px;
                box-sizing: border-box;
                font-size: 14px;
            }

            .staticrypt-form .staticrypt-decrypt-button {
                text-transform: uppercase;
                outline: 0;
                background: #4CAF50;
                width: 100%;
                border: 0;
                padding: 15px;
                color: #ffffff;
                font-size: 14px;
                cursor: pointer;
            }

            .staticrypt-form .staticrypt-decrypt-button:hover,
            .staticrypt-form .staticrypt-decrypt-button:active,
            .staticrypt-form .staticrypt-decrypt-button:focus {
                background: #4CAF50;
                filter: brightness(92%);
            }

            .staticrypt-html {
                height: 100%;
            }

            .staticrypt-body {
                height: 100%;
                margin: 0;
            }

            .staticrypt-content {
                height: 100%;
                margin-bottom: 1em;
                background: #76B852;
                font-family: "Arial", sans-serif;
                -webkit-font-smoothing: antialiased;
                -moz-osx-font-smoothing: grayscale;
            }

            .staticrypt-instructions {
                margin-top: -1em;
                margin-bottom: 1em;
            }

            .staticrypt-title {
                font-size: 1.5em;
            }

            label.staticrypt-remember {
                display: flex;
                align-items: center;
                margin-bottom: 1em;
            }

            .staticrypt-remember input[type="checkbox"] {
                transform: scale(1.5);
                margin-right: 1em;
            }

            .hidden {
                display: none !important;
            }

            .staticrypt-spinner-container {
                height: 100%;
                display: flex;
                align-items: center;
                justify-content: center;
            }

            .staticrypt-spinner {
                display: inline-block;
                width: 2rem;
                height: 2rem;
                vertical-align: text-bottom;
                border: 0.25em solid gray;
                border-right-color: transparent;
                border-radius: 50%;
                -webkit-animation: spinner-border 0.75s linear infinite;
                animation: spinner-border 0.75s linear infinite;
                animation-duration: 0.75s;
                animation-timing-function: linear;
                animation-delay: 0s;
                animation-iteration-count: infinite;
                animation-direction: normal;
                animation-fill-mode: none;
                animation-play-state: running;
                animation-name: spinner-border;
            }

            @keyframes spinner-border {
                100% {
                    transform: rotate(360deg);
                }
            }
        </style>
    </head>

    <body class="staticrypt-body">
        <div id="staticrypt_loading" class="staticrypt-spinner-container">
            <div class="staticrypt-spinner"></div>
        </div>

        <div id="staticrypt_content" class="staticrypt-content hidden">
            <div class="staticrypt-page">
                <div class="staticrypt-form">
                    <div class="staticrypt-instructions">
                        <p class="staticrypt-title">eaglenetwork</p>
                        <p><p>this is an app specifically made for&nbsp;<strong>studying</strong></p>
</p>
                    </div>

                    <hr class="staticrypt-hr" />

                    <form id="staticrypt-form" action="#" method="post">
                        <input
                            id="staticrypt-password"
                            type="password"
                            name="password"
                            placeholder="enter password"
                            autofocus
                        />

                        <label id="staticrypt-remember-label" class="staticrypt-remember hidden">
                            <input id="staticrypt-remember" type="checkbox" name="remember" />
                            Remember me
                        </label>

                        <input type="submit" class="staticrypt-decrypt-button" value="decrypt" />
                    </form>
                </div>
            </div>
        </div>

        <script>
            // these variables will be filled when generating the file - the template format is 'variable_name'
            const staticryptInitiator = 
            ((function(){
  const exports = {};
  const cryptoEngine = ((function(){
  const exports = {};
  const { subtle } = crypto;

const IV_BITS = 16 * 8;
const HEX_BITS = 4;
const ENCRYPTION_ALGO = "AES-CBC";

/**
 * Translates between utf8 encoded hexadecimal strings
 * and Uint8Array bytes.
 */
const HexEncoder = {
    /**
     * hex string -> bytes
     * @param {string} hexString
     * @returns {Uint8Array}
     */
    parse: function (hexString) {
        if (hexString.length % 2 !== 0) throw "Invalid hexString";
        const arrayBuffer = new Uint8Array(hexString.length / 2);

        for (let i = 0; i < hexString.length; i += 2) {
            const byteValue = parseInt(hexString.substring(i, i + 2), 16);
            if (isNaN(byteValue)) {
                throw "Invalid hexString";
            }
            arrayBuffer[i / 2] = byteValue;
        }
        return arrayBuffer;
    },

    /**
     * bytes -> hex string
     * @param {Uint8Array} bytes
     * @returns {string}
     */
    stringify: function (bytes) {
        const hexBytes = [];

        for (let i = 0; i < bytes.length; ++i) {
            let byteString = bytes[i].toString(16);
            if (byteString.length < 2) {
                byteString = "0" + byteString;
            }
            hexBytes.push(byteString);
        }
        return hexBytes.join("");
    },
};

/**
 * Translates between utf8 strings and Uint8Array bytes.
 */
const UTF8Encoder = {
    parse: function (str) {
        return new TextEncoder().encode(str);
    },

    stringify: function (bytes) {
        return new TextDecoder().decode(bytes);
    },
};

/**
 * Salt and encrypt a msg with a password.
 */
async function encrypt(msg, hashedPassword) {
    // Must be 16 bytes, unpredictable, and preferably cryptographically random. However, it need not be secret.
    // https://developer.mozilla.org/en-US/docs/Web/API/SubtleCrypto/encrypt#parameters
    const iv = crypto.getRandomValues(new Uint8Array(IV_BITS / 8));

    const key = await subtle.importKey("raw", HexEncoder.parse(hashedPassword), ENCRYPTION_ALGO, false, ["encrypt"]);

    const encrypted = await subtle.encrypt(
        {
            name: ENCRYPTION_ALGO,
            iv: iv,
        },
        key,
        UTF8Encoder.parse(msg)
    );

    // iv will be 32 hex characters, we prepend it to the ciphertext for use in decryption
    return HexEncoder.stringify(iv) + HexEncoder.stringify(new Uint8Array(encrypted));
}
exports.encrypt = encrypt;

/**
 * Decrypt a salted msg using a password.
 *
 * @param {string} encryptedMsg
 * @param {string} hashedPassword
 * @returns {Promise<string>}
 */
async function decrypt(encryptedMsg, hashedPassword) {
    const ivLength = IV_BITS / HEX_BITS;
    const iv = HexEncoder.parse(encryptedMsg.substring(0, ivLength));
    const encrypted = encryptedMsg.substring(ivLength);

    const key = await subtle.importKey("raw", HexEncoder.parse(hashedPassword), ENCRYPTION_ALGO, false, ["decrypt"]);

    const outBuffer = await subtle.decrypt(
        {
            name: ENCRYPTION_ALGO,
            iv: iv,
        },
        key,
        HexEncoder.parse(encrypted)
    );

    return UTF8Encoder.stringify(new Uint8Array(outBuffer));
}
exports.decrypt = decrypt;

/**
 * Salt and hash the password so it can be stored in localStorage without opening a password reuse vulnerability.
 *
 * @param {string} password
 * @param {string} salt
 * @returns {Promise<string>}
 */
async function hashPassword(password, salt) {
    // we hash the password in multiple steps, each adding more iterations. This is because we used to allow less
    // iterations, so for backward compatibility reasons, we need to support going from that to more iterations.
    let hashedPassword = await hashLegacyRound(password, salt);

    hashedPassword = await hashSecondRound(hashedPassword, salt);

    return hashThirdRound(hashedPassword, salt);
}
exports.hashPassword = hashPassword;

/**
 * This hashes the password with 1k iterations. This is a low number, we need this function to support backwards
 * compatibility.
 *
 * @param {string} password
 * @param {string} salt
 * @returns {Promise<string>}
 */
function hashLegacyRound(password, salt) {
    return pbkdf2(password, salt, 1000, "SHA-1");
}
exports.hashLegacyRound = hashLegacyRound;

/**
 * Add a second round of iterations. This is because we used to use 1k, so for backwards compatibility with
 * remember-me/autodecrypt links, we need to support going from that to more iterations.
 *
 * @param hashedPassword
 * @param salt
 * @returns {Promise<string>}
 */
function hashSecondRound(hashedPassword, salt) {
    return pbkdf2(hashedPassword, salt, 14000, "SHA-256");
}
exports.hashSecondRound = hashSecondRound;

/**
 * Add a third round of iterations to bring total number to 600k. This is because we used to use 1k, then 15k, so for
 * backwards compatibility with remember-me/autodecrypt links, we need to support going from that to more iterations.
 *
 * @param hashedPassword
 * @param salt
 * @returns {Promise<string>}
 */
function hashThirdRound(hashedPassword, salt) {
    return pbkdf2(hashedPassword, salt, 585000, "SHA-256");
}
exports.hashThirdRound = hashThirdRound;

/**
 * Salt and hash the password so it can be stored in localStorage without opening a password reuse vulnerability.
 *
 * @param {string} password
 * @param {string} salt
 * @param {int} iterations
 * @param {string} hashAlgorithm
 * @returns {Promise<string>}
 */
async function pbkdf2(password, salt, iterations, hashAlgorithm) {
    const key = await subtle.importKey("raw", UTF8Encoder.parse(password), "PBKDF2", false, ["deriveBits"]);

    const keyBytes = await subtle.deriveBits(
        {
            name: "PBKDF2",
            hash: hashAlgorithm,
            iterations,
            salt: UTF8Encoder.parse(salt),
        },
        key,
        256
    );

    return HexEncoder.stringify(new Uint8Array(keyBytes));
}

function generateRandomSalt() {
    const bytes = crypto.getRandomValues(new Uint8Array(128 / 8));

    return HexEncoder.stringify(new Uint8Array(bytes));
}
exports.generateRandomSalt = generateRandomSalt;

async function signMessage(hashedPassword, message) {
    const key = await subtle.importKey(
        "raw",
        HexEncoder.parse(hashedPassword),
        {
            name: "HMAC",
            hash: "SHA-256",
        },
        false,
        ["sign"]
    );
    const signature = await subtle.sign("HMAC", key, UTF8Encoder.parse(message));

    return HexEncoder.stringify(new Uint8Array(signature));
}
exports.signMessage = signMessage;

function getRandomAlphanum() {
    const possibleCharacters = "abcdefghijklmnopqrstuvwxyzABCDEFGHIJKLMNOPQRSTUVWXYZ0123456789";

    let byteArray;
    let parsedInt;

    // Keep generating new random bytes until we get a value that falls
    // within a range that can be evenly divided by possibleCharacters.length
    do {
        byteArray = crypto.getRandomValues(new Uint8Array(1));
        // extract the lowest byte to get an int from 0 to 255 (probably unnecessary, since we're only generating 1 byte)
        parsedInt = byteArray[0] & 0xff;
    } while (parsedInt >= 256 - (256 % possibleCharacters.length));

    // Take the modulo of the parsed integer to get a random number between 0 and totalLength - 1
    const randomIndex = parsedInt % possibleCharacters.length;

    return possibleCharacters[randomIndex];
}

/**
 * Generate a random string of a given length.
 *
 * @param {int} length
 * @returns {string}
 */
function generateRandomString(length) {
    let randomString = "";

    for (let i = 0; i < length; i++) {
        randomString += getRandomAlphanum();
    }

    return randomString;
}
exports.generateRandomString = generateRandomString;

  return exports;
})());
const codec = ((function(){
  const exports = {};
  /**
 * Initialize the codec with the provided cryptoEngine - this return functions to encode and decode messages.
 *
 * @param cryptoEngine - the engine to use for encryption / decryption
 */
function init(cryptoEngine) {
    const exports = {};

    /**
     * Top-level function for encoding a message.
     * Includes password hashing, encryption, and signing.
     *
     * @param {string} msg
     * @param {string} password
     * @param {string} salt
     *
     * @returns {string} The encoded text
     */
    async function encode(msg, password, salt) {
        const hashedPassword = await cryptoEngine.hashPassword(password, salt);

        const encrypted = await cryptoEngine.encrypt(msg, hashedPassword);

        // we use the hashed password in the HMAC because this is effectively what will be used a password (so we can store
        // it in localStorage safely, we don't use the clear text password)
        const hmac = await cryptoEngine.signMessage(hashedPassword, encrypted);

        return hmac + encrypted;
    }
    exports.encode = encode;

    /**
     * Encode using a password that has already been hashed. This is useful to encode multiple messages in a row, that way
     * we don't need to hash the password multiple times.
     *
     * @param {string} msg
     * @param {string} hashedPassword
     *
     * @returns {string} The encoded text
     */
    async function encodeWithHashedPassword(msg, hashedPassword) {
        const encrypted = await cryptoEngine.encrypt(msg, hashedPassword);

        // we use the hashed password in the HMAC because this is effectively what will be used a password (so we can store
        // it in localStorage safely, we don't use the clear text password)
        const hmac = await cryptoEngine.signMessage(hashedPassword, encrypted);

        return hmac + encrypted;
    }
    exports.encodeWithHashedPassword = encodeWithHashedPassword;

    /**
     * Top-level function for decoding a message.
     * Includes signature check and decryption.
     *
     * @param {string} signedMsg
     * @param {string} hashedPassword
     * @param {string} salt
     * @param {int} backwardCompatibleAttempt
     * @param {string} originalPassword
     *
     * @returns {Object} {success: true, decoded: string} | {success: false, message: string}
     */
    async function decode(signedMsg, hashedPassword, salt, backwardCompatibleAttempt = 0, originalPassword = "") {
        const encryptedHMAC = signedMsg.substring(0, 64);
        const encryptedMsg = signedMsg.substring(64);
        const decryptedHMAC = await cryptoEngine.signMessage(hashedPassword, encryptedMsg);

        if (decryptedHMAC !== encryptedHMAC) {
            // we have been raising the number of iterations in the hashing algorithm multiple times, so to support the old
            // remember-me/autodecrypt links we need to try bringing the old hashes up to speed.
            originalPassword = originalPassword || hashedPassword;
            if (backwardCompatibleAttempt === 0) {
                const updatedHashedPassword = await cryptoEngine.hashThirdRound(originalPassword, salt);

                return decode(signedMsg, updatedHashedPassword, salt, backwardCompatibleAttempt + 1, originalPassword);
            }
            if (backwardCompatibleAttempt === 1) {
                let updatedHashedPassword = await cryptoEngine.hashSecondRound(originalPassword, salt);
                updatedHashedPassword = await cryptoEngine.hashThirdRound(updatedHashedPassword, salt);

                return decode(signedMsg, updatedHashedPassword, salt, backwardCompatibleAttempt + 1, originalPassword);
            }

            return { success: false, message: "Signature mismatch" };
        }

        return {
            success: true,
            decoded: await cryptoEngine.decrypt(encryptedMsg, hashedPassword),
        };
    }
    exports.decode = decode;

    return exports;
}
exports.init = init;

  return exports;
})());
const decode = codec.init(cryptoEngine).decode;

/**
 * Initialize the staticrypt module, that exposes functions callbable by the password_template.
 *
 * @param {{
 *  staticryptEncryptedMsgUniqueVariableName: string,
 *  isRememberEnabled: boolean,
 *  rememberDurationInDays: number,
 *  staticryptSaltUniqueVariableName: string,
 * }} staticryptConfig - object of data that is stored on the password_template at encryption time.
 *
 * @param {{
 *  rememberExpirationKey: string,
 *  rememberPassphraseKey: string,
 *  replaceHtmlCallback: function,
 *  clearLocalStorageCallback: function,
 * }} templateConfig - object of data that can be configured by a custom password_template.
 */
function init(staticryptConfig, templateConfig) {
    const exports = {};

    /**
     * Decrypt our encrypted page, replace the whole HTML.
     *
     * @param {string} hashedPassword
     * @returns {Promise<boolean>}
     */
    async function decryptAndReplaceHtml(hashedPassword) {
        const { staticryptEncryptedMsgUniqueVariableName, staticryptSaltUniqueVariableName } = staticryptConfig;
        const { replaceHtmlCallback } = templateConfig;

        const result = await decode(
            staticryptEncryptedMsgUniqueVariableName,
            hashedPassword,
            staticryptSaltUniqueVariableName
        );
        if (!result.success) {
            return false;
        }
        const plainHTML = result.decoded;

        // if the user configured a callback call it, otherwise just replace the whole HTML
        if (typeof replaceHtmlCallback === "function") {
            replaceHtmlCallback(plainHTML);
        } else {
            document.write(plainHTML);
            document.close();
        }

        return true;
    }

    /**
     * Attempt to decrypt the page and replace the whole HTML.
     *
     * @param {string} password
     * @param {boolean} isRememberChecked
     *
     * @returns {Promise<{isSuccessful: boolean, hashedPassword?: string}>} - we return an object, so that if we want to
     *   expose more information in the future we can do it without breaking the password_template
     */
    async function handleDecryptionOfPage(password, isRememberChecked) {
        const { isRememberEnabled, rememberDurationInDays, staticryptSaltUniqueVariableName } = staticryptConfig;
        const { rememberExpirationKey, rememberPassphraseKey } = templateConfig;

        // decrypt and replace the whole page
        const hashedPassword = await cryptoEngine.hashPassword(password, staticryptSaltUniqueVariableName);

        const isDecryptionSuccessful = await decryptAndReplaceHtml(hashedPassword);

        if (!isDecryptionSuccessful) {
            return {
                isSuccessful: false,
                hashedPassword,
            };
        }

        // remember the hashedPassword and set its expiration if necessary
        if (isRememberEnabled && isRememberChecked) {
            window.localStorage.setItem(rememberPassphraseKey, hashedPassword);

            // set the expiration if the duration isn't 0 (meaning no expiration)
            if (rememberDurationInDays > 0) {
                window.localStorage.setItem(
                    rememberExpirationKey,
                    (new Date().getTime() + rememberDurationInDays * 24 * 60 * 60 * 1000).toString()
                );
            }
        }

        return {
            isSuccessful: true,
            hashedPassword,
        };
    }
    exports.handleDecryptionOfPage = handleDecryptionOfPage;

    /**
     * Clear localstorage from staticrypt related values
     */
    function clearLocalStorage() {
        const { clearLocalStorageCallback, rememberExpirationKey, rememberPassphraseKey } = templateConfig;

        if (typeof clearLocalStorageCallback === "function") {
            clearLocalStorageCallback();
        } else {
            localStorage.removeItem(rememberPassphraseKey);
            localStorage.removeItem(rememberExpirationKey);
        }
    }

    async function handleDecryptOnLoad() {
        let isSuccessful = await decryptOnLoadFromUrl();

        if (!isSuccessful) {
            isSuccessful = await decryptOnLoadFromRememberMe();
        }

        return { isSuccessful };
    }
    exports.handleDecryptOnLoad = handleDecryptOnLoad;

    /**
     * Clear storage if we are logging out
     *
     * @returns {boolean} - whether we logged out
     */
    function logoutIfNeeded() {
        const logoutKey = "staticrypt_logout";

        // handle logout through query param
        const queryParams = new URLSearchParams(window.location.search);
        if (queryParams.has(logoutKey)) {
            clearLocalStorage();
            return true;
        }

        // handle logout through URL fragment
        const hash = window.location.hash.substring(1);
        if (hash.includes(logoutKey)) {
            clearLocalStorage();
            return true;
        }

        return false;
    }

    /**
     * To be called on load: check if we want to try to decrypt and replace the HTML with the decrypted content, and
     * try to do it if needed.
     *
     * @returns {Promise<boolean>} true if we derypted and replaced the whole page, false otherwise
     */
    async function decryptOnLoadFromRememberMe() {
        const { rememberDurationInDays } = staticryptConfig;
        const { rememberExpirationKey, rememberPassphraseKey } = templateConfig;

        // if we are login out, terminate
        if (logoutIfNeeded()) {
            return false;
        }

        // if there is expiration configured, check if we're not beyond the expiration
        if (rememberDurationInDays && rememberDurationInDays > 0) {
            const expiration = localStorage.getItem(rememberExpirationKey),
                isExpired = expiration && new Date().getTime() > parseInt(expiration);

            if (isExpired) {
                clearLocalStorage();
                return false;
            }
        }

        const hashedPassword = localStorage.getItem(rememberPassphraseKey);

        if (hashedPassword) {
            // try to decrypt
            const isDecryptionSuccessful = await decryptAndReplaceHtml(hashedPassword);

            // if the decryption is unsuccessful the password might be wrong - silently clear the saved data and let
            // the user fill the password form again
            if (!isDecryptionSuccessful) {
                clearLocalStorage();
                return false;
            }

            return true;
        }

        return false;
    }

    function decryptOnLoadFromUrl() {
        const passwordKey = "staticrypt_pwd";

        // get the password from the query param
        const queryParams = new URLSearchParams(window.location.search);
        const hashedPasswordQuery = queryParams.get(passwordKey);

        // get the password from the url fragment
        const hashRegexMatch = window.location.hash.substring(1).match(new RegExp(passwordKey + "=(.*)"));
        const hashedPasswordFragment = hashRegexMatch ? hashRegexMatch[1] : null;

        const hashedPassword = hashedPasswordFragment || hashedPasswordQuery;

        if (hashedPassword) {
            return decryptAndReplaceHtml(hashedPassword);
        }

        return false;
    }

    return exports;
}
exports.init = init;

  return exports;
})());
        ;
            const templateError = "template_error",
                isRememberEnabled = true,
                staticryptConfig = {"staticryptEncryptedMsgUniqueVariableName":"5ef980d42a80b59267364709d4ecb7db5e0b35f786328be71c6ee00f433c851990f81dd02d7df465c1bbc64b8730fad79df09a3e1ba666ccfb2371d6267a3a5e2da48636bd31592ff78ea2fffad429da187d467a5faaff8ecc7587856a6201f6e6c55140502549cbd67b88264bbcee98e1bb34a32cdab3a14a049aab6bb325d2d8651fdf57fb0c9f626f4ccf9d2870e98df3149488b3515b471cf8c4ba213ae006152c39d939bf2d649806ce0b7b0f52bc6cdaefc53a7b55f7930496c2c53e6ad66613392cebac4d91fce961fe796dcc84f7c601b3d85b741f7605038e8dc7054cb77ae1230119c4955b37fe3679675384ef15e31f95ee42c8cd1f5607469ef4c8328e1a6ba5c371dd77823f556bf8c964603000d8b46d1e0e3cfa7338b079fa84054bf5c904a839f3f5739822a27052f284b602088911b3b8f823dd79a41cdb67c4cd4f1d66a3a5166d57abdb76aa1ea678b08d05a01c2de532f2c19f1de502f245a748072659e934236e7f46b55a3e4e717e7254deb365e0f783eb9055609668ba5a3b3ff5995de0ef9b9b83395bee06ac04c30728ea9f626d0bf84473ff6fa1ec23c27d5d84862228da8d72e832994388a5f681cb39923292dee94fc2b3a35f1eb4d6888fbf05b0ec4ff8f63b663f8b1ea4c60ccf56a7bec2e0ad24bd3472fb36ca4ce7110da6c77168a0e87868e1139477ac50b101477b04cbb4c8f69b10069ac65a31f08165cb94ddd405c2742f46fa515d441cb66e6b2f0e094de0c9f25c68d5bb944b7d5a2090f89c44bc5b80275d55046cdf6effa137e5a58ddca5d72a70d131da8f2e84243d358ad45fffb061c6af56bda67f949b30f3e49697efb88b5b58f88e6126814fbb531972b229a0c81358246f047618856febe6a9f2b0b4d5caa4dd6ca42f0ccf19fddc4e472cf82a9fab501ae041093e3c85ddd89c8c56dfbe93a872ba3daec06d48c4e4394618da0d07bc64702815d189354d808cd1e1304cad8acc985ded51f67a57d516cf58ff847126a7fd23ca040b2a459e67e90445e1d763f42bd9d2160d6528727fc9a4f8dcace48bf6710f6b9650b648c9e743116cf9086088f42221b6c2a6586524ed1bd1570e81fd138778b9e95e98af81b64e8e3a831ac2a4b30ab7d9d9ec8ffd35e7f68090be50a6f1c9593f721014412c0b35efbbce3472c61f6f06531908626b0899624b57e5a8ecf932d618ba626b22bb57b76a5033372cc85cd81c078716792ad13d6da466599de115b4eb7dce04fbf28fe310e6d7a12271e9b66d45588b4b922fa9034f4c5acafbca276ead4b0630004cc33b6aab51d94c4b1e0d5f6152ca07903faa7f2fb27a9c9e87b4bee7c416d19648e10903dbd867cf6f293d7b09523ab94dd652779ed4fe33ce0ef168c54d31b4d77aa5da381461c6ccbec8472e4ac408446316c20abde19f331ba3825d51b7bcebc9382ee0f759abcf6c741e10a39c439970198bf1ec42ca9f24234388afddeac74bd2fe0ee70144fadba7281b7b4c52a37bc032854ef8c9bc5fb7c756a5ec95f2d7c8d57891f620a6134ca3df266c48813558e60b6077b7a197eda001ea014734387a47f5a37e89aaa45842af9f9570df8034e33e0897061b08d9af635323d42adc76e50f76544492a10a69a751bf6b7d123261009ccb26a11dafca7f837c1d8961a71a250227c6ce5b5918b9bbeb035709b4324eed90fc869af0ac6f7978f5be460a744cb881f65cf044d1ed427080251848ea7b5fef4abbd6c08268b31a0a3a35d89ea43df71e20b4509401b0d52a5116997dee008726d84bc3094105a47df567271b8f9c1563a4141bd584810f7b406d7174f192d8de6f97153db621a3ea422ae563f9d19b693a74c5e3c25649aa4c707f434e4d943f98886296f0710d30a9eb060764187954606c86336699ad1467815ebf9b36368e3b088a16b7e53e1c4b716b12e7485640a55796c1abcbe1c0b50505e3ad5ea84135677f65590a11a25530af0525ac1afd07a4dc25872161a9e937ca04287da02d3901df50cbf22fa908c6af2ff4640e9a2ef5e5fc39200fd2f5bf726f689e1ef330f8de88375aa71ae419fdb60b0a5c4c1fae6eac813fa04b1485a205f6e20edbf77e30d5183529572459b1a3f6fa55b8f399e0caa82e510b0fb0d627e96bd945041aa4729aee206467d2c3f51e78a36e536f71d35193f0a9342939f12a44eb25b0f122a95bfc35ccb9d272f2b2c4f0d1c73671a45bfd8ffadf73d15e959893e1f8df18b5ade6d078ea67a50c5b0a87a50004ebcd59f52e1d5f37f2393525151ecdfb3c68bb25ab72c888f74fddba655237b1f475508b1f98998f78ef138cfb3071777b7aa12b6b2b58b1631f232aa30b4ec708d8d5e7ddf305047627eee6d77757438ea0d3d10353180c9bce4512cfde6e5e5a0307b4e0e6f6a1c6d754e9ec262e61ab4848e2e12e998f23b1b0210db9a839fa936686ba7858361f4add9bb6ecfb3303b0d33b480d0e5adc2e220bdb2bd1f845c383c801a75ecf662c35c5e7f5bdaddbb41c0c60066b9ca80962c895d86ffa11ba0bcd51ac52c24bb5e9f84b075cc24295792fa656d6c30680a0849750010291142a2a538ac556b197c8178aa78f04c231b229629871f66f2e6411995237904e6fb0e878ea4a1d1ec784d8bb25f1c80ea6159bdbf119fe6470d957f7e258a14e7bf87cd61f4f70e38c8be6f1e25c3aa3bedf2f3e6b4ff395f5ed78ea5298709bc97fde6b35e698c57e5b0c79080324516918cd3e55cd8c76efa535825e74c26cf04b26ba97f1f44ad1a3a661aed5f26f1561c14d61f9ea87a28621c503a2b92d0341611e095b7431061c5b5a240c6263c247f1bcc83da59acfef1ab8aeeb30011c791ae1297fbb65a06213988a49d3bb11152f1b0e0a6a452722a5922dda0a6b892f807609c05c74db5a809a9cef23d5bd4a586332b2640bf2691b62f86a922862f1f09d2c5ca1059aeac9efae646145981880a87c9018ed7b68bcfd609ed16e6e0dfdc1d8a63c5c03df22aadfd0cf0b3e3ccfc50cb8d8eb248ef3c9dc021888d56731df5a257c90e7b4f48555d24af75b83c119f5ccf4d8deaba34a2b9e7848b94f41f1c773680ad0a1e8a2bdf1ab99ee1feaafd74d6d9b667d9ff3fecfe384bd6d36131e4da024f7abfa098bb704077488771b4ce87d56ec87f389e33c6f7ff4ebc2ed80a7d07a3a78de5700797077171a45fcd449c7ad960d494c1254419a7a144202c2817585544d0e9589f415a9cb9bbd2b6362985265b2db198b80628c968eff385c00b440c586c1b8a9e68ff2672996f225f6c4b94e5b6af9651785cee7cb9309596f170de27968a6984c7c36aeb9df8db151360cecdadf1c3a7b664a2eb012b9f8b14acfa4f3f775607ac92ac4e37d83b1f99fe68968246ca886b26b4dffb0537c0ae8b3b1a030b3da8be39af5e2105457cb6b0c7f15b8b29d378ee16b5daccc89947effa63a2b3f42072915e4ea64fe1d0a1a642da6e5d11130bbc2649422e8b2b10fbb7b95a34bcd0ad0046e409f0706ca2088cea4b493eabe6c15c095c98bdbdd7b28278c32f6d9904e12892cbe5c8626c84b310d2b2a4337486c7714f8f9747f490ae6a9c376cc0d49fd93aef20b2fb2cd8216162f95d5e6a32259e22ed7de00d1a8942834c33699bb21372f06e524f3636d14ba75e0112c2632986c003669d6df92e9f1f771d981f067fc43646310021997b4f250b4cd9dcaf750f1804bc86abb52d47d2f18a1d4ad039a0446468a60c327147f5f24651a3700f8381634bc1a52830e5e9f3f7589cbc387723174082a080e0668ef6c35199f58b4c4b0016d57ff940a745ba8531d960c33549c924df3d268ee4996ad6485d19654feb0dcde20b4e862a2cf1fb5555cad4a10b7f3675c226057f1346449ed74b512a8fbda2cb2df3ba747087f8b1ae9536ee9e09c9300dbf07ec9046e62a20e51bbd3ed0171ce1f0817207cd43d2582dfccb2ce628fdc34ba4e14bcc78f6926f11e970fdb2b3bd17e67013cceca9ae22182a9b2bd50b1ad016e56753b6b2e905d67c0e44e517c8125275188b3b44ca3e7271be39cb930268f64cc60ebb8b5c1cff744de55f094df68e9995c128b8e7ae98e82e7cb96c7b108d7a260ea4ac7f904dfac7ca9c46bae4b02ff0c3edf41472cae3ba95c8da244beaf24189413de4e3f8fc3ca0c1a43841110863496994253c11511ffe201880354e937cc3d4f9e0cf54040c3dd097fbf15f36f8fd830f1eedab5ab3b77850894b3bafa7aff2aef2a38b64e93af2eb35816f7fe54a1e30c243bd99db7d30f69e259be85289123d5c86576246ff106101621088edc70cb2616ddcf689ccdec03282b04f6d39a996aef61ca86eb55436b9ed69ebaa7ffbd9eb156a00c2424de0c2463429288c59f438ddd46a93e8052ccddc815fbb6eb0661efdfe021bee9c971b0f051f832fd346516d2f5d4a88345a30b13d8c957dd14159f3c0bfa3c3a33f9c21cf290173da9d2440b6ae665bd65a0856834e5aec40895d803cee897d2cbbc13ebadbbf5418a4b6b19c4c1730753a34d622795bcbb7f207693e1d3acea427ab03770656d8c007ee9794c0aa17736fd19edeee12699999a0acdf7e7dcd83353b5aaeac4629652b22fbcb7b17275a01eb8ad68c1c30f64a36845d6a80016160de72dd11a9fcd70cae952ea6ecded7fbd93679a3461c39144333db381e9c6efb77a8cff6d6a9bc656b09cd36dc378030fa47b314e64ce2e1f4e13419e46c22f05e10f9c4387f64bc9c3226ec9e41c95a5c19ae5ef3656de8156f5b4025558236b778ba4ac8aa0005e8423c79b60bcb34666d91e0d096ff70e4ce2c69688904c1ac25ff940db19d76b96ddff4da8e105b94d492da8b441f6ca939111308c1823bdaceaf3e2d25b23a963294f3f47d266df35a44b8b77bfa0dd71aab8c2c27db1f330eb8a04f559b56cd942df486b6163070d2528b325bc1e461355397b39b4093ff462962fa557e86816589f480d49c3c99e2c6041c335bda0c9d1d043cbb765c2876bf1e24294f008d31621f34be1c0e006415b2da3b1875fb52f4f1f63aa83280e758415c6ef6424edee7a085abdb019b4bc052d8a1c3716f85ef51371a7a2901f5dcb0d24debc557d5db414c4f0a269dc479a3dc1d999c2f4aca16e3c8ffeadbe6cbbe1361dde6463f51088870bc195e6af433b7f1097909d1a47e0d6aab90fa04f3f076a3b4ba4422d50b6a3e8a0061fc5390907f56b813839fec606062c69f8610e0859259aaee7d18334767a8adbe919ff3217a61986e131474992741538bfc20043cd6f8101f7d6a9c18a9657a9545258540df9bd77697e4dd017400f788fea8f863a4fe4186a7130e16117b12c6db5a9ac157d1e2f9dc33f5fa7d74830dc4a061931a834a401ec750257da3fd04ea05395c75567504a7634d4f7031832211cc1749ae726fa6d1e2d342a39c90a39a35cb763a8d2abff9192d9dd1e53d03bb0f6f7c1db8954e02288d7380a35f436756273d3f7aa79b2f055ad9e9f610dad3be43beaf46c0c2faa6ad226cfc5fb3e76917bc31ef7947b94808536bd6d117b04d97598ce798fcd78a76dc2d9b22c03dcb415911c103086d564665c20b862e1621ba430f1ef1a8bf3b3a031cb76e64d0752b899a9737b4df2465cc4ceeaff51757352f388d90846e8a89fa381e33a8924d6c1f35c198b3bc1e6625c82f88cb8f54783eb91f40e092a9c6a5f92abf946e404bb90b289c6dc081e5befeb3bf527617912ca3506e387455bd4da15a0d0ebd6e215b49bfad7fc1590c82c62efee0e073672fb39c3685367e3d9006ad8b725a2cd225fdb7d59340bbdda3b854e6181c499acf0819e990359c3bd3eb97e1c0daa8a20b9395814a9a38655d3819d1ef5849779a8f495cc80248bb1482794405a0d2f907c5e8758495f2724a84de5f21dc09c1580dedf8f4b7ef49baea347fc9afb0b21af2fd687162df2df7b6b333e0518305ae3d45d20b24cd924ac7c6bb964bcf3aa67f2f8d1a905aa60da66ccc625e3e31b65fbbab81709611497a7a28f8fedab8dd2c8b8fa2195cd3d0d7e97a41e2229f47c9d05f264fd52446ce8661077b109a46bf4701cdf5b11b027f474ebb6e3533928eb66c5e91fe03574077f9ecf59950161cf0b35be11f80e779ae81fc104f3495cf94f6e44ca3d51e2274dbb824262bb6ef26ea71f3a02637828eef4390cefab308f0312ec92c34cb73922185b011ec2068dd0897d80564bf8069cc8bd799a7aeee409e1cd06a64f0c5294883ab963019d84e687d0324e739daceb1bfe1394e15b929e40c5fa8a776b5f418954b80e1e836aba2ba66207f8df419110ba4acf72c8ca479d75e1c7b99ef0ce870baea88e575d4df4c9b4566b98078af4cea5e932a476bb35441c69bfa2e2decc7c24c9f5ceeac03537637f379ccb88e162d1f4d02cab97569fdc970e20e799a4cac4cf5e421ff917eb8db1fd8767fe6bc9c4287c4da073294e7542e9ce47c3ad3b1819d17f7db95ebf621ecab58800168eb001ec8d4db9439ef67f0002a209ec9f4eab61005e0b70ff15978defde3ae4f88c6662fafc2ad78779e590eb8672e5e9bff3903a9c0c4439feca167d74367118a0d6040507a05f3646a29ee052bfb5dd95b7e7551ece40c9906fad8619ab75c41e9389810f8d3e88858e15c15d7566d8a27e4629115f8798587c411d6803026fe610bd7d7814d95de2b9df5c3c11a71991fa8990210338ae0ae4c9ffb76f810f0e6de54dfa5f80be71882e741b6d06562e7dbab85aa5a0a164b6bb1be9f88e0ff35f264ee6640aea76413615","isRememberEnabled":true,"rememberDurationInDays":0,"staticryptSaltUniqueVariableName":"02a54540720a44414bfbb454fd53fa1a"};

            // you can edit these values to customize some of the behavior of StatiCrypt
            const templateConfig = {
                rememberExpirationKey: "staticrypt_expiration",
                rememberPassphraseKey: "staticrypt_passphrase",
                replaceHtmlCallback: null,
                clearLocalStorageCallback: null,
            };

            // init the staticrypt engine
            const staticrypt = staticryptInitiator.init(staticryptConfig, templateConfig);

            // try to automatically decrypt on load if there is a saved password
            window.onload = async function () {
                const { isSuccessful } = await staticrypt.handleDecryptOnLoad();

                // if we didn't decrypt anything on load, show the password prompt. Otherwise the content has already been
                // replaced, no need to do anything
                if (!isSuccessful) {
                    // hide loading screen
                    document.getElementById("staticrypt_loading").classList.add("hidden");
                    document.getElementById("staticrypt_content").classList.remove("hidden");
                    document.getElementById("staticrypt-password").focus();

                    // show the remember me checkbox
                    if (isRememberEnabled) {
                        document.getElementById("staticrypt-remember-label").classList.remove("hidden");
                    }
                }
            };

            // handle password form submission
            document.getElementById("staticrypt-form").addEventListener("submit", async function (e) {
                e.preventDefault();

                const password = document.getElementById("staticrypt-password").value,
                    isRememberChecked = document.getElementById("staticrypt-remember").checked;

                const { isSuccessful } = await staticrypt.handleDecryptionOfPage(password, isRememberChecked);

                if (!isSuccessful) {
                    alert(templateError);
                }
            });
        </script>
    </body>
</html>
