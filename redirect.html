<!DOCTYPE html>
<html class="staticrypt-html">
    <head>
        <meta charset="utf-8" />
        <title>eaglenetwork</title>
        <meta name="viewport" content="width=device-width, initial-scale=1" />

        <!-- do not cache this page -->
        <meta http-equiv="cache-control" content="max-age=0" />
        <meta http-equiv="cache-control" content="no-cache" />
        <meta http-equiv="expires" content="0" />
        <meta http-equiv="expires" content="Tue, 01 Jan 1980 1:00:00 GMT" />
        <meta http-equiv="pragma" content="no-cache" />

        <style>
            .staticrypt-hr {
                margin-top: 20px;
                margin-bottom: 20px;
                border: 0;
                border-top: 1px solid #eee;
            }

            .staticrypt-page {
                width: 360px;
                padding: 8% 0 0;
                margin: auto;
                box-sizing: border-box;
            }

            .staticrypt-form {
                position: relative;
                z-index: 1;
                background: #ffffff;
                max-width: 360px;
                margin: 0 auto 100px;
                padding: 45px;
                text-align: center;
                box-shadow: 0 0 20px 0 rgba(0, 0, 0, 0.2), 0 5px 5px 0 rgba(0, 0, 0, 0.24);
            }

            .staticrypt-form input[type="password"] {
                outline: 0;
                background: #f2f2f2;
                width: 100%;
                border: 0;
                margin: 0 0 15px;
                padding: 15px;
                box-sizing: border-box;
                font-size: 14px;
            }

            .staticrypt-form .staticrypt-decrypt-button {
                text-transform: uppercase;
                outline: 0;
                background: #4CAF50;
                width: 100%;
                border: 0;
                padding: 15px;
                color: #ffffff;
                font-size: 14px;
                cursor: pointer;
            }

            .staticrypt-form .staticrypt-decrypt-button:hover,
            .staticrypt-form .staticrypt-decrypt-button:active,
            .staticrypt-form .staticrypt-decrypt-button:focus {
                background: #4CAF50;
                filter: brightness(92%);
            }

            .staticrypt-html {
                height: 100%;
            }

            .staticrypt-body {
                height: 100%;
                margin: 0;
            }

            .staticrypt-content {
                height: 100%;
                margin-bottom: 1em;
                background: #76B852;
                font-family: "Arial", sans-serif;
                -webkit-font-smoothing: antialiased;
                -moz-osx-font-smoothing: grayscale;
            }

            .staticrypt-instructions {
                margin-top: -1em;
                margin-bottom: 1em;
            }

            .staticrypt-title {
                font-size: 1.5em;
            }

            label.staticrypt-remember {
                display: flex;
                align-items: center;
                margin-bottom: 1em;
            }

            .staticrypt-remember input[type="checkbox"] {
                transform: scale(1.5);
                margin-right: 1em;
            }

            .hidden {
                display: none !important;
            }

            .staticrypt-spinner-container {
                height: 100%;
                display: flex;
                align-items: center;
                justify-content: center;
            }

            .staticrypt-spinner {
                display: inline-block;
                width: 2rem;
                height: 2rem;
                vertical-align: text-bottom;
                border: 0.25em solid gray;
                border-right-color: transparent;
                border-radius: 50%;
                -webkit-animation: spinner-border 0.75s linear infinite;
                animation: spinner-border 0.75s linear infinite;
                animation-duration: 0.75s;
                animation-timing-function: linear;
                animation-delay: 0s;
                animation-iteration-count: infinite;
                animation-direction: normal;
                animation-fill-mode: none;
                animation-play-state: running;
                animation-name: spinner-border;
            }

            @keyframes spinner-border {
                100% {
                    transform: rotate(360deg);
                }
            }
        </style>
    </head>

    <body class="staticrypt-body">
        <div id="staticrypt_loading" class="staticrypt-spinner-container">
            <div class="staticrypt-spinner"></div>
        </div>

        <div id="staticrypt_content" class="staticrypt-content hidden">
            <div class="staticrypt-page">
                <div class="staticrypt-form">
                    <div class="staticrypt-instructions">
                        <p class="staticrypt-title">eaglenetwork</p>
                        <p></p>
                    </div>

                    <hr class="staticrypt-hr" />

                    <form id="staticrypt-form" action="#" method="post">
                        <input
                            id="staticrypt-password"
                            type="password"
                            name="password"
                            placeholder="Password"
                            autofocus
                        />

                        <label id="staticrypt-remember-label" class="staticrypt-remember hidden">
                            <input id="staticrypt-remember" type="checkbox" name="remember" />
                            Remember me
                        </label>

                        <input type="submit" class="staticrypt-decrypt-button" value="DECRYPT" />
                    </form>
                </div>
            </div>
        </div>

        <script>
            // these variables will be filled when generating the file - the template format is 'variable_name'
            const staticryptInitiator = 
            ((function(){
  const exports = {};
  const cryptoEngine = ((function(){
  const exports = {};
  const { subtle } = crypto;

const IV_BITS = 16 * 8;
const HEX_BITS = 4;
const ENCRYPTION_ALGO = "AES-CBC";

/**
 * Translates between utf8 encoded hexadecimal strings
 * and Uint8Array bytes.
 */
const HexEncoder = {
    /**
     * hex string -> bytes
     * @param {string} hexString
     * @returns {Uint8Array}
     */
    parse: function (hexString) {
        if (hexString.length % 2 !== 0) throw "Invalid hexString";
        const arrayBuffer = new Uint8Array(hexString.length / 2);

        for (let i = 0; i < hexString.length; i += 2) {
            const byteValue = parseInt(hexString.substring(i, i + 2), 16);
            if (isNaN(byteValue)) {
                throw "Invalid hexString";
            }
            arrayBuffer[i / 2] = byteValue;
        }
        return arrayBuffer;
    },

    /**
     * bytes -> hex string
     * @param {Uint8Array} bytes
     * @returns {string}
     */
    stringify: function (bytes) {
        const hexBytes = [];

        for (let i = 0; i < bytes.length; ++i) {
            let byteString = bytes[i].toString(16);
            if (byteString.length < 2) {
                byteString = "0" + byteString;
            }
            hexBytes.push(byteString);
        }
        return hexBytes.join("");
    },
};

/**
 * Translates between utf8 strings and Uint8Array bytes.
 */
const UTF8Encoder = {
    parse: function (str) {
        return new TextEncoder().encode(str);
    },

    stringify: function (bytes) {
        return new TextDecoder().decode(bytes);
    },
};

/**
 * Salt and encrypt a msg with a password.
 */
async function encrypt(msg, hashedPassword) {
    // Must be 16 bytes, unpredictable, and preferably cryptographically random. However, it need not be secret.
    // https://developer.mozilla.org/en-US/docs/Web/API/SubtleCrypto/encrypt#parameters
    const iv = crypto.getRandomValues(new Uint8Array(IV_BITS / 8));

    const key = await subtle.importKey("raw", HexEncoder.parse(hashedPassword), ENCRYPTION_ALGO, false, ["encrypt"]);

    const encrypted = await subtle.encrypt(
        {
            name: ENCRYPTION_ALGO,
            iv: iv,
        },
        key,
        UTF8Encoder.parse(msg)
    );

    // iv will be 32 hex characters, we prepend it to the ciphertext for use in decryption
    return HexEncoder.stringify(iv) + HexEncoder.stringify(new Uint8Array(encrypted));
}
exports.encrypt = encrypt;

/**
 * Decrypt a salted msg using a password.
 *
 * @param {string} encryptedMsg
 * @param {string} hashedPassword
 * @returns {Promise<string>}
 */
async function decrypt(encryptedMsg, hashedPassword) {
    const ivLength = IV_BITS / HEX_BITS;
    const iv = HexEncoder.parse(encryptedMsg.substring(0, ivLength));
    const encrypted = encryptedMsg.substring(ivLength);

    const key = await subtle.importKey("raw", HexEncoder.parse(hashedPassword), ENCRYPTION_ALGO, false, ["decrypt"]);

    const outBuffer = await subtle.decrypt(
        {
            name: ENCRYPTION_ALGO,
            iv: iv,
        },
        key,
        HexEncoder.parse(encrypted)
    );

    return UTF8Encoder.stringify(new Uint8Array(outBuffer));
}
exports.decrypt = decrypt;

/**
 * Salt and hash the password so it can be stored in localStorage without opening a password reuse vulnerability.
 *
 * @param {string} password
 * @param {string} salt
 * @returns {Promise<string>}
 */
async function hashPassword(password, salt) {
    // we hash the password in multiple steps, each adding more iterations. This is because we used to allow less
    // iterations, so for backward compatibility reasons, we need to support going from that to more iterations.
    let hashedPassword = await hashLegacyRound(password, salt);

    hashedPassword = await hashSecondRound(hashedPassword, salt);

    return hashThirdRound(hashedPassword, salt);
}
exports.hashPassword = hashPassword;

/**
 * This hashes the password with 1k iterations. This is a low number, we need this function to support backwards
 * compatibility.
 *
 * @param {string} password
 * @param {string} salt
 * @returns {Promise<string>}
 */
function hashLegacyRound(password, salt) {
    return pbkdf2(password, salt, 1000, "SHA-1");
}
exports.hashLegacyRound = hashLegacyRound;

/**
 * Add a second round of iterations. This is because we used to use 1k, so for backwards compatibility with
 * remember-me/autodecrypt links, we need to support going from that to more iterations.
 *
 * @param hashedPassword
 * @param salt
 * @returns {Promise<string>}
 */
function hashSecondRound(hashedPassword, salt) {
    return pbkdf2(hashedPassword, salt, 14000, "SHA-256");
}
exports.hashSecondRound = hashSecondRound;

/**
 * Add a third round of iterations to bring total number to 600k. This is because we used to use 1k, then 15k, so for
 * backwards compatibility with remember-me/autodecrypt links, we need to support going from that to more iterations.
 *
 * @param hashedPassword
 * @param salt
 * @returns {Promise<string>}
 */
function hashThirdRound(hashedPassword, salt) {
    return pbkdf2(hashedPassword, salt, 585000, "SHA-256");
}
exports.hashThirdRound = hashThirdRound;

/**
 * Salt and hash the password so it can be stored in localStorage without opening a password reuse vulnerability.
 *
 * @param {string} password
 * @param {string} salt
 * @param {int} iterations
 * @param {string} hashAlgorithm
 * @returns {Promise<string>}
 */
async function pbkdf2(password, salt, iterations, hashAlgorithm) {
    const key = await subtle.importKey("raw", UTF8Encoder.parse(password), "PBKDF2", false, ["deriveBits"]);

    const keyBytes = await subtle.deriveBits(
        {
            name: "PBKDF2",
            hash: hashAlgorithm,
            iterations,
            salt: UTF8Encoder.parse(salt),
        },
        key,
        256
    );

    return HexEncoder.stringify(new Uint8Array(keyBytes));
}

function generateRandomSalt() {
    const bytes = crypto.getRandomValues(new Uint8Array(128 / 8));

    return HexEncoder.stringify(new Uint8Array(bytes));
}
exports.generateRandomSalt = generateRandomSalt;

async function signMessage(hashedPassword, message) {
    const key = await subtle.importKey(
        "raw",
        HexEncoder.parse(hashedPassword),
        {
            name: "HMAC",
            hash: "SHA-256",
        },
        false,
        ["sign"]
    );
    const signature = await subtle.sign("HMAC", key, UTF8Encoder.parse(message));

    return HexEncoder.stringify(new Uint8Array(signature));
}
exports.signMessage = signMessage;

function getRandomAlphanum() {
    const possibleCharacters = "abcdefghijklmnopqrstuvwxyzABCDEFGHIJKLMNOPQRSTUVWXYZ0123456789";

    let byteArray;
    let parsedInt;

    // Keep generating new random bytes until we get a value that falls
    // within a range that can be evenly divided by possibleCharacters.length
    do {
        byteArray = crypto.getRandomValues(new Uint8Array(1));
        // extract the lowest byte to get an int from 0 to 255 (probably unnecessary, since we're only generating 1 byte)
        parsedInt = byteArray[0] & 0xff;
    } while (parsedInt >= 256 - (256 % possibleCharacters.length));

    // Take the modulo of the parsed integer to get a random number between 0 and totalLength - 1
    const randomIndex = parsedInt % possibleCharacters.length;

    return possibleCharacters[randomIndex];
}

/**
 * Generate a random string of a given length.
 *
 * @param {int} length
 * @returns {string}
 */
function generateRandomString(length) {
    let randomString = "";

    for (let i = 0; i < length; i++) {
        randomString += getRandomAlphanum();
    }

    return randomString;
}
exports.generateRandomString = generateRandomString;

  return exports;
})());
const codec = ((function(){
  const exports = {};
  /**
 * Initialize the codec with the provided cryptoEngine - this return functions to encode and decode messages.
 *
 * @param cryptoEngine - the engine to use for encryption / decryption
 */
function init(cryptoEngine) {
    const exports = {};

    /**
     * Top-level function for encoding a message.
     * Includes password hashing, encryption, and signing.
     *
     * @param {string} msg
     * @param {string} password
     * @param {string} salt
     *
     * @returns {string} The encoded text
     */
    async function encode(msg, password, salt) {
        const hashedPassword = await cryptoEngine.hashPassword(password, salt);

        const encrypted = await cryptoEngine.encrypt(msg, hashedPassword);

        // we use the hashed password in the HMAC because this is effectively what will be used a password (so we can store
        // it in localStorage safely, we don't use the clear text password)
        const hmac = await cryptoEngine.signMessage(hashedPassword, encrypted);

        return hmac + encrypted;
    }
    exports.encode = encode;

    /**
     * Encode using a password that has already been hashed. This is useful to encode multiple messages in a row, that way
     * we don't need to hash the password multiple times.
     *
     * @param {string} msg
     * @param {string} hashedPassword
     *
     * @returns {string} The encoded text
     */
    async function encodeWithHashedPassword(msg, hashedPassword) {
        const encrypted = await cryptoEngine.encrypt(msg, hashedPassword);

        // we use the hashed password in the HMAC because this is effectively what will be used a password (so we can store
        // it in localStorage safely, we don't use the clear text password)
        const hmac = await cryptoEngine.signMessage(hashedPassword, encrypted);

        return hmac + encrypted;
    }
    exports.encodeWithHashedPassword = encodeWithHashedPassword;

    /**
     * Top-level function for decoding a message.
     * Includes signature check and decryption.
     *
     * @param {string} signedMsg
     * @param {string} hashedPassword
     * @param {string} salt
     * @param {int} backwardCompatibleAttempt
     * @param {string} originalPassword
     *
     * @returns {Object} {success: true, decoded: string} | {success: false, message: string}
     */
    async function decode(signedMsg, hashedPassword, salt, backwardCompatibleAttempt = 0, originalPassword = "") {
        const encryptedHMAC = signedMsg.substring(0, 64);
        const encryptedMsg = signedMsg.substring(64);
        const decryptedHMAC = await cryptoEngine.signMessage(hashedPassword, encryptedMsg);

        if (decryptedHMAC !== encryptedHMAC) {
            // we have been raising the number of iterations in the hashing algorithm multiple times, so to support the old
            // remember-me/autodecrypt links we need to try bringing the old hashes up to speed.
            originalPassword = originalPassword || hashedPassword;
            if (backwardCompatibleAttempt === 0) {
                const updatedHashedPassword = await cryptoEngine.hashThirdRound(originalPassword, salt);

                return decode(signedMsg, updatedHashedPassword, salt, backwardCompatibleAttempt + 1, originalPassword);
            }
            if (backwardCompatibleAttempt === 1) {
                let updatedHashedPassword = await cryptoEngine.hashSecondRound(originalPassword, salt);
                updatedHashedPassword = await cryptoEngine.hashThirdRound(updatedHashedPassword, salt);

                return decode(signedMsg, updatedHashedPassword, salt, backwardCompatibleAttempt + 1, originalPassword);
            }

            return { success: false, message: "Signature mismatch" };
        }

        return {
            success: true,
            decoded: await cryptoEngine.decrypt(encryptedMsg, hashedPassword),
        };
    }
    exports.decode = decode;

    return exports;
}
exports.init = init;

  return exports;
})());
const decode = codec.init(cryptoEngine).decode;

/**
 * Initialize the staticrypt module, that exposes functions callbable by the password_template.
 *
 * @param {{
 *  staticryptEncryptedMsgUniqueVariableName: string,
 *  isRememberEnabled: boolean,
 *  rememberDurationInDays: number,
 *  staticryptSaltUniqueVariableName: string,
 * }} staticryptConfig - object of data that is stored on the password_template at encryption time.
 *
 * @param {{
 *  rememberExpirationKey: string,
 *  rememberPassphraseKey: string,
 *  replaceHtmlCallback: function,
 *  clearLocalStorageCallback: function,
 * }} templateConfig - object of data that can be configured by a custom password_template.
 */
function init(staticryptConfig, templateConfig) {
    const exports = {};

    /**
     * Decrypt our encrypted page, replace the whole HTML.
     *
     * @param {string} hashedPassword
     * @returns {Promise<boolean>}
     */
    async function decryptAndReplaceHtml(hashedPassword) {
        const { staticryptEncryptedMsgUniqueVariableName, staticryptSaltUniqueVariableName } = staticryptConfig;
        const { replaceHtmlCallback } = templateConfig;

        const result = await decode(
            staticryptEncryptedMsgUniqueVariableName,
            hashedPassword,
            staticryptSaltUniqueVariableName
        );
        if (!result.success) {
            return false;
        }
        const plainHTML = result.decoded;

        // if the user configured a callback call it, otherwise just replace the whole HTML
        if (typeof replaceHtmlCallback === "function") {
            replaceHtmlCallback(plainHTML);
        } else {
            document.write(plainHTML);
            document.close();
        }

        return true;
    }

    /**
     * Attempt to decrypt the page and replace the whole HTML.
     *
     * @param {string} password
     * @param {boolean} isRememberChecked
     *
     * @returns {Promise<{isSuccessful: boolean, hashedPassword?: string}>} - we return an object, so that if we want to
     *   expose more information in the future we can do it without breaking the password_template
     */
    async function handleDecryptionOfPage(password, isRememberChecked) {
        const { isRememberEnabled, rememberDurationInDays, staticryptSaltUniqueVariableName } = staticryptConfig;
        const { rememberExpirationKey, rememberPassphraseKey } = templateConfig;

        // decrypt and replace the whole page
        const hashedPassword = await cryptoEngine.hashPassword(password, staticryptSaltUniqueVariableName);

        const isDecryptionSuccessful = await decryptAndReplaceHtml(hashedPassword);

        if (!isDecryptionSuccessful) {
            return {
                isSuccessful: false,
                hashedPassword,
            };
        }

        // remember the hashedPassword and set its expiration if necessary
        if (isRememberEnabled && isRememberChecked) {
            window.localStorage.setItem(rememberPassphraseKey, hashedPassword);

            // set the expiration if the duration isn't 0 (meaning no expiration)
            if (rememberDurationInDays > 0) {
                window.localStorage.setItem(
                    rememberExpirationKey,
                    (new Date().getTime() + rememberDurationInDays * 24 * 60 * 60 * 1000).toString()
                );
            }
        }

        return {
            isSuccessful: true,
            hashedPassword,
        };
    }
    exports.handleDecryptionOfPage = handleDecryptionOfPage;

    /**
     * Clear localstorage from staticrypt related values
     */
    function clearLocalStorage() {
        const { clearLocalStorageCallback, rememberExpirationKey, rememberPassphraseKey } = templateConfig;

        if (typeof clearLocalStorageCallback === "function") {
            clearLocalStorageCallback();
        } else {
            localStorage.removeItem(rememberPassphraseKey);
            localStorage.removeItem(rememberExpirationKey);
        }
    }

    async function handleDecryptOnLoad() {
        let isSuccessful = await decryptOnLoadFromUrl();

        if (!isSuccessful) {
            isSuccessful = await decryptOnLoadFromRememberMe();
        }

        return { isSuccessful };
    }
    exports.handleDecryptOnLoad = handleDecryptOnLoad;

    /**
     * Clear storage if we are logging out
     *
     * @returns {boolean} - whether we logged out
     */
    function logoutIfNeeded() {
        const logoutKey = "staticrypt_logout";

        // handle logout through query param
        const queryParams = new URLSearchParams(window.location.search);
        if (queryParams.has(logoutKey)) {
            clearLocalStorage();
            return true;
        }

        // handle logout through URL fragment
        const hash = window.location.hash.substring(1);
        if (hash.includes(logoutKey)) {
            clearLocalStorage();
            return true;
        }

        return false;
    }

    /**
     * To be called on load: check if we want to try to decrypt and replace the HTML with the decrypted content, and
     * try to do it if needed.
     *
     * @returns {Promise<boolean>} true if we derypted and replaced the whole page, false otherwise
     */
    async function decryptOnLoadFromRememberMe() {
        const { rememberDurationInDays } = staticryptConfig;
        const { rememberExpirationKey, rememberPassphraseKey } = templateConfig;

        // if we are login out, terminate
        if (logoutIfNeeded()) {
            return false;
        }

        // if there is expiration configured, check if we're not beyond the expiration
        if (rememberDurationInDays && rememberDurationInDays > 0) {
            const expiration = localStorage.getItem(rememberExpirationKey),
                isExpired = expiration && new Date().getTime() > parseInt(expiration);

            if (isExpired) {
                clearLocalStorage();
                return false;
            }
        }

        const hashedPassword = localStorage.getItem(rememberPassphraseKey);

        if (hashedPassword) {
            // try to decrypt
            const isDecryptionSuccessful = await decryptAndReplaceHtml(hashedPassword);

            // if the decryption is unsuccessful the password might be wrong - silently clear the saved data and let
            // the user fill the password form again
            if (!isDecryptionSuccessful) {
                clearLocalStorage();
                return false;
            }

            return true;
        }

        return false;
    }

    function decryptOnLoadFromUrl() {
        const passwordKey = "staticrypt_pwd";

        // get the password from the query param
        const queryParams = new URLSearchParams(window.location.search);
        const hashedPasswordQuery = queryParams.get(passwordKey);

        // get the password from the url fragment
        const hashRegexMatch = window.location.hash.substring(1).match(new RegExp(passwordKey + "=(.*)"));
        const hashedPasswordFragment = hashRegexMatch ? hashRegexMatch[1] : null;

        const hashedPassword = hashedPasswordFragment || hashedPasswordQuery;

        if (hashedPassword) {
            return decryptAndReplaceHtml(hashedPassword);
        }

        return false;
    }

    return exports;
}
exports.init = init;

  return exports;
})());
        ;
            const templateError = "template_error",
                isRememberEnabled = true,
                staticryptConfig = {"staticryptEncryptedMsgUniqueVariableName":"61f2198043cc8a3d111ec53febb0603f95cc6b76e1488bd61e46adc47b0936b2b017d6ad892bc18d14188ebfb5e595b12a4ea908e2402b914d87417df9e9fae69c84b9b329637700620814f4affd878c148cc3939717ccb6499ba137668ebe24bd067dfa6f784d2cf423db5af757d9b27be055dd659e0cb45ae29f890b364c02d2c28a3b5fa1338a54665acc3d8c71aef3978699a0cda4a79ab4c92b630f40f5d1dbc5b5167269e6e508798cf90303bdaa6fa1d001959a846ba9cbd72429a28e2910183c211a2321a79e51d942481c1101cd648d85d6191802afbcc956123ee764a4069cf3e29d70270e3787246c95e5ef528a2f018a63b2b43c9210ba0a6ab4d81cbda81927789e468d047027c283f4ef71de066aea0205c270171aff0021d1d44a548ad90bf0c2d51847cd8e74ebb20abb7fd33c0c96484f063a60b364b06599a070a3729f67f212e1d542b1d633ace3fb4b8db70a5e6d34fb062b96d2bc7c7c03ae23ac8671d3413d229f9720263c3ab56889bead6d805607e659db3b03808fd3ac2f54123b791949818b6a7af0df2d09e6940a0c8a9db767a1769af8ea886b69c77059e1bff981fa36e6216428cf46619bcff4145c38654ff373bee8b0916d18bff065ae0ab4e9fcc15a9050aafe0a492e33298f1c822ac7ed4e024a81a132b7872fb6cc64d7f0e372bbacfc3aa0083ddc83f219f0fe4e01a8eb03879cfd6bacc01a8796d63c6f34d707f936193cd99f5d6b77311cb48a1831cc56b039416c1595293e07030e9888f85479aa9a2f76b8b8e405aceaf6363e75914a36bd97380ec9368cc202ba072a5b9011d8fa2c4a56385de4d63ca4928c46f1e2cf02904fe5f6a9342c6f34ea5c7e5b160365aa93fe433a8c8f0c1bccf80873600cf2c77f0e026a9cf63b24dda0d6f83a2db54670ec95d80521678bd16c470c15dcad5f680a5eaffb77424c70fe08b0974e355be0ce5d449f987ec9757c7a93f7169ff97bfa51f42b37ca83791548d8ee83dfc1073f5f8d2c512ca9621c0ec576535a6f5db0f77afaa3d679d4c21237345edc87592ba6bde76846824db0ef44d231e4c5a574750ebb8337aa07f72846a8912926c3c7aa84b275f776e439eb8a993b777e1fd876cdcf1605bb6746ce77f5c496ffcd71907186fd2604e37cea91ec2d18307f10dc00305aa1cc153c99d9f03ada91022fc4ce63b6569621dee5c3db51867dec32abcfbe3ea7d8beacc756f2e4814b90eb85556e2d153f032a8512d6a3f1253020f198b28f8aecaec846f9a63ade73fb0931e16604acc9b1d714924ce2948a82ac51289f31c34807b2bdcf518492fb7a25b9123b830e3b462f220885a5dffce7f26e999c46384598984ac012954d0f104487b3c199008d2ab10dde5d22aca10b48ba3d26edc129f0a454ff2664f139797499a29a39843b119f94b6c40de9e997b61a1b6590bf3865c50016e2537ce844dafec06b39e77e800bf652ee0fb9052600352dfdb35a7b99449097a3dc5acf26826918a752d86028bfea8d01c208b4b7f24dfe859588e58b6692f4537ecc7f4911a9d55917b8937244bc2277dfb261cc8ff8cb297e40e72e4a7080b03883871cd1a8606afa3a34e0e1a802669f487a62b34e0147267777823c1e0a908f879fc96645ad4284efb1d86f4fbe96e4c666988ca6c4e3fcc25e77321be4638d9dd63ee15e1f55ad57b5d977913647d6507e9cd53f9de0348f49299261eae064a2911759ab035ad8934f7c2218bb7df99ac065bb8a4f1f477f4c77259552d2e27d8560cb3138653c65c3521f6e367988eea88922d32e51f7df47d0648c0ee9b9884343359890129a98fa1dc05b467250b0f04dce56b9b2ce4267ea17cb1ab533472ff02326d94beecad41a6c655db83cc55fd2a321170b05fce87a3c4aca9e42fb2f06cb6dbd6b9a4c50f8b9d56b89609a55f5f5ef1cbb07058eab0d43e7f72b07d94552a537a25b7bc05e31df52d5a5d12c638d20ab68e8f7c923fea17ee9b161607ad5990fd1e46fe33beb711714cb8a56be3d4e549abf7eb22bfcd98d0b47ab71dfce38d126e1647d88e1610563f996777f2c11b1c95112da686d8b08b1321bbcb2c0fddcf785443b547a6dc27c3fa82dabb13c001d2b4c4943a86640a04e6eaa3c924416f9c85b24a7762003cf967504dc7181a6f6be249200c8c8819008d3d3aa5023ef1af0a4f97bd664f49defa818b618be1d26b8fd1cbcc98e6c0bb6c400f9688f64abe2de9c7c67556163c8495b02a54997289f67975f3fbeb8bce911801163e874eae494b3fe4281cd5cd0b83ae70bd9bb8f6240fc2ed40253f5e8cc5d8d8a167c201267316127f250b5df659d1e9bd0e790e83cb10d22cd5fca12359212860016d18e3b3303254a20d61978d30f99497aab6e41c88b68f231b3a1849fb369d15fd9c29c45c3eca310deaaa095f6393650c5524bda8c1bac2047c79583ac2103162d56bdb5a902c33c78f645cef0873f30d2d501a461c7cbe3c55533a4a0f37ac340ef1f9ca3a828221067dde02aafa7b80f1da8231f738763d363e0aa234121390a06ff5a6a97ef93e99b865a4ab93457c99006285c44afe66432b3eea89a6546a0d1fb46b476f529e3a591fda50c55f2239915d9eeaaa9de51159f2c9d263624f54cae04bd3c412881bbd7af784d76b8054b201bc5221a5ee0da4a431bde4085907b6667aa109bce2915b1512298f494ec4d5f30955c9a1cc6801062aac89eb8a85f739d0be504787a496f7f77ccb39ae6c1e75b17a62018072137fa74721ccd3542dfa2edce7daf345b5aeb1527d51b8bda493fc596da6e0c74ea767394d39453b0592d481f231a207755d87150fa9d4eb8c2b510ec4b35e0d86f8c9c46689a8070b93355a1d685475406c5d75f661205f73954588545f77fc36c59946b0635f71caf3df2482c2a462d38fbd26140684b31325c13b6f1945bf1099ddaa54d87fd956e2d45c2774e7881711827281d85af4157c0c88bea984c448f96b53216e12964dbd15e086e0aaf4570adf06b25752bf9ca1981d6466d79131165c1dc921d08ea96d23610c7aa2199e457126fff193a31fba068d6ea830df0540af62235a1dbada6bbac81288e9718644c1796ff93d9e3babcff01ef2c09f4f97e0da10b436760acf44f17ad1ab83ab9425d1262a96967412dead3704865c9792c1afcf66165e8117866c2f4e11f40b1e8f3aa1b2f8869a5e080fd3afc8bb2e7582c7f576e2125ed6c33235bc9295aafffba43484ecfba2174451f6e7224320235f2b09808e8002b9429d136c9acac5c3bb5d38ff7b826b657b706e86b1885496c8a46824348a04d485c55190546ae8c25184008ecd812dd90f7ca043088b793b5c9ff387d16fa72711ecd6e9d52870308db31b9228aaed16fe1cd795f7474afd0e763b2a3fe506951a796cbd4348c3b33f4f6137d3d2fe716b666110ebdfec348c479da25eac04aa5e7ceeeb98c541ce93b2bc50eca1b7dab8ee9fbfdd1801ee8551bbe776e042e030b11644c7a2c0acea199f9b60e33f71a342948ef5af6fbc85355b04eb38b94fcb59a51e650d00c480cebe67e3092104dd58054ddf320e995e2995c80e482f7871128fde08ed4c8f1cb58f1beadec84c6c77253a72cba1e63f569e62b82889784cbbcc6f2933d9fd4e1959dc04af07aba0229e12e7293ac3f06b4baf9e6477b79093095a693c195f72766870144a11c0468c3100e143243b23a1e9d1f9fc1ea93f40b28c40c000c9e3d37d385160dfb7fdce9aa91297db5fb8dfd11aea0dbc7a7a460e828105224e0d9eea5654109c4c2c63b625c2789799b660161a11eacb5eb34c1c6b3ef8e034ee0024219ed81c9c1300fb5e04e184f8c2cfdb7ffae13bd461bfd1f0c240bd5cef6ab3d1ae46f7f99d205fc327beee4e7c0c84c5a210a4bfe83b3f8a0351deb08f15d5e9f9ec2ee1345183d0a9a6aba5c018f6563b7e217b0727f0b1409ae84600732b8774d0a8df0b695de5c70870986611d3c8d369f2c4c06f6b65d730781832b05f6c23e153576297136088ad3974f950e1a7f32be66215cbde134c12553f022df4490c62cd1bb6d4dba321628869ac57257da9bf3909ce59046111829bd093a13c3b67944278a4ae72f99e6f1b9c0c5516588f2d37929ddccdfd778ff2d130a2fe711bc58e8c04706112218d1292d3bade396a5b35e824602990c0c1da900eb1d71eae649278e0b887074d8c7226c347ecb30453e9a529bdc184d44cb330ea8ef477c80be7264b67c814df5542dc2ee5992deb1a6832bb123c47ca52f87ae72a0a624094b4b150f46c8ed76039b1b194791e0266e3f0b0147c6bd26009681b2db369e5dbbc2c478120ca08799c185e802ecd78d42509594541a8cfa2ba3d701f4391fa63cca9ef71f5093e67a4f66998a5b65f37010a558d2ae161d4804a2ef120e844912725b15492d563a855e8fc1b01324452241b1d8588bc0057c345ed4f487f84cec6f8d70ad77ae8ac9bc5f0a7d1e35182b04cb1be1e4c6cecff1d740036a107587aefda68780bdfb01bf0e49ee0ef7cf2d4045650adb5fbc371316f282267bd65eb54b1228a69ed3d037d4768b34455e2b8493578841ee0207922b0fefe5772c4a370df8cab234d5733ec3313952004d8ad9ed38aedb19414a3913ebe449f888bb6498b285b4865ab5908f78b0da2ea7b2b72a6524b50cf96a3c8fdbd2fe97b5fac58206ffc77f41db3d8d7f39de975732450c57ca0c7d36cf67c105648c5e440617dfc0a2406b293ffaccd229ce9f325ca26778bac5f58292f40498dc06ab59255973c1abbe7cb1e03c7a7c5b62ae40bd0ef0036c33dc238376c2054bc12920babd1d0d67cd4664a81d2c17f20c36a26b8477e115783f40d819d9fd4119e74c24c2c843f2a7c7d74b4b5849e805bee0e51d1e4f3d1d3677adb2b6f9a86894030fe32a4d151b6eb97b6b4c9250eb3c4d4478b17200cb83a365350268a1ac3032ccbf9aced13720b85d7d800981d705bbfc77772be48bd9c28acd9029f3aa6a0b61820d0806244fbb2b386ce53f4856ab4940ef5939383c78f46000f6133a91b792f7e370cdd7babf16c9e5c6a0a4e4faec4f14c2b524ba305b8d26219d2717426cad811299cbefe4ca6461882efdde943a2b9d777cc892326ba7bc2efe42a537897e2eef1a28e232bbef4fd9d68e2d24ae1ee79f1dd37ca0507eed4cad3faabd9011b05913e5db2811ca2094b661ce73fab43190ced38d615dc66a8f19790d85b05f46fff3503fd4ba3520bb5a2563392e4f4c2edd53b06edc0da59b024336037fa8797e9d4609b297f56daec4996fcc444dec04be758c70db90233d53967eef04aac3cb2f49082c5fe81ca5489b55ca11d6bb85a0c4180b6365696ef1ae3b165efed001663ca70b8ee83069557c4eb74aeb61de35948282ff85af600cb31d8be921cc88c4aab44388bde76cc602d2bbb204e0b8af125b99356cbdac64bf97e462ce85cdbcefb841b98b7bbc3f630a21483086fc5fb14bc9599d6769652234ba87cde7a4274683a3afc8803cb90639a5b306854ba4f9ac0e3f3f03316fd605c58c1c5ec85c516e0106d698dc57e2c240592321a2492d1aa860c225cf9da22951108573972e76459859460d25d8c3785a5bd105072c6d2e80313b1ca99c9d3e44ebd37fd66f194ee60d35c2b4f73798a08b3a7300ca8b772a9f8a43a945e1661a88eb1689b06be24b38d1fe954a834b0b8509bf5ecb77588c1546cb61b4297a0fa4f656393ece541459c470cc2d56138bbce94b894317c01c7839671de3c25daabacab81384c468f5ce03d05808b7c1054251201a5c22fdca30023264268ea3f6a05fc2171737f8228917972bf6605d83253e788e8c41403391f54d63caccca7c02eccbf801d36687b9fa2da503f86e872fbf0508ed9e1c8c187a012628cdb5760e810c9b2ea023b11bda891cfba35584a422bb33a46c8bc284d4e625699d6f17007ae6f568ca5738f6e9d9241f4b824f9013b67911cf086f61181a9aef2e63ffda6b3c4d9bee816f8a35601f36ecdb7df770794568de0ae95c90765d1ae61889574f766e92bf928fcbf81b5fb8ee7f56c5595fceaba2dc52e900f49fcbd7425c66cfd8f702abdbe47f10d5d916ae2e333ad27d82768fbe712da786d05646e7a7d4d3ef6cf4d0628aa886b0b6e3ac55095c63a2b27b038fb97ae0cb47481f6d327ecea67b3e7f47afe0b2b93e83b752f744e05fb1a632cd28db64a255ddd027342b2373309c51a4b36a1c4a431afe0247e3d689429c0ead0f0f024093073bbbbccd19f36c676aaaa592abbf1d4765398e1fa0326610a502a997a082bbb00055414cb77587e49d9b3e701ee381b4e85d846681c7cf720094d273a81d9264f03daa99dcd95653789a673681d431a2f0fdf2a29ebf35ca320e56c5b1be74c6bacc8a87460901f03c59afb1ad9fb3b22045419c3fa48119a5fba4ef4070788552d61b78c2a16d299f40d9521c7c73945fa205974b0b9608b83f7bf8980e76bcbfedef66062a9f8f6953f1348065a7a7dda2aa415f447bd23380eddab385fdd02a127576aba01fee2b22a742484c9afbba72142d35498e18f18192adf581977e3fa99adbc45e366172bcf1077f60fc1b8c2fa22d04c1c414cffe6ee798d881f11067c6c3afae7b2889290cc91f1f9ad5aacb370e40e7a7431fc57cc33908b0276854aacd34e93df9c146bc217f1be188c5fc85b09f107dee7669f4ea3692be30657e75df67735e76bf751a822c33a973a01d6bea7b2f35ab8dcb176d4084672dad005a4afef014ae39fa93148f8cc3c1bc124e7b31cd458f932821ca588f6ec1980f8a0fad2df4a3526f1ba2564c8498af3293c5c764cd9bd1834f46947f0b1377eaf2f583d363bd0f19c2ab17aa0a5968562c09f6b1069d2a9b10caacc090e79e4f6de3c8788dff17b036bdde134f255149b412dc5a4a10ff6bc7019f01553fcee354f31a94a57e79a64a3310f31a8fbb0c93c29df0f6f618e0eedb098dcc06e97b93be6297f2f50ed628cfb658b55843c77c12c6f02c4fd56f5c054afb9a77c54eb9e9db75f9919875ced4e962535efbcf0c1ff4fb9addb96648ebfbf7989c3371513a7570e27c911edf4bdc2e1a156de6808e904055c701edf2264012712b6b259687636a9a0e7c856ab7355bd9af6251c173b1d16d42d2497cb77136323ef7d4ae68824a39f674b601f766b28dd0fc2077eb3bbbc4132d9bd40812409ed767cb44a03b428fe5ce466e828ee9071f378eb331d7638fdc09189688566153f80454339e8031dab770ad31f203847b6f8c4954def69205bc290bf39be9c6ace35ab0f230b4a285d927f027df945af5ea99866e6acd2d62293980d146befe9dcddfce5a207e1d24d4cabf51a263c4baa1cc69bb6b3f8ba30e0ba58f10b5d65c2ce8a753fd07c3f0225a5643a11a40c84c5574c7f1c395f3cc9e8758e00845ad97ff5f1fbaf8cdda12bf8ec52bc1703b87e8de6c72dc1288da548b0c7340df412a276df8c71f9c24133688d387a8b6","isRememberEnabled":true,"rememberDurationInDays":0,"staticryptSaltUniqueVariableName":"ffe31c7b7ef75e2bae04cdb4d95e0b0a"};

            // you can edit these values to customize some of the behavior of StatiCrypt
            const templateConfig = {
                rememberExpirationKey: "staticrypt_expiration",
                rememberPassphraseKey: "staticrypt_passphrase",
                replaceHtmlCallback: null,
                clearLocalStorageCallback: null,
            };

            // init the staticrypt engine
            const staticrypt = staticryptInitiator.init(staticryptConfig, templateConfig);

            // try to automatically decrypt on load if there is a saved password
            window.onload = async function () {
                const { isSuccessful } = await staticrypt.handleDecryptOnLoad();

                // if we didn't decrypt anything on load, show the password prompt. Otherwise the content has already been
                // replaced, no need to do anything
                if (!isSuccessful) {
                    // hide loading screen
                    document.getElementById("staticrypt_loading").classList.add("hidden");
                    document.getElementById("staticrypt_content").classList.remove("hidden");
                    document.getElementById("staticrypt-password").focus();

                    // show the remember me checkbox
                    if (isRememberEnabled) {
                        document.getElementById("staticrypt-remember-label").classList.remove("hidden");
                    }
                }
            };

            // handle password form submission
            document.getElementById("staticrypt-form").addEventListener("submit", async function (e) {
                e.preventDefault();

                const password = document.getElementById("staticrypt-password").value,
                    isRememberChecked = document.getElementById("staticrypt-remember").checked;

                const { isSuccessful } = await staticrypt.handleDecryptionOfPage(password, isRememberChecked);

                if (!isSuccessful) {
                    alert(templateError);
                }
            });
        </script>
    </body>
</html>
